module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.30.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Absentee {
  id: ID!
  student: Student!
  classInstance: ClassInstance!
}

type AbsenteeConnection {
  pageInfo: PageInfo!
  edges: [AbsenteeEdge]!
  aggregate: AggregateAbsentee!
}

input AbsenteeCreateInput {
  student: StudentCreateOneInput!
  classInstance: ClassInstanceCreateOneWithoutAbsenteesInput!
}

input AbsenteeCreateManyWithoutClassInstanceInput {
  create: [AbsenteeCreateWithoutClassInstanceInput!]
  connect: [AbsenteeWhereUniqueInput!]
}

input AbsenteeCreateWithoutClassInstanceInput {
  student: StudentCreateOneInput!
}

type AbsenteeEdge {
  node: Absentee!
  cursor: String!
}

enum AbsenteeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AbsenteePreviousValues {
  id: ID!
}

input AbsenteeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [AbsenteeScalarWhereInput!]
  OR: [AbsenteeScalarWhereInput!]
  NOT: [AbsenteeScalarWhereInput!]
}

type AbsenteeSubscriptionPayload {
  mutation: MutationType!
  node: Absentee
  updatedFields: [String!]
  previousValues: AbsenteePreviousValues
}

input AbsenteeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AbsenteeWhereInput
  AND: [AbsenteeSubscriptionWhereInput!]
  OR: [AbsenteeSubscriptionWhereInput!]
  NOT: [AbsenteeSubscriptionWhereInput!]
}

input AbsenteeUpdateInput {
  student: StudentUpdateOneRequiredInput
  classInstance: ClassInstanceUpdateOneRequiredWithoutAbsenteesInput
}

input AbsenteeUpdateManyWithoutClassInstanceInput {
  create: [AbsenteeCreateWithoutClassInstanceInput!]
  delete: [AbsenteeWhereUniqueInput!]
  connect: [AbsenteeWhereUniqueInput!]
  set: [AbsenteeWhereUniqueInput!]
  disconnect: [AbsenteeWhereUniqueInput!]
  update: [AbsenteeUpdateWithWhereUniqueWithoutClassInstanceInput!]
  upsert: [AbsenteeUpsertWithWhereUniqueWithoutClassInstanceInput!]
  deleteMany: [AbsenteeScalarWhereInput!]
}

input AbsenteeUpdateWithoutClassInstanceDataInput {
  student: StudentUpdateOneRequiredInput
}

input AbsenteeUpdateWithWhereUniqueWithoutClassInstanceInput {
  where: AbsenteeWhereUniqueInput!
  data: AbsenteeUpdateWithoutClassInstanceDataInput!
}

input AbsenteeUpsertWithWhereUniqueWithoutClassInstanceInput {
  where: AbsenteeWhereUniqueInput!
  update: AbsenteeUpdateWithoutClassInstanceDataInput!
  create: AbsenteeCreateWithoutClassInstanceInput!
}

input AbsenteeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  student: StudentWhereInput
  classInstance: ClassInstanceWhereInput
  AND: [AbsenteeWhereInput!]
  OR: [AbsenteeWhereInput!]
  NOT: [AbsenteeWhereInput!]
}

input AbsenteeWhereUniqueInput {
  id: ID
}

type AggregateAbsentee {
  count: Int!
}

type AggregateAttendee {
  count: Int!
}

type AggregateCard {
  count: Int!
}

type AggregateClass {
  count: Int!
}

type AggregateClassInstance {
  count: Int!
}

type AggregateClassStudent {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateStudent {
  count: Int!
}

type AggregateStudio {
  count: Int!
}

type AggregateTeacher {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Attendee {
  id: ID!
  student: Student!
  classInstance: ClassInstance!
}

type AttendeeConnection {
  pageInfo: PageInfo!
  edges: [AttendeeEdge]!
  aggregate: AggregateAttendee!
}

input AttendeeCreateInput {
  student: StudentCreateOneInput!
  classInstance: ClassInstanceCreateOneWithoutAttendeesInput!
}

input AttendeeCreateManyWithoutClassInstanceInput {
  create: [AttendeeCreateWithoutClassInstanceInput!]
  connect: [AttendeeWhereUniqueInput!]
}

input AttendeeCreateWithoutClassInstanceInput {
  student: StudentCreateOneInput!
}

type AttendeeEdge {
  node: Attendee!
  cursor: String!
}

enum AttendeeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AttendeePreviousValues {
  id: ID!
}

input AttendeeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [AttendeeScalarWhereInput!]
  OR: [AttendeeScalarWhereInput!]
  NOT: [AttendeeScalarWhereInput!]
}

type AttendeeSubscriptionPayload {
  mutation: MutationType!
  node: Attendee
  updatedFields: [String!]
  previousValues: AttendeePreviousValues
}

input AttendeeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AttendeeWhereInput
  AND: [AttendeeSubscriptionWhereInput!]
  OR: [AttendeeSubscriptionWhereInput!]
  NOT: [AttendeeSubscriptionWhereInput!]
}

input AttendeeUpdateInput {
  student: StudentUpdateOneRequiredInput
  classInstance: ClassInstanceUpdateOneRequiredWithoutAttendeesInput
}

input AttendeeUpdateManyWithoutClassInstanceInput {
  create: [AttendeeCreateWithoutClassInstanceInput!]
  delete: [AttendeeWhereUniqueInput!]
  connect: [AttendeeWhereUniqueInput!]
  set: [AttendeeWhereUniqueInput!]
  disconnect: [AttendeeWhereUniqueInput!]
  update: [AttendeeUpdateWithWhereUniqueWithoutClassInstanceInput!]
  upsert: [AttendeeUpsertWithWhereUniqueWithoutClassInstanceInput!]
  deleteMany: [AttendeeScalarWhereInput!]
}

input AttendeeUpdateWithoutClassInstanceDataInput {
  student: StudentUpdateOneRequiredInput
}

input AttendeeUpdateWithWhereUniqueWithoutClassInstanceInput {
  where: AttendeeWhereUniqueInput!
  data: AttendeeUpdateWithoutClassInstanceDataInput!
}

input AttendeeUpsertWithWhereUniqueWithoutClassInstanceInput {
  where: AttendeeWhereUniqueInput!
  update: AttendeeUpdateWithoutClassInstanceDataInput!
  create: AttendeeCreateWithoutClassInstanceInput!
}

input AttendeeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  student: StudentWhereInput
  classInstance: ClassInstanceWhereInput
  AND: [AttendeeWhereInput!]
  OR: [AttendeeWhereInput!]
  NOT: [AttendeeWhereInput!]
}

input AttendeeWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Card {
  id: ID!
  student: Student
  payment: Payment
  startDate: DateTime
  expirationDate: DateTime
  validNumberOfClasses: Int!
  classes(where: ClassInstanceWhereInput, orderBy: ClassInstanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClassInstance!]
}

type CardConnection {
  pageInfo: PageInfo!
  edges: [CardEdge]!
  aggregate: AggregateCard!
}

input CardCreateInput {
  student: StudentCreateOneWithoutCardsInput
  payment: PaymentCreateOneWithoutCardInput
  startDate: DateTime
  expirationDate: DateTime
  validNumberOfClasses: Int!
  classes: ClassInstanceCreateManyInput
}

input CardCreateManyWithoutStudentInput {
  create: [CardCreateWithoutStudentInput!]
  connect: [CardWhereUniqueInput!]
}

input CardCreateOneWithoutPaymentInput {
  create: CardCreateWithoutPaymentInput
  connect: CardWhereUniqueInput
}

input CardCreateWithoutPaymentInput {
  student: StudentCreateOneWithoutCardsInput
  startDate: DateTime
  expirationDate: DateTime
  validNumberOfClasses: Int!
  classes: ClassInstanceCreateManyInput
}

input CardCreateWithoutStudentInput {
  payment: PaymentCreateOneWithoutCardInput
  startDate: DateTime
  expirationDate: DateTime
  validNumberOfClasses: Int!
  classes: ClassInstanceCreateManyInput
}

type CardEdge {
  node: Card!
  cursor: String!
}

enum CardOrderByInput {
  id_ASC
  id_DESC
  startDate_ASC
  startDate_DESC
  expirationDate_ASC
  expirationDate_DESC
  validNumberOfClasses_ASC
  validNumberOfClasses_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CardPreviousValues {
  id: ID!
  startDate: DateTime
  expirationDate: DateTime
  validNumberOfClasses: Int!
}

input CardScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  expirationDate: DateTime
  expirationDate_not: DateTime
  expirationDate_in: [DateTime!]
  expirationDate_not_in: [DateTime!]
  expirationDate_lt: DateTime
  expirationDate_lte: DateTime
  expirationDate_gt: DateTime
  expirationDate_gte: DateTime
  validNumberOfClasses: Int
  validNumberOfClasses_not: Int
  validNumberOfClasses_in: [Int!]
  validNumberOfClasses_not_in: [Int!]
  validNumberOfClasses_lt: Int
  validNumberOfClasses_lte: Int
  validNumberOfClasses_gt: Int
  validNumberOfClasses_gte: Int
  AND: [CardScalarWhereInput!]
  OR: [CardScalarWhereInput!]
  NOT: [CardScalarWhereInput!]
}

type CardSubscriptionPayload {
  mutation: MutationType!
  node: Card
  updatedFields: [String!]
  previousValues: CardPreviousValues
}

input CardSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CardWhereInput
  AND: [CardSubscriptionWhereInput!]
  OR: [CardSubscriptionWhereInput!]
  NOT: [CardSubscriptionWhereInput!]
}

input CardUpdateInput {
  student: StudentUpdateOneWithoutCardsInput
  payment: PaymentUpdateOneWithoutCardInput
  startDate: DateTime
  expirationDate: DateTime
  validNumberOfClasses: Int
  classes: ClassInstanceUpdateManyInput
}

input CardUpdateManyDataInput {
  startDate: DateTime
  expirationDate: DateTime
  validNumberOfClasses: Int
}

input CardUpdateManyMutationInput {
  startDate: DateTime
  expirationDate: DateTime
  validNumberOfClasses: Int
}

input CardUpdateManyWithoutStudentInput {
  create: [CardCreateWithoutStudentInput!]
  delete: [CardWhereUniqueInput!]
  connect: [CardWhereUniqueInput!]
  set: [CardWhereUniqueInput!]
  disconnect: [CardWhereUniqueInput!]
  update: [CardUpdateWithWhereUniqueWithoutStudentInput!]
  upsert: [CardUpsertWithWhereUniqueWithoutStudentInput!]
  deleteMany: [CardScalarWhereInput!]
  updateMany: [CardUpdateManyWithWhereNestedInput!]
}

input CardUpdateManyWithWhereNestedInput {
  where: CardScalarWhereInput!
  data: CardUpdateManyDataInput!
}

input CardUpdateOneWithoutPaymentInput {
  create: CardCreateWithoutPaymentInput
  update: CardUpdateWithoutPaymentDataInput
  upsert: CardUpsertWithoutPaymentInput
  delete: Boolean
  disconnect: Boolean
  connect: CardWhereUniqueInput
}

input CardUpdateWithoutPaymentDataInput {
  student: StudentUpdateOneWithoutCardsInput
  startDate: DateTime
  expirationDate: DateTime
  validNumberOfClasses: Int
  classes: ClassInstanceUpdateManyInput
}

input CardUpdateWithoutStudentDataInput {
  payment: PaymentUpdateOneWithoutCardInput
  startDate: DateTime
  expirationDate: DateTime
  validNumberOfClasses: Int
  classes: ClassInstanceUpdateManyInput
}

input CardUpdateWithWhereUniqueWithoutStudentInput {
  where: CardWhereUniqueInput!
  data: CardUpdateWithoutStudentDataInput!
}

input CardUpsertWithoutPaymentInput {
  update: CardUpdateWithoutPaymentDataInput!
  create: CardCreateWithoutPaymentInput!
}

input CardUpsertWithWhereUniqueWithoutStudentInput {
  where: CardWhereUniqueInput!
  update: CardUpdateWithoutStudentDataInput!
  create: CardCreateWithoutStudentInput!
}

input CardWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  student: StudentWhereInput
  payment: PaymentWhereInput
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  expirationDate: DateTime
  expirationDate_not: DateTime
  expirationDate_in: [DateTime!]
  expirationDate_not_in: [DateTime!]
  expirationDate_lt: DateTime
  expirationDate_lte: DateTime
  expirationDate_gt: DateTime
  expirationDate_gte: DateTime
  validNumberOfClasses: Int
  validNumberOfClasses_not: Int
  validNumberOfClasses_in: [Int!]
  validNumberOfClasses_not_in: [Int!]
  validNumberOfClasses_lt: Int
  validNumberOfClasses_lte: Int
  validNumberOfClasses_gt: Int
  validNumberOfClasses_gte: Int
  classes_every: ClassInstanceWhereInput
  classes_some: ClassInstanceWhereInput
  classes_none: ClassInstanceWhereInput
  AND: [CardWhereInput!]
  OR: [CardWhereInput!]
  NOT: [CardWhereInput!]
}

input CardWhereUniqueInput {
  id: ID
}

type Class {
  id: ID!
  name: String!
  description: String
  startDate: DateTime
  teachers(where: TeacherWhereInput, orderBy: TeacherOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Teacher!]
  students(where: ClassStudentWhereInput, orderBy: ClassStudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClassStudent!]
  classHistory(where: ClassInstanceWhereInput, orderBy: ClassInstanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClassInstance!]
  studentLimit: Int
}

type ClassConnection {
  pageInfo: PageInfo!
  edges: [ClassEdge]!
  aggregate: AggregateClass!
}

input ClassCreateInput {
  name: String!
  description: String
  startDate: DateTime
  teachers: TeacherCreateManyWithoutClassesInput
  students: ClassStudentCreateManyWithoutClassInput
  classHistory: ClassInstanceCreateManyWithoutParentInput
  studentLimit: Int
}

input ClassCreateManyWithoutTeachersInput {
  create: [ClassCreateWithoutTeachersInput!]
  connect: [ClassWhereUniqueInput!]
}

input ClassCreateOneWithoutClassHistoryInput {
  create: ClassCreateWithoutClassHistoryInput
  connect: ClassWhereUniqueInput
}

input ClassCreateOneWithoutStudentsInput {
  create: ClassCreateWithoutStudentsInput
  connect: ClassWhereUniqueInput
}

input ClassCreateWithoutClassHistoryInput {
  name: String!
  description: String
  startDate: DateTime
  teachers: TeacherCreateManyWithoutClassesInput
  students: ClassStudentCreateManyWithoutClassInput
  studentLimit: Int
}

input ClassCreateWithoutStudentsInput {
  name: String!
  description: String
  startDate: DateTime
  teachers: TeacherCreateManyWithoutClassesInput
  classHistory: ClassInstanceCreateManyWithoutParentInput
  studentLimit: Int
}

input ClassCreateWithoutTeachersInput {
  name: String!
  description: String
  startDate: DateTime
  students: ClassStudentCreateManyWithoutClassInput
  classHistory: ClassInstanceCreateManyWithoutParentInput
  studentLimit: Int
}

type ClassEdge {
  node: Class!
  cursor: String!
}

type ClassInstance {
  id: ID!
  parent: Class
  date: DateTime
  topic: String
  notes: String
  attendees(where: AttendeeWhereInput, orderBy: AttendeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attendee!]
  absentees(where: AbsenteeWhereInput, orderBy: AbsenteeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Absentee!]
}

type ClassInstanceConnection {
  pageInfo: PageInfo!
  edges: [ClassInstanceEdge]!
  aggregate: AggregateClassInstance!
}

input ClassInstanceCreateInput {
  parent: ClassCreateOneWithoutClassHistoryInput
  date: DateTime
  topic: String
  notes: String
  attendees: AttendeeCreateManyWithoutClassInstanceInput
  absentees: AbsenteeCreateManyWithoutClassInstanceInput
}

input ClassInstanceCreateManyInput {
  create: [ClassInstanceCreateInput!]
  connect: [ClassInstanceWhereUniqueInput!]
}

input ClassInstanceCreateManyWithoutParentInput {
  create: [ClassInstanceCreateWithoutParentInput!]
  connect: [ClassInstanceWhereUniqueInput!]
}

input ClassInstanceCreateOneWithoutAbsenteesInput {
  create: ClassInstanceCreateWithoutAbsenteesInput
  connect: ClassInstanceWhereUniqueInput
}

input ClassInstanceCreateOneWithoutAttendeesInput {
  create: ClassInstanceCreateWithoutAttendeesInput
  connect: ClassInstanceWhereUniqueInput
}

input ClassInstanceCreateWithoutAbsenteesInput {
  parent: ClassCreateOneWithoutClassHistoryInput
  date: DateTime
  topic: String
  notes: String
  attendees: AttendeeCreateManyWithoutClassInstanceInput
}

input ClassInstanceCreateWithoutAttendeesInput {
  parent: ClassCreateOneWithoutClassHistoryInput
  date: DateTime
  topic: String
  notes: String
  absentees: AbsenteeCreateManyWithoutClassInstanceInput
}

input ClassInstanceCreateWithoutParentInput {
  date: DateTime
  topic: String
  notes: String
  attendees: AttendeeCreateManyWithoutClassInstanceInput
  absentees: AbsenteeCreateManyWithoutClassInstanceInput
}

type ClassInstanceEdge {
  node: ClassInstance!
  cursor: String!
}

enum ClassInstanceOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  topic_ASC
  topic_DESC
  notes_ASC
  notes_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ClassInstancePreviousValues {
  id: ID!
  date: DateTime
  topic: String
  notes: String
}

input ClassInstanceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  topic: String
  topic_not: String
  topic_in: [String!]
  topic_not_in: [String!]
  topic_lt: String
  topic_lte: String
  topic_gt: String
  topic_gte: String
  topic_contains: String
  topic_not_contains: String
  topic_starts_with: String
  topic_not_starts_with: String
  topic_ends_with: String
  topic_not_ends_with: String
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  AND: [ClassInstanceScalarWhereInput!]
  OR: [ClassInstanceScalarWhereInput!]
  NOT: [ClassInstanceScalarWhereInput!]
}

type ClassInstanceSubscriptionPayload {
  mutation: MutationType!
  node: ClassInstance
  updatedFields: [String!]
  previousValues: ClassInstancePreviousValues
}

input ClassInstanceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClassInstanceWhereInput
  AND: [ClassInstanceSubscriptionWhereInput!]
  OR: [ClassInstanceSubscriptionWhereInput!]
  NOT: [ClassInstanceSubscriptionWhereInput!]
}

input ClassInstanceUpdateDataInput {
  parent: ClassUpdateOneWithoutClassHistoryInput
  date: DateTime
  topic: String
  notes: String
  attendees: AttendeeUpdateManyWithoutClassInstanceInput
  absentees: AbsenteeUpdateManyWithoutClassInstanceInput
}

input ClassInstanceUpdateInput {
  parent: ClassUpdateOneWithoutClassHistoryInput
  date: DateTime
  topic: String
  notes: String
  attendees: AttendeeUpdateManyWithoutClassInstanceInput
  absentees: AbsenteeUpdateManyWithoutClassInstanceInput
}

input ClassInstanceUpdateManyDataInput {
  date: DateTime
  topic: String
  notes: String
}

input ClassInstanceUpdateManyInput {
  create: [ClassInstanceCreateInput!]
  update: [ClassInstanceUpdateWithWhereUniqueNestedInput!]
  upsert: [ClassInstanceUpsertWithWhereUniqueNestedInput!]
  delete: [ClassInstanceWhereUniqueInput!]
  connect: [ClassInstanceWhereUniqueInput!]
  set: [ClassInstanceWhereUniqueInput!]
  disconnect: [ClassInstanceWhereUniqueInput!]
  deleteMany: [ClassInstanceScalarWhereInput!]
  updateMany: [ClassInstanceUpdateManyWithWhereNestedInput!]
}

input ClassInstanceUpdateManyMutationInput {
  date: DateTime
  topic: String
  notes: String
}

input ClassInstanceUpdateManyWithoutParentInput {
  create: [ClassInstanceCreateWithoutParentInput!]
  delete: [ClassInstanceWhereUniqueInput!]
  connect: [ClassInstanceWhereUniqueInput!]
  set: [ClassInstanceWhereUniqueInput!]
  disconnect: [ClassInstanceWhereUniqueInput!]
  update: [ClassInstanceUpdateWithWhereUniqueWithoutParentInput!]
  upsert: [ClassInstanceUpsertWithWhereUniqueWithoutParentInput!]
  deleteMany: [ClassInstanceScalarWhereInput!]
  updateMany: [ClassInstanceUpdateManyWithWhereNestedInput!]
}

input ClassInstanceUpdateManyWithWhereNestedInput {
  where: ClassInstanceScalarWhereInput!
  data: ClassInstanceUpdateManyDataInput!
}

input ClassInstanceUpdateOneRequiredWithoutAbsenteesInput {
  create: ClassInstanceCreateWithoutAbsenteesInput
  update: ClassInstanceUpdateWithoutAbsenteesDataInput
  upsert: ClassInstanceUpsertWithoutAbsenteesInput
  connect: ClassInstanceWhereUniqueInput
}

input ClassInstanceUpdateOneRequiredWithoutAttendeesInput {
  create: ClassInstanceCreateWithoutAttendeesInput
  update: ClassInstanceUpdateWithoutAttendeesDataInput
  upsert: ClassInstanceUpsertWithoutAttendeesInput
  connect: ClassInstanceWhereUniqueInput
}

input ClassInstanceUpdateWithoutAbsenteesDataInput {
  parent: ClassUpdateOneWithoutClassHistoryInput
  date: DateTime
  topic: String
  notes: String
  attendees: AttendeeUpdateManyWithoutClassInstanceInput
}

input ClassInstanceUpdateWithoutAttendeesDataInput {
  parent: ClassUpdateOneWithoutClassHistoryInput
  date: DateTime
  topic: String
  notes: String
  absentees: AbsenteeUpdateManyWithoutClassInstanceInput
}

input ClassInstanceUpdateWithoutParentDataInput {
  date: DateTime
  topic: String
  notes: String
  attendees: AttendeeUpdateManyWithoutClassInstanceInput
  absentees: AbsenteeUpdateManyWithoutClassInstanceInput
}

input ClassInstanceUpdateWithWhereUniqueNestedInput {
  where: ClassInstanceWhereUniqueInput!
  data: ClassInstanceUpdateDataInput!
}

input ClassInstanceUpdateWithWhereUniqueWithoutParentInput {
  where: ClassInstanceWhereUniqueInput!
  data: ClassInstanceUpdateWithoutParentDataInput!
}

input ClassInstanceUpsertWithoutAbsenteesInput {
  update: ClassInstanceUpdateWithoutAbsenteesDataInput!
  create: ClassInstanceCreateWithoutAbsenteesInput!
}

input ClassInstanceUpsertWithoutAttendeesInput {
  update: ClassInstanceUpdateWithoutAttendeesDataInput!
  create: ClassInstanceCreateWithoutAttendeesInput!
}

input ClassInstanceUpsertWithWhereUniqueNestedInput {
  where: ClassInstanceWhereUniqueInput!
  update: ClassInstanceUpdateDataInput!
  create: ClassInstanceCreateInput!
}

input ClassInstanceUpsertWithWhereUniqueWithoutParentInput {
  where: ClassInstanceWhereUniqueInput!
  update: ClassInstanceUpdateWithoutParentDataInput!
  create: ClassInstanceCreateWithoutParentInput!
}

input ClassInstanceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  parent: ClassWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  topic: String
  topic_not: String
  topic_in: [String!]
  topic_not_in: [String!]
  topic_lt: String
  topic_lte: String
  topic_gt: String
  topic_gte: String
  topic_contains: String
  topic_not_contains: String
  topic_starts_with: String
  topic_not_starts_with: String
  topic_ends_with: String
  topic_not_ends_with: String
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  attendees_every: AttendeeWhereInput
  attendees_some: AttendeeWhereInput
  attendees_none: AttendeeWhereInput
  absentees_every: AbsenteeWhereInput
  absentees_some: AbsenteeWhereInput
  absentees_none: AbsenteeWhereInput
  AND: [ClassInstanceWhereInput!]
  OR: [ClassInstanceWhereInput!]
  NOT: [ClassInstanceWhereInput!]
}

input ClassInstanceWhereUniqueInput {
  id: ID
}

enum ClassOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  startDate_ASC
  startDate_DESC
  studentLimit_ASC
  studentLimit_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ClassPreviousValues {
  id: ID!
  name: String!
  description: String
  startDate: DateTime
  studentLimit: Int
}

input ClassScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  studentLimit: Int
  studentLimit_not: Int
  studentLimit_in: [Int!]
  studentLimit_not_in: [Int!]
  studentLimit_lt: Int
  studentLimit_lte: Int
  studentLimit_gt: Int
  studentLimit_gte: Int
  AND: [ClassScalarWhereInput!]
  OR: [ClassScalarWhereInput!]
  NOT: [ClassScalarWhereInput!]
}

type ClassStudent {
  id: ID!
  student: Student!
  class: Class!
  role: DanceRole!
}

type ClassStudentConnection {
  pageInfo: PageInfo!
  edges: [ClassStudentEdge]!
  aggregate: AggregateClassStudent!
}

input ClassStudentCreateInput {
  student: StudentCreateOneWithoutClassesInput!
  class: ClassCreateOneWithoutStudentsInput!
  role: DanceRole!
}

input ClassStudentCreateManyWithoutClassInput {
  create: [ClassStudentCreateWithoutClassInput!]
  connect: [ClassStudentWhereUniqueInput!]
}

input ClassStudentCreateManyWithoutStudentInput {
  create: [ClassStudentCreateWithoutStudentInput!]
  connect: [ClassStudentWhereUniqueInput!]
}

input ClassStudentCreateWithoutClassInput {
  student: StudentCreateOneWithoutClassesInput!
  role: DanceRole!
}

input ClassStudentCreateWithoutStudentInput {
  class: ClassCreateOneWithoutStudentsInput!
  role: DanceRole!
}

type ClassStudentEdge {
  node: ClassStudent!
  cursor: String!
}

enum ClassStudentOrderByInput {
  id_ASC
  id_DESC
  role_ASC
  role_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ClassStudentPreviousValues {
  id: ID!
  role: DanceRole!
}

input ClassStudentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  role: DanceRole
  role_not: DanceRole
  role_in: [DanceRole!]
  role_not_in: [DanceRole!]
  AND: [ClassStudentScalarWhereInput!]
  OR: [ClassStudentScalarWhereInput!]
  NOT: [ClassStudentScalarWhereInput!]
}

type ClassStudentSubscriptionPayload {
  mutation: MutationType!
  node: ClassStudent
  updatedFields: [String!]
  previousValues: ClassStudentPreviousValues
}

input ClassStudentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClassStudentWhereInput
  AND: [ClassStudentSubscriptionWhereInput!]
  OR: [ClassStudentSubscriptionWhereInput!]
  NOT: [ClassStudentSubscriptionWhereInput!]
}

input ClassStudentUpdateInput {
  student: StudentUpdateOneRequiredWithoutClassesInput
  class: ClassUpdateOneRequiredWithoutStudentsInput
  role: DanceRole
}

input ClassStudentUpdateManyDataInput {
  role: DanceRole
}

input ClassStudentUpdateManyMutationInput {
  role: DanceRole
}

input ClassStudentUpdateManyWithoutClassInput {
  create: [ClassStudentCreateWithoutClassInput!]
  delete: [ClassStudentWhereUniqueInput!]
  connect: [ClassStudentWhereUniqueInput!]
  set: [ClassStudentWhereUniqueInput!]
  disconnect: [ClassStudentWhereUniqueInput!]
  update: [ClassStudentUpdateWithWhereUniqueWithoutClassInput!]
  upsert: [ClassStudentUpsertWithWhereUniqueWithoutClassInput!]
  deleteMany: [ClassStudentScalarWhereInput!]
  updateMany: [ClassStudentUpdateManyWithWhereNestedInput!]
}

input ClassStudentUpdateManyWithoutStudentInput {
  create: [ClassStudentCreateWithoutStudentInput!]
  delete: [ClassStudentWhereUniqueInput!]
  connect: [ClassStudentWhereUniqueInput!]
  set: [ClassStudentWhereUniqueInput!]
  disconnect: [ClassStudentWhereUniqueInput!]
  update: [ClassStudentUpdateWithWhereUniqueWithoutStudentInput!]
  upsert: [ClassStudentUpsertWithWhereUniqueWithoutStudentInput!]
  deleteMany: [ClassStudentScalarWhereInput!]
  updateMany: [ClassStudentUpdateManyWithWhereNestedInput!]
}

input ClassStudentUpdateManyWithWhereNestedInput {
  where: ClassStudentScalarWhereInput!
  data: ClassStudentUpdateManyDataInput!
}

input ClassStudentUpdateWithoutClassDataInput {
  student: StudentUpdateOneRequiredWithoutClassesInput
  role: DanceRole
}

input ClassStudentUpdateWithoutStudentDataInput {
  class: ClassUpdateOneRequiredWithoutStudentsInput
  role: DanceRole
}

input ClassStudentUpdateWithWhereUniqueWithoutClassInput {
  where: ClassStudentWhereUniqueInput!
  data: ClassStudentUpdateWithoutClassDataInput!
}

input ClassStudentUpdateWithWhereUniqueWithoutStudentInput {
  where: ClassStudentWhereUniqueInput!
  data: ClassStudentUpdateWithoutStudentDataInput!
}

input ClassStudentUpsertWithWhereUniqueWithoutClassInput {
  where: ClassStudentWhereUniqueInput!
  update: ClassStudentUpdateWithoutClassDataInput!
  create: ClassStudentCreateWithoutClassInput!
}

input ClassStudentUpsertWithWhereUniqueWithoutStudentInput {
  where: ClassStudentWhereUniqueInput!
  update: ClassStudentUpdateWithoutStudentDataInput!
  create: ClassStudentCreateWithoutStudentInput!
}

input ClassStudentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  student: StudentWhereInput
  class: ClassWhereInput
  role: DanceRole
  role_not: DanceRole
  role_in: [DanceRole!]
  role_not_in: [DanceRole!]
  AND: [ClassStudentWhereInput!]
  OR: [ClassStudentWhereInput!]
  NOT: [ClassStudentWhereInput!]
}

input ClassStudentWhereUniqueInput {
  id: ID
}

type ClassSubscriptionPayload {
  mutation: MutationType!
  node: Class
  updatedFields: [String!]
  previousValues: ClassPreviousValues
}

input ClassSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClassWhereInput
  AND: [ClassSubscriptionWhereInput!]
  OR: [ClassSubscriptionWhereInput!]
  NOT: [ClassSubscriptionWhereInput!]
}

input ClassUpdateInput {
  name: String
  description: String
  startDate: DateTime
  teachers: TeacherUpdateManyWithoutClassesInput
  students: ClassStudentUpdateManyWithoutClassInput
  classHistory: ClassInstanceUpdateManyWithoutParentInput
  studentLimit: Int
}

input ClassUpdateManyDataInput {
  name: String
  description: String
  startDate: DateTime
  studentLimit: Int
}

input ClassUpdateManyMutationInput {
  name: String
  description: String
  startDate: DateTime
  studentLimit: Int
}

input ClassUpdateManyWithoutTeachersInput {
  create: [ClassCreateWithoutTeachersInput!]
  delete: [ClassWhereUniqueInput!]
  connect: [ClassWhereUniqueInput!]
  set: [ClassWhereUniqueInput!]
  disconnect: [ClassWhereUniqueInput!]
  update: [ClassUpdateWithWhereUniqueWithoutTeachersInput!]
  upsert: [ClassUpsertWithWhereUniqueWithoutTeachersInput!]
  deleteMany: [ClassScalarWhereInput!]
  updateMany: [ClassUpdateManyWithWhereNestedInput!]
}

input ClassUpdateManyWithWhereNestedInput {
  where: ClassScalarWhereInput!
  data: ClassUpdateManyDataInput!
}

input ClassUpdateOneRequiredWithoutStudentsInput {
  create: ClassCreateWithoutStudentsInput
  update: ClassUpdateWithoutStudentsDataInput
  upsert: ClassUpsertWithoutStudentsInput
  connect: ClassWhereUniqueInput
}

input ClassUpdateOneWithoutClassHistoryInput {
  create: ClassCreateWithoutClassHistoryInput
  update: ClassUpdateWithoutClassHistoryDataInput
  upsert: ClassUpsertWithoutClassHistoryInput
  delete: Boolean
  disconnect: Boolean
  connect: ClassWhereUniqueInput
}

input ClassUpdateWithoutClassHistoryDataInput {
  name: String
  description: String
  startDate: DateTime
  teachers: TeacherUpdateManyWithoutClassesInput
  students: ClassStudentUpdateManyWithoutClassInput
  studentLimit: Int
}

input ClassUpdateWithoutStudentsDataInput {
  name: String
  description: String
  startDate: DateTime
  teachers: TeacherUpdateManyWithoutClassesInput
  classHistory: ClassInstanceUpdateManyWithoutParentInput
  studentLimit: Int
}

input ClassUpdateWithoutTeachersDataInput {
  name: String
  description: String
  startDate: DateTime
  students: ClassStudentUpdateManyWithoutClassInput
  classHistory: ClassInstanceUpdateManyWithoutParentInput
  studentLimit: Int
}

input ClassUpdateWithWhereUniqueWithoutTeachersInput {
  where: ClassWhereUniqueInput!
  data: ClassUpdateWithoutTeachersDataInput!
}

input ClassUpsertWithoutClassHistoryInput {
  update: ClassUpdateWithoutClassHistoryDataInput!
  create: ClassCreateWithoutClassHistoryInput!
}

input ClassUpsertWithoutStudentsInput {
  update: ClassUpdateWithoutStudentsDataInput!
  create: ClassCreateWithoutStudentsInput!
}

input ClassUpsertWithWhereUniqueWithoutTeachersInput {
  where: ClassWhereUniqueInput!
  update: ClassUpdateWithoutTeachersDataInput!
  create: ClassCreateWithoutTeachersInput!
}

input ClassWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  teachers_every: TeacherWhereInput
  teachers_some: TeacherWhereInput
  teachers_none: TeacherWhereInput
  students_every: ClassStudentWhereInput
  students_some: ClassStudentWhereInput
  students_none: ClassStudentWhereInput
  classHistory_every: ClassInstanceWhereInput
  classHistory_some: ClassInstanceWhereInput
  classHistory_none: ClassInstanceWhereInput
  studentLimit: Int
  studentLimit_not: Int
  studentLimit_in: [Int!]
  studentLimit_not_in: [Int!]
  studentLimit_lt: Int
  studentLimit_lte: Int
  studentLimit_gt: Int
  studentLimit_gte: Int
  AND: [ClassWhereInput!]
  OR: [ClassWhereInput!]
  NOT: [ClassWhereInput!]
}

input ClassWhereUniqueInput {
  id: ID
}

enum DanceRole {
  Leader
  Follower
  Solo
}

scalar DateTime

scalar Long

type Mutation {
  createAbsentee(data: AbsenteeCreateInput!): Absentee!
  updateAbsentee(data: AbsenteeUpdateInput!, where: AbsenteeWhereUniqueInput!): Absentee
  upsertAbsentee(where: AbsenteeWhereUniqueInput!, create: AbsenteeCreateInput!, update: AbsenteeUpdateInput!): Absentee!
  deleteAbsentee(where: AbsenteeWhereUniqueInput!): Absentee
  deleteManyAbsentees(where: AbsenteeWhereInput): BatchPayload!
  createAttendee(data: AttendeeCreateInput!): Attendee!
  updateAttendee(data: AttendeeUpdateInput!, where: AttendeeWhereUniqueInput!): Attendee
  upsertAttendee(where: AttendeeWhereUniqueInput!, create: AttendeeCreateInput!, update: AttendeeUpdateInput!): Attendee!
  deleteAttendee(where: AttendeeWhereUniqueInput!): Attendee
  deleteManyAttendees(where: AttendeeWhereInput): BatchPayload!
  createCard(data: CardCreateInput!): Card!
  updateCard(data: CardUpdateInput!, where: CardWhereUniqueInput!): Card
  updateManyCards(data: CardUpdateManyMutationInput!, where: CardWhereInput): BatchPayload!
  upsertCard(where: CardWhereUniqueInput!, create: CardCreateInput!, update: CardUpdateInput!): Card!
  deleteCard(where: CardWhereUniqueInput!): Card
  deleteManyCards(where: CardWhereInput): BatchPayload!
  createClass(data: ClassCreateInput!): Class!
  updateClass(data: ClassUpdateInput!, where: ClassWhereUniqueInput!): Class
  updateManyClasses(data: ClassUpdateManyMutationInput!, where: ClassWhereInput): BatchPayload!
  upsertClass(where: ClassWhereUniqueInput!, create: ClassCreateInput!, update: ClassUpdateInput!): Class!
  deleteClass(where: ClassWhereUniqueInput!): Class
  deleteManyClasses(where: ClassWhereInput): BatchPayload!
  createClassInstance(data: ClassInstanceCreateInput!): ClassInstance!
  updateClassInstance(data: ClassInstanceUpdateInput!, where: ClassInstanceWhereUniqueInput!): ClassInstance
  updateManyClassInstances(data: ClassInstanceUpdateManyMutationInput!, where: ClassInstanceWhereInput): BatchPayload!
  upsertClassInstance(where: ClassInstanceWhereUniqueInput!, create: ClassInstanceCreateInput!, update: ClassInstanceUpdateInput!): ClassInstance!
  deleteClassInstance(where: ClassInstanceWhereUniqueInput!): ClassInstance
  deleteManyClassInstances(where: ClassInstanceWhereInput): BatchPayload!
  createClassStudent(data: ClassStudentCreateInput!): ClassStudent!
  updateClassStudent(data: ClassStudentUpdateInput!, where: ClassStudentWhereUniqueInput!): ClassStudent
  updateManyClassStudents(data: ClassStudentUpdateManyMutationInput!, where: ClassStudentWhereInput): BatchPayload!
  upsertClassStudent(where: ClassStudentWhereUniqueInput!, create: ClassStudentCreateInput!, update: ClassStudentUpdateInput!): ClassStudent!
  deleteClassStudent(where: ClassStudentWhereUniqueInput!): ClassStudent
  deleteManyClassStudents(where: ClassStudentWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createRoom(data: RoomCreateInput!): Room!
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateManyRooms(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  createStudent(data: StudentCreateInput!): Student!
  updateStudent(data: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student
  updateManyStudents(data: StudentUpdateManyMutationInput!, where: StudentWhereInput): BatchPayload!
  upsertStudent(where: StudentWhereUniqueInput!, create: StudentCreateInput!, update: StudentUpdateInput!): Student!
  deleteStudent(where: StudentWhereUniqueInput!): Student
  deleteManyStudents(where: StudentWhereInput): BatchPayload!
  createStudio(data: StudioCreateInput!): Studio!
  updateStudio(data: StudioUpdateInput!, where: StudioWhereUniqueInput!): Studio
  updateManyStudios(data: StudioUpdateManyMutationInput!, where: StudioWhereInput): BatchPayload!
  upsertStudio(where: StudioWhereUniqueInput!, create: StudioCreateInput!, update: StudioUpdateInput!): Studio!
  deleteStudio(where: StudioWhereUniqueInput!): Studio
  deleteManyStudios(where: StudioWhereInput): BatchPayload!
  createTeacher(data: TeacherCreateInput!): Teacher!
  updateTeacher(data: TeacherUpdateInput!, where: TeacherWhereUniqueInput!): Teacher
  updateManyTeachers(data: TeacherUpdateManyMutationInput!, where: TeacherWhereInput): BatchPayload!
  upsertTeacher(where: TeacherWhereUniqueInput!, create: TeacherCreateInput!, update: TeacherUpdateInput!): Teacher!
  deleteTeacher(where: TeacherWhereUniqueInput!): Teacher
  deleteManyTeachers(where: TeacherWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  type: PaymentType!
  date: DateTime!
  amount: Int!
  student: Student
  card: Card
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  type: PaymentType!
  date: DateTime!
  amount: Int!
  student: StudentCreateOneInput
  card: CardCreateOneWithoutPaymentInput
}

input PaymentCreateOneWithoutCardInput {
  create: PaymentCreateWithoutCardInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutCardInput {
  type: PaymentType!
  date: DateTime!
  amount: Int!
  student: StudentCreateOneInput
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  date_ASC
  date_DESC
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PaymentPreviousValues {
  id: ID!
  type: PaymentType!
  date: DateTime!
  amount: Int!
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

enum PaymentType {
  Class
  Private
  DropIn
}

input PaymentUpdateInput {
  type: PaymentType
  date: DateTime
  amount: Int
  student: StudentUpdateOneInput
  card: CardUpdateOneWithoutPaymentInput
}

input PaymentUpdateManyMutationInput {
  type: PaymentType
  date: DateTime
  amount: Int
}

input PaymentUpdateOneWithoutCardInput {
  create: PaymentCreateWithoutCardInput
  update: PaymentUpdateWithoutCardDataInput
  upsert: PaymentUpsertWithoutCardInput
  delete: Boolean
  disconnect: Boolean
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutCardDataInput {
  type: PaymentType
  date: DateTime
  amount: Int
  student: StudentUpdateOneInput
}

input PaymentUpsertWithoutCardInput {
  update: PaymentUpdateWithoutCardDataInput!
  create: PaymentCreateWithoutCardInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: PaymentType
  type_not: PaymentType
  type_in: [PaymentType!]
  type_not_in: [PaymentType!]
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  student: StudentWhereInput
  card: CardWhereInput
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type Query {
  absentee(where: AbsenteeWhereUniqueInput!): Absentee
  absentees(where: AbsenteeWhereInput, orderBy: AbsenteeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Absentee]!
  absenteesConnection(where: AbsenteeWhereInput, orderBy: AbsenteeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AbsenteeConnection!
  attendee(where: AttendeeWhereUniqueInput!): Attendee
  attendees(where: AttendeeWhereInput, orderBy: AttendeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attendee]!
  attendeesConnection(where: AttendeeWhereInput, orderBy: AttendeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AttendeeConnection!
  card(where: CardWhereUniqueInput!): Card
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card]!
  cardsConnection(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CardConnection!
  class(where: ClassWhereUniqueInput!): Class
  classes(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Class]!
  classesConnection(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClassConnection!
  classInstance(where: ClassInstanceWhereUniqueInput!): ClassInstance
  classInstances(where: ClassInstanceWhereInput, orderBy: ClassInstanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClassInstance]!
  classInstancesConnection(where: ClassInstanceWhereInput, orderBy: ClassInstanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClassInstanceConnection!
  classStudent(where: ClassStudentWhereUniqueInput!): ClassStudent
  classStudents(where: ClassStudentWhereInput, orderBy: ClassStudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClassStudent]!
  classStudentsConnection(where: ClassStudentWhereInput, orderBy: ClassStudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClassStudentConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  room(where: RoomWhereUniqueInput!): Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  student(where: StudentWhereUniqueInput!): Student
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student]!
  studentsConnection(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudentConnection!
  studio(where: StudioWhereUniqueInput!): Studio
  studios(where: StudioWhereInput, orderBy: StudioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Studio]!
  studiosConnection(where: StudioWhereInput, orderBy: StudioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudioConnection!
  teacher(where: TeacherWhereUniqueInput!): Teacher
  teachers(where: TeacherWhereInput, orderBy: TeacherOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Teacher]!
  teachersConnection(where: TeacherWhereInput, orderBy: TeacherOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeacherConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Room {
  id: ID!
  name: String
  capacity: Int
  studio: Studio!
}

type RoomConnection {
  pageInfo: PageInfo!
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  name: String
  capacity: Int
  studio: StudioCreateOneWithoutRoomsInput!
}

input RoomCreateManyWithoutStudioInput {
  create: [RoomCreateWithoutStudioInput!]
  connect: [RoomWhereUniqueInput!]
}

input RoomCreateWithoutStudioInput {
  name: String
  capacity: Int
}

type RoomEdge {
  node: Room!
  cursor: String!
}

enum RoomOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  capacity_ASC
  capacity_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RoomPreviousValues {
  id: ID!
  name: String
  capacity: Int
}

input RoomScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  capacity: Int
  capacity_not: Int
  capacity_in: [Int!]
  capacity_not_in: [Int!]
  capacity_lt: Int
  capacity_lte: Int
  capacity_gt: Int
  capacity_gte: Int
  AND: [RoomScalarWhereInput!]
  OR: [RoomScalarWhereInput!]
  NOT: [RoomScalarWhereInput!]
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
  AND: [RoomSubscriptionWhereInput!]
  OR: [RoomSubscriptionWhereInput!]
  NOT: [RoomSubscriptionWhereInput!]
}

input RoomUpdateInput {
  name: String
  capacity: Int
  studio: StudioUpdateOneRequiredWithoutRoomsInput
}

input RoomUpdateManyDataInput {
  name: String
  capacity: Int
}

input RoomUpdateManyMutationInput {
  name: String
  capacity: Int
}

input RoomUpdateManyWithoutStudioInput {
  create: [RoomCreateWithoutStudioInput!]
  delete: [RoomWhereUniqueInput!]
  connect: [RoomWhereUniqueInput!]
  set: [RoomWhereUniqueInput!]
  disconnect: [RoomWhereUniqueInput!]
  update: [RoomUpdateWithWhereUniqueWithoutStudioInput!]
  upsert: [RoomUpsertWithWhereUniqueWithoutStudioInput!]
  deleteMany: [RoomScalarWhereInput!]
  updateMany: [RoomUpdateManyWithWhereNestedInput!]
}

input RoomUpdateManyWithWhereNestedInput {
  where: RoomScalarWhereInput!
  data: RoomUpdateManyDataInput!
}

input RoomUpdateWithoutStudioDataInput {
  name: String
  capacity: Int
}

input RoomUpdateWithWhereUniqueWithoutStudioInput {
  where: RoomWhereUniqueInput!
  data: RoomUpdateWithoutStudioDataInput!
}

input RoomUpsertWithWhereUniqueWithoutStudioInput {
  where: RoomWhereUniqueInput!
  update: RoomUpdateWithoutStudioDataInput!
  create: RoomCreateWithoutStudioInput!
}

input RoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  capacity: Int
  capacity_not: Int
  capacity_in: [Int!]
  capacity_not_in: [Int!]
  capacity_lt: Int
  capacity_lte: Int
  capacity_gt: Int
  capacity_gte: Int
  studio: StudioWhereInput
  AND: [RoomWhereInput!]
  OR: [RoomWhereInput!]
  NOT: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  id: ID
}

type Student {
  id: ID!
  name: String!
  email: String!
  mobile: String
  classes(where: ClassStudentWhereInput, orderBy: ClassStudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ClassStudent!]
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card!]
  hasReferralBonus: Boolean!
}

type StudentConnection {
  pageInfo: PageInfo!
  edges: [StudentEdge]!
  aggregate: AggregateStudent!
}

input StudentCreateInput {
  name: String!
  email: String!
  mobile: String
  classes: ClassStudentCreateManyWithoutStudentInput
  cards: CardCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
}

input StudentCreateOneInput {
  create: StudentCreateInput
  connect: StudentWhereUniqueInput
}

input StudentCreateOneWithoutCardsInput {
  create: StudentCreateWithoutCardsInput
  connect: StudentWhereUniqueInput
}

input StudentCreateOneWithoutClassesInput {
  create: StudentCreateWithoutClassesInput
  connect: StudentWhereUniqueInput
}

input StudentCreateWithoutCardsInput {
  name: String!
  email: String!
  mobile: String
  classes: ClassStudentCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
}

input StudentCreateWithoutClassesInput {
  name: String!
  email: String!
  mobile: String
  cards: CardCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
}

type StudentEdge {
  node: Student!
  cursor: String!
}

enum StudentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  mobile_ASC
  mobile_DESC
  hasReferralBonus_ASC
  hasReferralBonus_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StudentPreviousValues {
  id: ID!
  name: String!
  email: String!
  mobile: String
  hasReferralBonus: Boolean!
}

type StudentSubscriptionPayload {
  mutation: MutationType!
  node: Student
  updatedFields: [String!]
  previousValues: StudentPreviousValues
}

input StudentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudentWhereInput
  AND: [StudentSubscriptionWhereInput!]
  OR: [StudentSubscriptionWhereInput!]
  NOT: [StudentSubscriptionWhereInput!]
}

input StudentUpdateDataInput {
  name: String
  email: String
  mobile: String
  classes: ClassStudentUpdateManyWithoutStudentInput
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
}

input StudentUpdateInput {
  name: String
  email: String
  mobile: String
  classes: ClassStudentUpdateManyWithoutStudentInput
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
}

input StudentUpdateManyMutationInput {
  name: String
  email: String
  mobile: String
  hasReferralBonus: Boolean
}

input StudentUpdateOneInput {
  create: StudentCreateInput
  update: StudentUpdateDataInput
  upsert: StudentUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: StudentWhereUniqueInput
}

input StudentUpdateOneRequiredInput {
  create: StudentCreateInput
  update: StudentUpdateDataInput
  upsert: StudentUpsertNestedInput
  connect: StudentWhereUniqueInput
}

input StudentUpdateOneRequiredWithoutClassesInput {
  create: StudentCreateWithoutClassesInput
  update: StudentUpdateWithoutClassesDataInput
  upsert: StudentUpsertWithoutClassesInput
  connect: StudentWhereUniqueInput
}

input StudentUpdateOneWithoutCardsInput {
  create: StudentCreateWithoutCardsInput
  update: StudentUpdateWithoutCardsDataInput
  upsert: StudentUpsertWithoutCardsInput
  delete: Boolean
  disconnect: Boolean
  connect: StudentWhereUniqueInput
}

input StudentUpdateWithoutCardsDataInput {
  name: String
  email: String
  mobile: String
  classes: ClassStudentUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
}

input StudentUpdateWithoutClassesDataInput {
  name: String
  email: String
  mobile: String
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
}

input StudentUpsertNestedInput {
  update: StudentUpdateDataInput!
  create: StudentCreateInput!
}

input StudentUpsertWithoutCardsInput {
  update: StudentUpdateWithoutCardsDataInput!
  create: StudentCreateWithoutCardsInput!
}

input StudentUpsertWithoutClassesInput {
  update: StudentUpdateWithoutClassesDataInput!
  create: StudentCreateWithoutClassesInput!
}

input StudentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobile: String
  mobile_not: String
  mobile_in: [String!]
  mobile_not_in: [String!]
  mobile_lt: String
  mobile_lte: String
  mobile_gt: String
  mobile_gte: String
  mobile_contains: String
  mobile_not_contains: String
  mobile_starts_with: String
  mobile_not_starts_with: String
  mobile_ends_with: String
  mobile_not_ends_with: String
  classes_every: ClassStudentWhereInput
  classes_some: ClassStudentWhereInput
  classes_none: ClassStudentWhereInput
  cards_every: CardWhereInput
  cards_some: CardWhereInput
  cards_none: CardWhereInput
  hasReferralBonus: Boolean
  hasReferralBonus_not: Boolean
  AND: [StudentWhereInput!]
  OR: [StudentWhereInput!]
  NOT: [StudentWhereInput!]
}

input StudentWhereUniqueInput {
  id: ID
}

type Studio {
  id: ID!
  name: String
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room!]
  address: String
}

type StudioConnection {
  pageInfo: PageInfo!
  edges: [StudioEdge]!
  aggregate: AggregateStudio!
}

input StudioCreateInput {
  name: String
  rooms: RoomCreateManyWithoutStudioInput
  address: String
}

input StudioCreateOneWithoutRoomsInput {
  create: StudioCreateWithoutRoomsInput
  connect: StudioWhereUniqueInput
}

input StudioCreateWithoutRoomsInput {
  name: String
  address: String
}

type StudioEdge {
  node: Studio!
  cursor: String!
}

enum StudioOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  address_ASC
  address_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StudioPreviousValues {
  id: ID!
  name: String
  address: String
}

type StudioSubscriptionPayload {
  mutation: MutationType!
  node: Studio
  updatedFields: [String!]
  previousValues: StudioPreviousValues
}

input StudioSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudioWhereInput
  AND: [StudioSubscriptionWhereInput!]
  OR: [StudioSubscriptionWhereInput!]
  NOT: [StudioSubscriptionWhereInput!]
}

input StudioUpdateInput {
  name: String
  rooms: RoomUpdateManyWithoutStudioInput
  address: String
}

input StudioUpdateManyMutationInput {
  name: String
  address: String
}

input StudioUpdateOneRequiredWithoutRoomsInput {
  create: StudioCreateWithoutRoomsInput
  update: StudioUpdateWithoutRoomsDataInput
  upsert: StudioUpsertWithoutRoomsInput
  connect: StudioWhereUniqueInput
}

input StudioUpdateWithoutRoomsDataInput {
  name: String
  address: String
}

input StudioUpsertWithoutRoomsInput {
  update: StudioUpdateWithoutRoomsDataInput!
  create: StudioCreateWithoutRoomsInput!
}

input StudioWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  rooms_every: RoomWhereInput
  rooms_some: RoomWhereInput
  rooms_none: RoomWhereInput
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  AND: [StudioWhereInput!]
  OR: [StudioWhereInput!]
  NOT: [StudioWhereInput!]
}

input StudioWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  absentee(where: AbsenteeSubscriptionWhereInput): AbsenteeSubscriptionPayload
  attendee(where: AttendeeSubscriptionWhereInput): AttendeeSubscriptionPayload
  card(where: CardSubscriptionWhereInput): CardSubscriptionPayload
  class(where: ClassSubscriptionWhereInput): ClassSubscriptionPayload
  classInstance(where: ClassInstanceSubscriptionWhereInput): ClassInstanceSubscriptionPayload
  classStudent(where: ClassStudentSubscriptionWhereInput): ClassStudentSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  student(where: StudentSubscriptionWhereInput): StudentSubscriptionPayload
  studio(where: StudioSubscriptionWhereInput): StudioSubscriptionPayload
  teacher(where: TeacherSubscriptionWhereInput): TeacherSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Teacher {
  id: ID!
  name: String!
  email: String!
  mobile: String
  classes(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Class!]
}

type TeacherConnection {
  pageInfo: PageInfo!
  edges: [TeacherEdge]!
  aggregate: AggregateTeacher!
}

input TeacherCreateInput {
  name: String!
  email: String!
  mobile: String
  classes: ClassCreateManyWithoutTeachersInput
}

input TeacherCreateManyWithoutClassesInput {
  create: [TeacherCreateWithoutClassesInput!]
  connect: [TeacherWhereUniqueInput!]
}

input TeacherCreateWithoutClassesInput {
  name: String!
  email: String!
  mobile: String
}

type TeacherEdge {
  node: Teacher!
  cursor: String!
}

enum TeacherOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  mobile_ASC
  mobile_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TeacherPreviousValues {
  id: ID!
  name: String!
  email: String!
  mobile: String
}

input TeacherScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobile: String
  mobile_not: String
  mobile_in: [String!]
  mobile_not_in: [String!]
  mobile_lt: String
  mobile_lte: String
  mobile_gt: String
  mobile_gte: String
  mobile_contains: String
  mobile_not_contains: String
  mobile_starts_with: String
  mobile_not_starts_with: String
  mobile_ends_with: String
  mobile_not_ends_with: String
  AND: [TeacherScalarWhereInput!]
  OR: [TeacherScalarWhereInput!]
  NOT: [TeacherScalarWhereInput!]
}

type TeacherSubscriptionPayload {
  mutation: MutationType!
  node: Teacher
  updatedFields: [String!]
  previousValues: TeacherPreviousValues
}

input TeacherSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeacherWhereInput
  AND: [TeacherSubscriptionWhereInput!]
  OR: [TeacherSubscriptionWhereInput!]
  NOT: [TeacherSubscriptionWhereInput!]
}

input TeacherUpdateInput {
  name: String
  email: String
  mobile: String
  classes: ClassUpdateManyWithoutTeachersInput
}

input TeacherUpdateManyDataInput {
  name: String
  email: String
  mobile: String
}

input TeacherUpdateManyMutationInput {
  name: String
  email: String
  mobile: String
}

input TeacherUpdateManyWithoutClassesInput {
  create: [TeacherCreateWithoutClassesInput!]
  delete: [TeacherWhereUniqueInput!]
  connect: [TeacherWhereUniqueInput!]
  set: [TeacherWhereUniqueInput!]
  disconnect: [TeacherWhereUniqueInput!]
  update: [TeacherUpdateWithWhereUniqueWithoutClassesInput!]
  upsert: [TeacherUpsertWithWhereUniqueWithoutClassesInput!]
  deleteMany: [TeacherScalarWhereInput!]
  updateMany: [TeacherUpdateManyWithWhereNestedInput!]
}

input TeacherUpdateManyWithWhereNestedInput {
  where: TeacherScalarWhereInput!
  data: TeacherUpdateManyDataInput!
}

input TeacherUpdateWithoutClassesDataInput {
  name: String
  email: String
  mobile: String
}

input TeacherUpdateWithWhereUniqueWithoutClassesInput {
  where: TeacherWhereUniqueInput!
  data: TeacherUpdateWithoutClassesDataInput!
}

input TeacherUpsertWithWhereUniqueWithoutClassesInput {
  where: TeacherWhereUniqueInput!
  update: TeacherUpdateWithoutClassesDataInput!
  create: TeacherCreateWithoutClassesInput!
}

input TeacherWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobile: String
  mobile_not: String
  mobile_in: [String!]
  mobile_not_in: [String!]
  mobile_lt: String
  mobile_lte: String
  mobile_gt: String
  mobile_gte: String
  mobile_contains: String
  mobile_not_contains: String
  mobile_starts_with: String
  mobile_not_starts_with: String
  mobile_ends_with: String
  mobile_not_ends_with: String
  classes_every: ClassWhereInput
  classes_some: ClassWhereInput
  classes_none: ClassWhereInput
  AND: [TeacherWhereInput!]
  OR: [TeacherWhereInput!]
  NOT: [TeacherWhereInput!]
}

input TeacherWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  email: String
  password: String!
  name: String!
  admin: Boolean!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  email: String
  password: String!
  name: String!
  admin: Boolean
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  admin_ASC
  admin_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String
  password: String!
  name: String!
  admin: Boolean!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  password: String
  name: String
  admin: Boolean
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  name: String
  admin: Boolean
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  admin: Boolean
  admin_not: Boolean
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    