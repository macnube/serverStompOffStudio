module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCard {
  count: Int!
}

type AggregateCourse {
  count: Int!
}

type AggregateCourseAbsence {
  count: Int!
}

type AggregateCourseInstance {
  count: Int!
}

type AggregateExpense {
  count: Int!
}

type AggregateLoginResponse {
  count: Int!
}

type AggregateMembership {
  count: Int!
}

type AggregateParticipant {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateStudent {
  count: Int!
}

type AggregateStudio {
  count: Int!
}

type AggregateTeacher {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Card {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  student: Student!
  payment: Payment
  expirationDate: DateTime
  active: Boolean!
  paid: Boolean!
  value: Int!
  originalValue: Int!
  participationHistory(where: ParticipantWhereInput, orderBy: ParticipantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Participant!]
}

type CardConnection {
  pageInfo: PageInfo!
  edges: [CardEdge]!
  aggregate: AggregateCard!
}

input CardCreateInput {
  id: ID
  student: StudentCreateOneWithoutCardsInput!
  payment: PaymentCreateOneWithoutCardInput
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int!
  originalValue: Int!
  participationHistory: ParticipantCreateManyInput
}

input CardCreateManyWithoutStudentInput {
  create: [CardCreateWithoutStudentInput!]
  connect: [CardWhereUniqueInput!]
}

input CardCreateOneWithoutPaymentInput {
  create: CardCreateWithoutPaymentInput
  connect: CardWhereUniqueInput
}

input CardCreateWithoutPaymentInput {
  id: ID
  student: StudentCreateOneWithoutCardsInput!
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int!
  originalValue: Int!
  participationHistory: ParticipantCreateManyInput
}

input CardCreateWithoutStudentInput {
  id: ID
  payment: PaymentCreateOneWithoutCardInput
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int!
  originalValue: Int!
  participationHistory: ParticipantCreateManyInput
}

type CardEdge {
  node: Card!
  cursor: String!
}

enum CardOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  expirationDate_ASC
  expirationDate_DESC
  active_ASC
  active_DESC
  paid_ASC
  paid_DESC
  value_ASC
  value_DESC
  originalValue_ASC
  originalValue_DESC
}

type CardPreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  expirationDate: DateTime
  active: Boolean!
  paid: Boolean!
  value: Int!
  originalValue: Int!
}

input CardScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  expirationDate: DateTime
  expirationDate_not: DateTime
  expirationDate_in: [DateTime!]
  expirationDate_not_in: [DateTime!]
  expirationDate_lt: DateTime
  expirationDate_lte: DateTime
  expirationDate_gt: DateTime
  expirationDate_gte: DateTime
  active: Boolean
  active_not: Boolean
  paid: Boolean
  paid_not: Boolean
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  originalValue: Int
  originalValue_not: Int
  originalValue_in: [Int!]
  originalValue_not_in: [Int!]
  originalValue_lt: Int
  originalValue_lte: Int
  originalValue_gt: Int
  originalValue_gte: Int
  AND: [CardScalarWhereInput!]
  OR: [CardScalarWhereInput!]
  NOT: [CardScalarWhereInput!]
}

type CardSubscriptionPayload {
  mutation: MutationType!
  node: Card
  updatedFields: [String!]
  previousValues: CardPreviousValues
}

input CardSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CardWhereInput
  AND: [CardSubscriptionWhereInput!]
  OR: [CardSubscriptionWhereInput!]
  NOT: [CardSubscriptionWhereInput!]
}

input CardUpdateInput {
  student: StudentUpdateOneRequiredWithoutCardsInput
  payment: PaymentUpdateOneWithoutCardInput
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int
  originalValue: Int
  participationHistory: ParticipantUpdateManyInput
}

input CardUpdateManyDataInput {
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int
  originalValue: Int
}

input CardUpdateManyMutationInput {
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int
  originalValue: Int
}

input CardUpdateManyWithoutStudentInput {
  create: [CardCreateWithoutStudentInput!]
  delete: [CardWhereUniqueInput!]
  connect: [CardWhereUniqueInput!]
  set: [CardWhereUniqueInput!]
  disconnect: [CardWhereUniqueInput!]
  update: [CardUpdateWithWhereUniqueWithoutStudentInput!]
  upsert: [CardUpsertWithWhereUniqueWithoutStudentInput!]
  deleteMany: [CardScalarWhereInput!]
  updateMany: [CardUpdateManyWithWhereNestedInput!]
}

input CardUpdateManyWithWhereNestedInput {
  where: CardScalarWhereInput!
  data: CardUpdateManyDataInput!
}

input CardUpdateOneWithoutPaymentInput {
  create: CardCreateWithoutPaymentInput
  update: CardUpdateWithoutPaymentDataInput
  upsert: CardUpsertWithoutPaymentInput
  delete: Boolean
  disconnect: Boolean
  connect: CardWhereUniqueInput
}

input CardUpdateWithoutPaymentDataInput {
  student: StudentUpdateOneRequiredWithoutCardsInput
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int
  originalValue: Int
  participationHistory: ParticipantUpdateManyInput
}

input CardUpdateWithoutStudentDataInput {
  payment: PaymentUpdateOneWithoutCardInput
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int
  originalValue: Int
  participationHistory: ParticipantUpdateManyInput
}

input CardUpdateWithWhereUniqueWithoutStudentInput {
  where: CardWhereUniqueInput!
  data: CardUpdateWithoutStudentDataInput!
}

input CardUpsertWithoutPaymentInput {
  update: CardUpdateWithoutPaymentDataInput!
  create: CardCreateWithoutPaymentInput!
}

input CardUpsertWithWhereUniqueWithoutStudentInput {
  where: CardWhereUniqueInput!
  update: CardUpdateWithoutStudentDataInput!
  create: CardCreateWithoutStudentInput!
}

input CardWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  student: StudentWhereInput
  payment: PaymentWhereInput
  expirationDate: DateTime
  expirationDate_not: DateTime
  expirationDate_in: [DateTime!]
  expirationDate_not_in: [DateTime!]
  expirationDate_lt: DateTime
  expirationDate_lte: DateTime
  expirationDate_gt: DateTime
  expirationDate_gte: DateTime
  active: Boolean
  active_not: Boolean
  paid: Boolean
  paid_not: Boolean
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  originalValue: Int
  originalValue_not: Int
  originalValue_in: [Int!]
  originalValue_not_in: [Int!]
  originalValue_lt: Int
  originalValue_lte: Int
  originalValue_gt: Int
  originalValue_gte: Int
  participationHistory_every: ParticipantWhereInput
  participationHistory_some: ParticipantWhereInput
  participationHistory_none: ParticipantWhereInput
  AND: [CardWhereInput!]
  OR: [CardWhereInput!]
  NOT: [CardWhereInput!]
}

input CardWhereUniqueInput {
  id: ID
}

type Course {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers(where: TeacherWhereInput, orderBy: TeacherOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Teacher!]
  memberships(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership!]
  instances(where: CourseInstanceWhereInput, orderBy: CourseInstanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseInstance!]
  studentLimit: Int
  room: Room
  absences(where: CourseAbsenceWhereInput, orderBy: CourseAbsenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseAbsence!]
}

type CourseAbsence {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  date: DateTime!
  student: Student!
  course: Course!
}

type CourseAbsenceConnection {
  pageInfo: PageInfo!
  edges: [CourseAbsenceEdge]!
  aggregate: AggregateCourseAbsence!
}

input CourseAbsenceCreateInput {
  id: ID
  date: DateTime!
  student: StudentCreateOneInput!
  course: CourseCreateOneWithoutAbsencesInput!
}

input CourseAbsenceCreateManyWithoutCourseInput {
  create: [CourseAbsenceCreateWithoutCourseInput!]
  connect: [CourseAbsenceWhereUniqueInput!]
}

input CourseAbsenceCreateWithoutCourseInput {
  id: ID
  date: DateTime!
  student: StudentCreateOneInput!
}

type CourseAbsenceEdge {
  node: CourseAbsence!
  cursor: String!
}

enum CourseAbsenceOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  date_ASC
  date_DESC
}

type CourseAbsencePreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  date: DateTime!
}

input CourseAbsenceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [CourseAbsenceScalarWhereInput!]
  OR: [CourseAbsenceScalarWhereInput!]
  NOT: [CourseAbsenceScalarWhereInput!]
}

type CourseAbsenceSubscriptionPayload {
  mutation: MutationType!
  node: CourseAbsence
  updatedFields: [String!]
  previousValues: CourseAbsencePreviousValues
}

input CourseAbsenceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseAbsenceWhereInput
  AND: [CourseAbsenceSubscriptionWhereInput!]
  OR: [CourseAbsenceSubscriptionWhereInput!]
  NOT: [CourseAbsenceSubscriptionWhereInput!]
}

input CourseAbsenceUpdateInput {
  date: DateTime
  student: StudentUpdateOneRequiredInput
  course: CourseUpdateOneRequiredWithoutAbsencesInput
}

input CourseAbsenceUpdateManyDataInput {
  date: DateTime
}

input CourseAbsenceUpdateManyMutationInput {
  date: DateTime
}

input CourseAbsenceUpdateManyWithoutCourseInput {
  create: [CourseAbsenceCreateWithoutCourseInput!]
  delete: [CourseAbsenceWhereUniqueInput!]
  connect: [CourseAbsenceWhereUniqueInput!]
  set: [CourseAbsenceWhereUniqueInput!]
  disconnect: [CourseAbsenceWhereUniqueInput!]
  update: [CourseAbsenceUpdateWithWhereUniqueWithoutCourseInput!]
  upsert: [CourseAbsenceUpsertWithWhereUniqueWithoutCourseInput!]
  deleteMany: [CourseAbsenceScalarWhereInput!]
  updateMany: [CourseAbsenceUpdateManyWithWhereNestedInput!]
}

input CourseAbsenceUpdateManyWithWhereNestedInput {
  where: CourseAbsenceScalarWhereInput!
  data: CourseAbsenceUpdateManyDataInput!
}

input CourseAbsenceUpdateWithoutCourseDataInput {
  date: DateTime
  student: StudentUpdateOneRequiredInput
}

input CourseAbsenceUpdateWithWhereUniqueWithoutCourseInput {
  where: CourseAbsenceWhereUniqueInput!
  data: CourseAbsenceUpdateWithoutCourseDataInput!
}

input CourseAbsenceUpsertWithWhereUniqueWithoutCourseInput {
  where: CourseAbsenceWhereUniqueInput!
  update: CourseAbsenceUpdateWithoutCourseDataInput!
  create: CourseAbsenceCreateWithoutCourseInput!
}

input CourseAbsenceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  student: StudentWhereInput
  course: CourseWhereInput
  AND: [CourseAbsenceWhereInput!]
  OR: [CourseAbsenceWhereInput!]
  NOT: [CourseAbsenceWhereInput!]
}

input CourseAbsenceWhereUniqueInput {
  id: ID
}

type CourseConnection {
  pageInfo: PageInfo!
  edges: [CourseEdge]!
  aggregate: AggregateCourse!
}

input CourseCreateInput {
  id: ID
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers: TeacherCreateManyWithoutCoursesInput
  memberships: MembershipCreateManyWithoutCourseInput
  instances: CourseInstanceCreateManyWithoutCourseInput
  studentLimit: Int
  room: RoomCreateOneInput
  absences: CourseAbsenceCreateManyWithoutCourseInput
}

input CourseCreateManyWithoutTeachersInput {
  create: [CourseCreateWithoutTeachersInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateOneWithoutAbsencesInput {
  create: CourseCreateWithoutAbsencesInput
  connect: CourseWhereUniqueInput
}

input CourseCreateOneWithoutInstancesInput {
  create: CourseCreateWithoutInstancesInput
  connect: CourseWhereUniqueInput
}

input CourseCreateOneWithoutMembershipsInput {
  create: CourseCreateWithoutMembershipsInput
  connect: CourseWhereUniqueInput
}

input CourseCreateWithoutAbsencesInput {
  id: ID
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers: TeacherCreateManyWithoutCoursesInput
  memberships: MembershipCreateManyWithoutCourseInput
  instances: CourseInstanceCreateManyWithoutCourseInput
  studentLimit: Int
  room: RoomCreateOneInput
}

input CourseCreateWithoutInstancesInput {
  id: ID
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers: TeacherCreateManyWithoutCoursesInput
  memberships: MembershipCreateManyWithoutCourseInput
  studentLimit: Int
  room: RoomCreateOneInput
  absences: CourseAbsenceCreateManyWithoutCourseInput
}

input CourseCreateWithoutMembershipsInput {
  id: ID
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers: TeacherCreateManyWithoutCoursesInput
  instances: CourseInstanceCreateManyWithoutCourseInput
  studentLimit: Int
  room: RoomCreateOneInput
  absences: CourseAbsenceCreateManyWithoutCourseInput
}

input CourseCreateWithoutTeachersInput {
  id: ID
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  memberships: MembershipCreateManyWithoutCourseInput
  instances: CourseInstanceCreateManyWithoutCourseInput
  studentLimit: Int
  room: RoomCreateOneInput
  absences: CourseAbsenceCreateManyWithoutCourseInput
}

enum CourseDay {
  MON
  TUE
  WED
  THU
  FRI
  SAT
  SUN
}

type CourseEdge {
  node: Course!
  cursor: String!
}

type CourseInstance {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  course: Course
  date: DateTime!
  topic: String
  notes: String
  participants(where: ParticipantWhereInput, orderBy: ParticipantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Participant!]
  recapUrl: String
}

type CourseInstanceConnection {
  pageInfo: PageInfo!
  edges: [CourseInstanceEdge]!
  aggregate: AggregateCourseInstance!
}

input CourseInstanceCreateInput {
  id: ID
  course: CourseCreateOneWithoutInstancesInput
  date: DateTime!
  topic: String
  notes: String
  participants: ParticipantCreateManyWithoutCourseInstanceInput
  recapUrl: String
}

input CourseInstanceCreateManyWithoutCourseInput {
  create: [CourseInstanceCreateWithoutCourseInput!]
  connect: [CourseInstanceWhereUniqueInput!]
}

input CourseInstanceCreateOneWithoutParticipantsInput {
  create: CourseInstanceCreateWithoutParticipantsInput
  connect: CourseInstanceWhereUniqueInput
}

input CourseInstanceCreateWithoutCourseInput {
  id: ID
  date: DateTime!
  topic: String
  notes: String
  participants: ParticipantCreateManyWithoutCourseInstanceInput
  recapUrl: String
}

input CourseInstanceCreateWithoutParticipantsInput {
  id: ID
  course: CourseCreateOneWithoutInstancesInput
  date: DateTime!
  topic: String
  notes: String
  recapUrl: String
}

type CourseInstanceEdge {
  node: CourseInstance!
  cursor: String!
}

enum CourseInstanceOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  date_ASC
  date_DESC
  topic_ASC
  topic_DESC
  notes_ASC
  notes_DESC
  recapUrl_ASC
  recapUrl_DESC
}

type CourseInstancePreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  date: DateTime!
  topic: String
  notes: String
  recapUrl: String
}

input CourseInstanceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  topic: String
  topic_not: String
  topic_in: [String!]
  topic_not_in: [String!]
  topic_lt: String
  topic_lte: String
  topic_gt: String
  topic_gte: String
  topic_contains: String
  topic_not_contains: String
  topic_starts_with: String
  topic_not_starts_with: String
  topic_ends_with: String
  topic_not_ends_with: String
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  recapUrl: String
  recapUrl_not: String
  recapUrl_in: [String!]
  recapUrl_not_in: [String!]
  recapUrl_lt: String
  recapUrl_lte: String
  recapUrl_gt: String
  recapUrl_gte: String
  recapUrl_contains: String
  recapUrl_not_contains: String
  recapUrl_starts_with: String
  recapUrl_not_starts_with: String
  recapUrl_ends_with: String
  recapUrl_not_ends_with: String
  AND: [CourseInstanceScalarWhereInput!]
  OR: [CourseInstanceScalarWhereInput!]
  NOT: [CourseInstanceScalarWhereInput!]
}

type CourseInstanceSubscriptionPayload {
  mutation: MutationType!
  node: CourseInstance
  updatedFields: [String!]
  previousValues: CourseInstancePreviousValues
}

input CourseInstanceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseInstanceWhereInput
  AND: [CourseInstanceSubscriptionWhereInput!]
  OR: [CourseInstanceSubscriptionWhereInput!]
  NOT: [CourseInstanceSubscriptionWhereInput!]
}

input CourseInstanceUpdateInput {
  course: CourseUpdateOneWithoutInstancesInput
  date: DateTime
  topic: String
  notes: String
  participants: ParticipantUpdateManyWithoutCourseInstanceInput
  recapUrl: String
}

input CourseInstanceUpdateManyDataInput {
  date: DateTime
  topic: String
  notes: String
  recapUrl: String
}

input CourseInstanceUpdateManyMutationInput {
  date: DateTime
  topic: String
  notes: String
  recapUrl: String
}

input CourseInstanceUpdateManyWithoutCourseInput {
  create: [CourseInstanceCreateWithoutCourseInput!]
  delete: [CourseInstanceWhereUniqueInput!]
  connect: [CourseInstanceWhereUniqueInput!]
  set: [CourseInstanceWhereUniqueInput!]
  disconnect: [CourseInstanceWhereUniqueInput!]
  update: [CourseInstanceUpdateWithWhereUniqueWithoutCourseInput!]
  upsert: [CourseInstanceUpsertWithWhereUniqueWithoutCourseInput!]
  deleteMany: [CourseInstanceScalarWhereInput!]
  updateMany: [CourseInstanceUpdateManyWithWhereNestedInput!]
}

input CourseInstanceUpdateManyWithWhereNestedInput {
  where: CourseInstanceScalarWhereInput!
  data: CourseInstanceUpdateManyDataInput!
}

input CourseInstanceUpdateOneRequiredWithoutParticipantsInput {
  create: CourseInstanceCreateWithoutParticipantsInput
  update: CourseInstanceUpdateWithoutParticipantsDataInput
  upsert: CourseInstanceUpsertWithoutParticipantsInput
  connect: CourseInstanceWhereUniqueInput
}

input CourseInstanceUpdateWithoutCourseDataInput {
  date: DateTime
  topic: String
  notes: String
  participants: ParticipantUpdateManyWithoutCourseInstanceInput
  recapUrl: String
}

input CourseInstanceUpdateWithoutParticipantsDataInput {
  course: CourseUpdateOneWithoutInstancesInput
  date: DateTime
  topic: String
  notes: String
  recapUrl: String
}

input CourseInstanceUpdateWithWhereUniqueWithoutCourseInput {
  where: CourseInstanceWhereUniqueInput!
  data: CourseInstanceUpdateWithoutCourseDataInput!
}

input CourseInstanceUpsertWithoutParticipantsInput {
  update: CourseInstanceUpdateWithoutParticipantsDataInput!
  create: CourseInstanceCreateWithoutParticipantsInput!
}

input CourseInstanceUpsertWithWhereUniqueWithoutCourseInput {
  where: CourseInstanceWhereUniqueInput!
  update: CourseInstanceUpdateWithoutCourseDataInput!
  create: CourseInstanceCreateWithoutCourseInput!
}

input CourseInstanceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  course: CourseWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  topic: String
  topic_not: String
  topic_in: [String!]
  topic_not_in: [String!]
  topic_lt: String
  topic_lte: String
  topic_gt: String
  topic_gte: String
  topic_contains: String
  topic_not_contains: String
  topic_starts_with: String
  topic_not_starts_with: String
  topic_ends_with: String
  topic_not_ends_with: String
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  participants_every: ParticipantWhereInput
  participants_some: ParticipantWhereInput
  participants_none: ParticipantWhereInput
  recapUrl: String
  recapUrl_not: String
  recapUrl_in: [String!]
  recapUrl_not_in: [String!]
  recapUrl_lt: String
  recapUrl_lte: String
  recapUrl_gt: String
  recapUrl_gte: String
  recapUrl_contains: String
  recapUrl_not_contains: String
  recapUrl_starts_with: String
  recapUrl_not_starts_with: String
  recapUrl_ends_with: String
  recapUrl_not_ends_with: String
  AND: [CourseInstanceWhereInput!]
  OR: [CourseInstanceWhereInput!]
  NOT: [CourseInstanceWhereInput!]
}

input CourseInstanceWhereUniqueInput {
  id: ID
}

enum CourseOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  startDate_ASC
  startDate_DESC
  startTime_ASC
  startTime_DESC
  day_ASC
  day_DESC
  duration_ASC
  duration_DESC
  studentLimit_ASC
  studentLimit_DESC
}

type CoursePreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  studentLimit: Int
}

input CourseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  day: CourseDay
  day_not: CourseDay
  day_in: [CourseDay!]
  day_not_in: [CourseDay!]
  duration: Int
  duration_not: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_gt: Int
  duration_gte: Int
  studentLimit: Int
  studentLimit_not: Int
  studentLimit_in: [Int!]
  studentLimit_not_in: [Int!]
  studentLimit_lt: Int
  studentLimit_lte: Int
  studentLimit_gt: Int
  studentLimit_gte: Int
  AND: [CourseScalarWhereInput!]
  OR: [CourseScalarWhereInput!]
  NOT: [CourseScalarWhereInput!]
}

type CourseSubscriptionPayload {
  mutation: MutationType!
  node: Course
  updatedFields: [String!]
  previousValues: CoursePreviousValues
}

input CourseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseWhereInput
  AND: [CourseSubscriptionWhereInput!]
  OR: [CourseSubscriptionWhereInput!]
  NOT: [CourseSubscriptionWhereInput!]
}

input CourseUpdateInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers: TeacherUpdateManyWithoutCoursesInput
  memberships: MembershipUpdateManyWithoutCourseInput
  instances: CourseInstanceUpdateManyWithoutCourseInput
  studentLimit: Int
  room: RoomUpdateOneInput
  absences: CourseAbsenceUpdateManyWithoutCourseInput
}

input CourseUpdateManyDataInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  studentLimit: Int
}

input CourseUpdateManyMutationInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  studentLimit: Int
}

input CourseUpdateManyWithoutTeachersInput {
  create: [CourseCreateWithoutTeachersInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutTeachersInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutTeachersInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithWhereNestedInput {
  where: CourseScalarWhereInput!
  data: CourseUpdateManyDataInput!
}

input CourseUpdateOneRequiredWithoutAbsencesInput {
  create: CourseCreateWithoutAbsencesInput
  update: CourseUpdateWithoutAbsencesDataInput
  upsert: CourseUpsertWithoutAbsencesInput
  connect: CourseWhereUniqueInput
}

input CourseUpdateOneRequiredWithoutMembershipsInput {
  create: CourseCreateWithoutMembershipsInput
  update: CourseUpdateWithoutMembershipsDataInput
  upsert: CourseUpsertWithoutMembershipsInput
  connect: CourseWhereUniqueInput
}

input CourseUpdateOneWithoutInstancesInput {
  create: CourseCreateWithoutInstancesInput
  update: CourseUpdateWithoutInstancesDataInput
  upsert: CourseUpsertWithoutInstancesInput
  delete: Boolean
  disconnect: Boolean
  connect: CourseWhereUniqueInput
}

input CourseUpdateWithoutAbsencesDataInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers: TeacherUpdateManyWithoutCoursesInput
  memberships: MembershipUpdateManyWithoutCourseInput
  instances: CourseInstanceUpdateManyWithoutCourseInput
  studentLimit: Int
  room: RoomUpdateOneInput
}

input CourseUpdateWithoutInstancesDataInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers: TeacherUpdateManyWithoutCoursesInput
  memberships: MembershipUpdateManyWithoutCourseInput
  studentLimit: Int
  room: RoomUpdateOneInput
  absences: CourseAbsenceUpdateManyWithoutCourseInput
}

input CourseUpdateWithoutMembershipsDataInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers: TeacherUpdateManyWithoutCoursesInput
  instances: CourseInstanceUpdateManyWithoutCourseInput
  studentLimit: Int
  room: RoomUpdateOneInput
  absences: CourseAbsenceUpdateManyWithoutCourseInput
}

input CourseUpdateWithoutTeachersDataInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  memberships: MembershipUpdateManyWithoutCourseInput
  instances: CourseInstanceUpdateManyWithoutCourseInput
  studentLimit: Int
  room: RoomUpdateOneInput
  absences: CourseAbsenceUpdateManyWithoutCourseInput
}

input CourseUpdateWithWhereUniqueWithoutTeachersInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutTeachersDataInput!
}

input CourseUpsertWithoutAbsencesInput {
  update: CourseUpdateWithoutAbsencesDataInput!
  create: CourseCreateWithoutAbsencesInput!
}

input CourseUpsertWithoutInstancesInput {
  update: CourseUpdateWithoutInstancesDataInput!
  create: CourseCreateWithoutInstancesInput!
}

input CourseUpsertWithoutMembershipsInput {
  update: CourseUpdateWithoutMembershipsDataInput!
  create: CourseCreateWithoutMembershipsInput!
}

input CourseUpsertWithWhereUniqueWithoutTeachersInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutTeachersDataInput!
  create: CourseCreateWithoutTeachersInput!
}

input CourseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  day: CourseDay
  day_not: CourseDay
  day_in: [CourseDay!]
  day_not_in: [CourseDay!]
  duration: Int
  duration_not: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_gt: Int
  duration_gte: Int
  teachers_every: TeacherWhereInput
  teachers_some: TeacherWhereInput
  teachers_none: TeacherWhereInput
  memberships_every: MembershipWhereInput
  memberships_some: MembershipWhereInput
  memberships_none: MembershipWhereInput
  instances_every: CourseInstanceWhereInput
  instances_some: CourseInstanceWhereInput
  instances_none: CourseInstanceWhereInput
  studentLimit: Int
  studentLimit_not: Int
  studentLimit_in: [Int!]
  studentLimit_not_in: [Int!]
  studentLimit_lt: Int
  studentLimit_lte: Int
  studentLimit_gt: Int
  studentLimit_gte: Int
  room: RoomWhereInput
  absences_every: CourseAbsenceWhereInput
  absences_some: CourseAbsenceWhereInput
  absences_none: CourseAbsenceWhereInput
  AND: [CourseWhereInput!]
  OR: [CourseWhereInput!]
  NOT: [CourseWhereInput!]
}

input CourseWhereUniqueInput {
  id: ID
}

enum DanceRole {
  LEADER
  FOLLOWER
  SOLO
}

scalar DateTime

type Expense {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  type: ExpenseType!
  date: DateTime!
  amount: Int!
  note: String
}

type ExpenseConnection {
  pageInfo: PageInfo!
  edges: [ExpenseEdge]!
  aggregate: AggregateExpense!
}

input ExpenseCreateInput {
  id: ID
  type: ExpenseType!
  date: DateTime!
  amount: Int!
  note: String
}

type ExpenseEdge {
  node: Expense!
  cursor: String!
}

enum ExpenseOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  type_ASC
  type_DESC
  date_ASC
  date_DESC
  amount_ASC
  amount_DESC
  note_ASC
  note_DESC
}

type ExpensePreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  type: ExpenseType!
  date: DateTime!
  amount: Int!
  note: String
}

type ExpenseSubscriptionPayload {
  mutation: MutationType!
  node: Expense
  updatedFields: [String!]
  previousValues: ExpensePreviousValues
}

input ExpenseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExpenseWhereInput
  AND: [ExpenseSubscriptionWhereInput!]
  OR: [ExpenseSubscriptionWhereInput!]
  NOT: [ExpenseSubscriptionWhereInput!]
}

enum ExpenseType {
  RENT
  MISC
}

input ExpenseUpdateInput {
  type: ExpenseType
  date: DateTime
  amount: Int
  note: String
}

input ExpenseUpdateManyMutationInput {
  type: ExpenseType
  date: DateTime
  amount: Int
  note: String
}

input ExpenseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  type: ExpenseType
  type_not: ExpenseType
  type_in: [ExpenseType!]
  type_not_in: [ExpenseType!]
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  note: String
  note_not: String
  note_in: [String!]
  note_not_in: [String!]
  note_lt: String
  note_lte: String
  note_gt: String
  note_gte: String
  note_contains: String
  note_not_contains: String
  note_starts_with: String
  note_not_starts_with: String
  note_ends_with: String
  note_not_ends_with: String
  AND: [ExpenseWhereInput!]
  OR: [ExpenseWhereInput!]
  NOT: [ExpenseWhereInput!]
}

input ExpenseWhereUniqueInput {
  id: ID
}

type LoginResponse {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  token: String
  user: User
}

type LoginResponseConnection {
  pageInfo: PageInfo!
  edges: [LoginResponseEdge]!
  aggregate: AggregateLoginResponse!
}

input LoginResponseCreateInput {
  id: ID
  token: String
  user: UserCreateOneInput
}

type LoginResponseEdge {
  node: LoginResponse!
  cursor: String!
}

enum LoginResponseOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  token_ASC
  token_DESC
}

type LoginResponsePreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  token: String
}

type LoginResponseSubscriptionPayload {
  mutation: MutationType!
  node: LoginResponse
  updatedFields: [String!]
  previousValues: LoginResponsePreviousValues
}

input LoginResponseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LoginResponseWhereInput
  AND: [LoginResponseSubscriptionWhereInput!]
  OR: [LoginResponseSubscriptionWhereInput!]
  NOT: [LoginResponseSubscriptionWhereInput!]
}

input LoginResponseUpdateInput {
  token: String
  user: UserUpdateOneInput
}

input LoginResponseUpdateManyMutationInput {
  token: String
}

input LoginResponseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_lt: String
  token_lte: String
  token_gt: String
  token_gte: String
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  user: UserWhereInput
  AND: [LoginResponseWhereInput!]
  OR: [LoginResponseWhereInput!]
  NOT: [LoginResponseWhereInput!]
}

input LoginResponseWhereUniqueInput {
  id: ID
}

scalar Long

type Membership {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  student: Student!
  course: Course!
  role: DanceRole!
  status: MembershipStatus
  waitlistDate: DateTime
}

type MembershipConnection {
  pageInfo: PageInfo!
  edges: [MembershipEdge]!
  aggregate: AggregateMembership!
}

input MembershipCreateInput {
  id: ID
  student: StudentCreateOneWithoutMembershipsInput!
  course: CourseCreateOneWithoutMembershipsInput!
  role: DanceRole!
  status: MembershipStatus
  waitlistDate: DateTime
}

input MembershipCreateManyWithoutCourseInput {
  create: [MembershipCreateWithoutCourseInput!]
  connect: [MembershipWhereUniqueInput!]
}

input MembershipCreateManyWithoutStudentInput {
  create: [MembershipCreateWithoutStudentInput!]
  connect: [MembershipWhereUniqueInput!]
}

input MembershipCreateOneInput {
  create: MembershipCreateInput
  connect: MembershipWhereUniqueInput
}

input MembershipCreateWithoutCourseInput {
  id: ID
  student: StudentCreateOneWithoutMembershipsInput!
  role: DanceRole!
  status: MembershipStatus
  waitlistDate: DateTime
}

input MembershipCreateWithoutStudentInput {
  id: ID
  course: CourseCreateOneWithoutMembershipsInput!
  role: DanceRole!
  status: MembershipStatus
  waitlistDate: DateTime
}

type MembershipEdge {
  node: Membership!
  cursor: String!
}

enum MembershipOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  role_ASC
  role_DESC
  status_ASC
  status_DESC
  waitlistDate_ASC
  waitlistDate_DESC
}

type MembershipPreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  role: DanceRole!
  status: MembershipStatus
  waitlistDate: DateTime
}

input MembershipScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  role: DanceRole
  role_not: DanceRole
  role_in: [DanceRole!]
  role_not_in: [DanceRole!]
  status: MembershipStatus
  status_not: MembershipStatus
  status_in: [MembershipStatus!]
  status_not_in: [MembershipStatus!]
  waitlistDate: DateTime
  waitlistDate_not: DateTime
  waitlistDate_in: [DateTime!]
  waitlistDate_not_in: [DateTime!]
  waitlistDate_lt: DateTime
  waitlistDate_lte: DateTime
  waitlistDate_gt: DateTime
  waitlistDate_gte: DateTime
  AND: [MembershipScalarWhereInput!]
  OR: [MembershipScalarWhereInput!]
  NOT: [MembershipScalarWhereInput!]
}

enum MembershipStatus {
  ACTIVE
  INACTIVE
  WAITLIST
}

type MembershipSubscriptionPayload {
  mutation: MutationType!
  node: Membership
  updatedFields: [String!]
  previousValues: MembershipPreviousValues
}

input MembershipSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MembershipWhereInput
  AND: [MembershipSubscriptionWhereInput!]
  OR: [MembershipSubscriptionWhereInput!]
  NOT: [MembershipSubscriptionWhereInput!]
}

input MembershipUpdateDataInput {
  student: StudentUpdateOneRequiredWithoutMembershipsInput
  course: CourseUpdateOneRequiredWithoutMembershipsInput
  role: DanceRole
  status: MembershipStatus
  waitlistDate: DateTime
}

input MembershipUpdateInput {
  student: StudentUpdateOneRequiredWithoutMembershipsInput
  course: CourseUpdateOneRequiredWithoutMembershipsInput
  role: DanceRole
  status: MembershipStatus
  waitlistDate: DateTime
}

input MembershipUpdateManyDataInput {
  role: DanceRole
  status: MembershipStatus
  waitlistDate: DateTime
}

input MembershipUpdateManyMutationInput {
  role: DanceRole
  status: MembershipStatus
  waitlistDate: DateTime
}

input MembershipUpdateManyWithoutCourseInput {
  create: [MembershipCreateWithoutCourseInput!]
  delete: [MembershipWhereUniqueInput!]
  connect: [MembershipWhereUniqueInput!]
  set: [MembershipWhereUniqueInput!]
  disconnect: [MembershipWhereUniqueInput!]
  update: [MembershipUpdateWithWhereUniqueWithoutCourseInput!]
  upsert: [MembershipUpsertWithWhereUniqueWithoutCourseInput!]
  deleteMany: [MembershipScalarWhereInput!]
  updateMany: [MembershipUpdateManyWithWhereNestedInput!]
}

input MembershipUpdateManyWithoutStudentInput {
  create: [MembershipCreateWithoutStudentInput!]
  delete: [MembershipWhereUniqueInput!]
  connect: [MembershipWhereUniqueInput!]
  set: [MembershipWhereUniqueInput!]
  disconnect: [MembershipWhereUniqueInput!]
  update: [MembershipUpdateWithWhereUniqueWithoutStudentInput!]
  upsert: [MembershipUpsertWithWhereUniqueWithoutStudentInput!]
  deleteMany: [MembershipScalarWhereInput!]
  updateMany: [MembershipUpdateManyWithWhereNestedInput!]
}

input MembershipUpdateManyWithWhereNestedInput {
  where: MembershipScalarWhereInput!
  data: MembershipUpdateManyDataInput!
}

input MembershipUpdateOneRequiredInput {
  create: MembershipCreateInput
  update: MembershipUpdateDataInput
  upsert: MembershipUpsertNestedInput
  connect: MembershipWhereUniqueInput
}

input MembershipUpdateWithoutCourseDataInput {
  student: StudentUpdateOneRequiredWithoutMembershipsInput
  role: DanceRole
  status: MembershipStatus
  waitlistDate: DateTime
}

input MembershipUpdateWithoutStudentDataInput {
  course: CourseUpdateOneRequiredWithoutMembershipsInput
  role: DanceRole
  status: MembershipStatus
  waitlistDate: DateTime
}

input MembershipUpdateWithWhereUniqueWithoutCourseInput {
  where: MembershipWhereUniqueInput!
  data: MembershipUpdateWithoutCourseDataInput!
}

input MembershipUpdateWithWhereUniqueWithoutStudentInput {
  where: MembershipWhereUniqueInput!
  data: MembershipUpdateWithoutStudentDataInput!
}

input MembershipUpsertNestedInput {
  update: MembershipUpdateDataInput!
  create: MembershipCreateInput!
}

input MembershipUpsertWithWhereUniqueWithoutCourseInput {
  where: MembershipWhereUniqueInput!
  update: MembershipUpdateWithoutCourseDataInput!
  create: MembershipCreateWithoutCourseInput!
}

input MembershipUpsertWithWhereUniqueWithoutStudentInput {
  where: MembershipWhereUniqueInput!
  update: MembershipUpdateWithoutStudentDataInput!
  create: MembershipCreateWithoutStudentInput!
}

input MembershipWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  student: StudentWhereInput
  course: CourseWhereInput
  role: DanceRole
  role_not: DanceRole
  role_in: [DanceRole!]
  role_not_in: [DanceRole!]
  status: MembershipStatus
  status_not: MembershipStatus
  status_in: [MembershipStatus!]
  status_not_in: [MembershipStatus!]
  waitlistDate: DateTime
  waitlistDate_not: DateTime
  waitlistDate_in: [DateTime!]
  waitlistDate_not_in: [DateTime!]
  waitlistDate_lt: DateTime
  waitlistDate_lte: DateTime
  waitlistDate_gt: DateTime
  waitlistDate_gte: DateTime
  AND: [MembershipWhereInput!]
  OR: [MembershipWhereInput!]
  NOT: [MembershipWhereInput!]
}

input MembershipWhereUniqueInput {
  id: ID
}

type Mutation {
  createCard(data: CardCreateInput!): Card!
  updateCard(data: CardUpdateInput!, where: CardWhereUniqueInput!): Card
  updateManyCards(data: CardUpdateManyMutationInput!, where: CardWhereInput): BatchPayload!
  upsertCard(where: CardWhereUniqueInput!, create: CardCreateInput!, update: CardUpdateInput!): Card!
  deleteCard(where: CardWhereUniqueInput!): Card
  deleteManyCards(where: CardWhereInput): BatchPayload!
  createCourse(data: CourseCreateInput!): Course!
  updateCourse(data: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course
  updateManyCourses(data: CourseUpdateManyMutationInput!, where: CourseWhereInput): BatchPayload!
  upsertCourse(where: CourseWhereUniqueInput!, create: CourseCreateInput!, update: CourseUpdateInput!): Course!
  deleteCourse(where: CourseWhereUniqueInput!): Course
  deleteManyCourses(where: CourseWhereInput): BatchPayload!
  createCourseAbsence(data: CourseAbsenceCreateInput!): CourseAbsence!
  updateCourseAbsence(data: CourseAbsenceUpdateInput!, where: CourseAbsenceWhereUniqueInput!): CourseAbsence
  updateManyCourseAbsences(data: CourseAbsenceUpdateManyMutationInput!, where: CourseAbsenceWhereInput): BatchPayload!
  upsertCourseAbsence(where: CourseAbsenceWhereUniqueInput!, create: CourseAbsenceCreateInput!, update: CourseAbsenceUpdateInput!): CourseAbsence!
  deleteCourseAbsence(where: CourseAbsenceWhereUniqueInput!): CourseAbsence
  deleteManyCourseAbsences(where: CourseAbsenceWhereInput): BatchPayload!
  createCourseInstance(data: CourseInstanceCreateInput!): CourseInstance!
  updateCourseInstance(data: CourseInstanceUpdateInput!, where: CourseInstanceWhereUniqueInput!): CourseInstance
  updateManyCourseInstances(data: CourseInstanceUpdateManyMutationInput!, where: CourseInstanceWhereInput): BatchPayload!
  upsertCourseInstance(where: CourseInstanceWhereUniqueInput!, create: CourseInstanceCreateInput!, update: CourseInstanceUpdateInput!): CourseInstance!
  deleteCourseInstance(where: CourseInstanceWhereUniqueInput!): CourseInstance
  deleteManyCourseInstances(where: CourseInstanceWhereInput): BatchPayload!
  createExpense(data: ExpenseCreateInput!): Expense!
  updateExpense(data: ExpenseUpdateInput!, where: ExpenseWhereUniqueInput!): Expense
  updateManyExpenses(data: ExpenseUpdateManyMutationInput!, where: ExpenseWhereInput): BatchPayload!
  upsertExpense(where: ExpenseWhereUniqueInput!, create: ExpenseCreateInput!, update: ExpenseUpdateInput!): Expense!
  deleteExpense(where: ExpenseWhereUniqueInput!): Expense
  deleteManyExpenses(where: ExpenseWhereInput): BatchPayload!
  createLoginResponse(data: LoginResponseCreateInput!): LoginResponse!
  updateLoginResponse(data: LoginResponseUpdateInput!, where: LoginResponseWhereUniqueInput!): LoginResponse
  updateManyLoginResponses(data: LoginResponseUpdateManyMutationInput!, where: LoginResponseWhereInput): BatchPayload!
  upsertLoginResponse(where: LoginResponseWhereUniqueInput!, create: LoginResponseCreateInput!, update: LoginResponseUpdateInput!): LoginResponse!
  deleteLoginResponse(where: LoginResponseWhereUniqueInput!): LoginResponse
  deleteManyLoginResponses(where: LoginResponseWhereInput): BatchPayload!
  createMembership(data: MembershipCreateInput!): Membership!
  updateMembership(data: MembershipUpdateInput!, where: MembershipWhereUniqueInput!): Membership
  updateManyMemberships(data: MembershipUpdateManyMutationInput!, where: MembershipWhereInput): BatchPayload!
  upsertMembership(where: MembershipWhereUniqueInput!, create: MembershipCreateInput!, update: MembershipUpdateInput!): Membership!
  deleteMembership(where: MembershipWhereUniqueInput!): Membership
  deleteManyMemberships(where: MembershipWhereInput): BatchPayload!
  createParticipant(data: ParticipantCreateInput!): Participant!
  updateParticipant(data: ParticipantUpdateInput!, where: ParticipantWhereUniqueInput!): Participant
  updateManyParticipants(data: ParticipantUpdateManyMutationInput!, where: ParticipantWhereInput): BatchPayload!
  upsertParticipant(where: ParticipantWhereUniqueInput!, create: ParticipantCreateInput!, update: ParticipantUpdateInput!): Participant!
  deleteParticipant(where: ParticipantWhereUniqueInput!): Participant
  deleteManyParticipants(where: ParticipantWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createRoom(data: RoomCreateInput!): Room!
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateManyRooms(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  createStudent(data: StudentCreateInput!): Student!
  updateStudent(data: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student
  updateManyStudents(data: StudentUpdateManyMutationInput!, where: StudentWhereInput): BatchPayload!
  upsertStudent(where: StudentWhereUniqueInput!, create: StudentCreateInput!, update: StudentUpdateInput!): Student!
  deleteStudent(where: StudentWhereUniqueInput!): Student
  deleteManyStudents(where: StudentWhereInput): BatchPayload!
  createStudio(data: StudioCreateInput!): Studio!
  updateStudio(data: StudioUpdateInput!, where: StudioWhereUniqueInput!): Studio
  updateManyStudios(data: StudioUpdateManyMutationInput!, where: StudioWhereInput): BatchPayload!
  upsertStudio(where: StudioWhereUniqueInput!, create: StudioCreateInput!, update: StudioUpdateInput!): Studio!
  deleteStudio(where: StudioWhereUniqueInput!): Studio
  deleteManyStudios(where: StudioWhereInput): BatchPayload!
  createTeacher(data: TeacherCreateInput!): Teacher!
  updateTeacher(data: TeacherUpdateInput!, where: TeacherWhereUniqueInput!): Teacher
  updateManyTeachers(data: TeacherUpdateManyMutationInput!, where: TeacherWhereInput): BatchPayload!
  upsertTeacher(where: TeacherWhereUniqueInput!, create: TeacherCreateInput!, update: TeacherUpdateInput!): Teacher!
  deleteTeacher(where: TeacherWhereUniqueInput!): Teacher
  deleteManyTeachers(where: TeacherWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Participant {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  membership: Membership!
  courseInstance: CourseInstance!
  status: ParticipantStatus
}

type ParticipantConnection {
  pageInfo: PageInfo!
  edges: [ParticipantEdge]!
  aggregate: AggregateParticipant!
}

input ParticipantCreateInput {
  id: ID
  membership: MembershipCreateOneInput!
  courseInstance: CourseInstanceCreateOneWithoutParticipantsInput!
  status: ParticipantStatus
}

input ParticipantCreateManyInput {
  create: [ParticipantCreateInput!]
  connect: [ParticipantWhereUniqueInput!]
}

input ParticipantCreateManyWithoutCourseInstanceInput {
  create: [ParticipantCreateWithoutCourseInstanceInput!]
  connect: [ParticipantWhereUniqueInput!]
}

input ParticipantCreateWithoutCourseInstanceInput {
  id: ID
  membership: MembershipCreateOneInput!
  status: ParticipantStatus
}

type ParticipantEdge {
  node: Participant!
  cursor: String!
}

enum ParticipantOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  status_ASC
  status_DESC
}

type ParticipantPreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  status: ParticipantStatus
}

input ParticipantScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  status: ParticipantStatus
  status_not: ParticipantStatus
  status_in: [ParticipantStatus!]
  status_not_in: [ParticipantStatus!]
  AND: [ParticipantScalarWhereInput!]
  OR: [ParticipantScalarWhereInput!]
  NOT: [ParticipantScalarWhereInput!]
}

enum ParticipantStatus {
  PRESENT
  ABSENT
  NOT_LOGGED
}

type ParticipantSubscriptionPayload {
  mutation: MutationType!
  node: Participant
  updatedFields: [String!]
  previousValues: ParticipantPreviousValues
}

input ParticipantSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ParticipantWhereInput
  AND: [ParticipantSubscriptionWhereInput!]
  OR: [ParticipantSubscriptionWhereInput!]
  NOT: [ParticipantSubscriptionWhereInput!]
}

input ParticipantUpdateDataInput {
  membership: MembershipUpdateOneRequiredInput
  courseInstance: CourseInstanceUpdateOneRequiredWithoutParticipantsInput
  status: ParticipantStatus
}

input ParticipantUpdateInput {
  membership: MembershipUpdateOneRequiredInput
  courseInstance: CourseInstanceUpdateOneRequiredWithoutParticipantsInput
  status: ParticipantStatus
}

input ParticipantUpdateManyDataInput {
  status: ParticipantStatus
}

input ParticipantUpdateManyInput {
  create: [ParticipantCreateInput!]
  update: [ParticipantUpdateWithWhereUniqueNestedInput!]
  upsert: [ParticipantUpsertWithWhereUniqueNestedInput!]
  delete: [ParticipantWhereUniqueInput!]
  connect: [ParticipantWhereUniqueInput!]
  set: [ParticipantWhereUniqueInput!]
  disconnect: [ParticipantWhereUniqueInput!]
  deleteMany: [ParticipantScalarWhereInput!]
  updateMany: [ParticipantUpdateManyWithWhereNestedInput!]
}

input ParticipantUpdateManyMutationInput {
  status: ParticipantStatus
}

input ParticipantUpdateManyWithoutCourseInstanceInput {
  create: [ParticipantCreateWithoutCourseInstanceInput!]
  delete: [ParticipantWhereUniqueInput!]
  connect: [ParticipantWhereUniqueInput!]
  set: [ParticipantWhereUniqueInput!]
  disconnect: [ParticipantWhereUniqueInput!]
  update: [ParticipantUpdateWithWhereUniqueWithoutCourseInstanceInput!]
  upsert: [ParticipantUpsertWithWhereUniqueWithoutCourseInstanceInput!]
  deleteMany: [ParticipantScalarWhereInput!]
  updateMany: [ParticipantUpdateManyWithWhereNestedInput!]
}

input ParticipantUpdateManyWithWhereNestedInput {
  where: ParticipantScalarWhereInput!
  data: ParticipantUpdateManyDataInput!
}

input ParticipantUpdateWithoutCourseInstanceDataInput {
  membership: MembershipUpdateOneRequiredInput
  status: ParticipantStatus
}

input ParticipantUpdateWithWhereUniqueNestedInput {
  where: ParticipantWhereUniqueInput!
  data: ParticipantUpdateDataInput!
}

input ParticipantUpdateWithWhereUniqueWithoutCourseInstanceInput {
  where: ParticipantWhereUniqueInput!
  data: ParticipantUpdateWithoutCourseInstanceDataInput!
}

input ParticipantUpsertWithWhereUniqueNestedInput {
  where: ParticipantWhereUniqueInput!
  update: ParticipantUpdateDataInput!
  create: ParticipantCreateInput!
}

input ParticipantUpsertWithWhereUniqueWithoutCourseInstanceInput {
  where: ParticipantWhereUniqueInput!
  update: ParticipantUpdateWithoutCourseInstanceDataInput!
  create: ParticipantCreateWithoutCourseInstanceInput!
}

input ParticipantWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  membership: MembershipWhereInput
  courseInstance: CourseInstanceWhereInput
  status: ParticipantStatus
  status_not: ParticipantStatus
  status_in: [ParticipantStatus!]
  status_not_in: [ParticipantStatus!]
  AND: [ParticipantWhereInput!]
  OR: [ParticipantWhereInput!]
  NOT: [ParticipantWhereInput!]
}

input ParticipantWhereUniqueInput {
  id: ID
}

type Payment {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  type: PaymentType!
  date: DateTime!
  amount: Int!
  student: Student
  card: Card
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  id: ID
  type: PaymentType!
  date: DateTime!
  amount: Int!
  student: StudentCreateOneWithoutPaymentsInput
  card: CardCreateOneWithoutPaymentInput
}

input PaymentCreateManyWithoutStudentInput {
  create: [PaymentCreateWithoutStudentInput!]
  connect: [PaymentWhereUniqueInput!]
}

input PaymentCreateOneWithoutCardInput {
  create: PaymentCreateWithoutCardInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutCardInput {
  id: ID
  type: PaymentType!
  date: DateTime!
  amount: Int!
  student: StudentCreateOneWithoutPaymentsInput
}

input PaymentCreateWithoutStudentInput {
  id: ID
  type: PaymentType!
  date: DateTime!
  amount: Int!
  card: CardCreateOneWithoutPaymentInput
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  type_ASC
  type_DESC
  date_ASC
  date_DESC
  amount_ASC
  amount_DESC
}

type PaymentPreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  type: PaymentType!
  date: DateTime!
  amount: Int!
}

input PaymentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  type: PaymentType
  type_not: PaymentType
  type_in: [PaymentType!]
  type_not_in: [PaymentType!]
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  AND: [PaymentScalarWhereInput!]
  OR: [PaymentScalarWhereInput!]
  NOT: [PaymentScalarWhereInput!]
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

enum PaymentType {
  CARD
  PRIVATE
  DROP_IN
  OLD_CARD
}

input PaymentUpdateInput {
  type: PaymentType
  date: DateTime
  amount: Int
  student: StudentUpdateOneWithoutPaymentsInput
  card: CardUpdateOneWithoutPaymentInput
}

input PaymentUpdateManyDataInput {
  type: PaymentType
  date: DateTime
  amount: Int
}

input PaymentUpdateManyMutationInput {
  type: PaymentType
  date: DateTime
  amount: Int
}

input PaymentUpdateManyWithoutStudentInput {
  create: [PaymentCreateWithoutStudentInput!]
  delete: [PaymentWhereUniqueInput!]
  connect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  disconnect: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutStudentInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutStudentInput!]
  deleteMany: [PaymentScalarWhereInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
}

input PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput!
  data: PaymentUpdateManyDataInput!
}

input PaymentUpdateOneWithoutCardInput {
  create: PaymentCreateWithoutCardInput
  update: PaymentUpdateWithoutCardDataInput
  upsert: PaymentUpsertWithoutCardInput
  delete: Boolean
  disconnect: Boolean
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutCardDataInput {
  type: PaymentType
  date: DateTime
  amount: Int
  student: StudentUpdateOneWithoutPaymentsInput
}

input PaymentUpdateWithoutStudentDataInput {
  type: PaymentType
  date: DateTime
  amount: Int
  card: CardUpdateOneWithoutPaymentInput
}

input PaymentUpdateWithWhereUniqueWithoutStudentInput {
  where: PaymentWhereUniqueInput!
  data: PaymentUpdateWithoutStudentDataInput!
}

input PaymentUpsertWithoutCardInput {
  update: PaymentUpdateWithoutCardDataInput!
  create: PaymentCreateWithoutCardInput!
}

input PaymentUpsertWithWhereUniqueWithoutStudentInput {
  where: PaymentWhereUniqueInput!
  update: PaymentUpdateWithoutStudentDataInput!
  create: PaymentCreateWithoutStudentInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  type: PaymentType
  type_not: PaymentType
  type_in: [PaymentType!]
  type_not_in: [PaymentType!]
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  student: StudentWhereInput
  card: CardWhereInput
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type Query {
  card(where: CardWhereUniqueInput!): Card
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card]!
  cardsConnection(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CardConnection!
  course(where: CourseWhereUniqueInput!): Course
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course]!
  coursesConnection(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseConnection!
  courseAbsence(where: CourseAbsenceWhereUniqueInput!): CourseAbsence
  courseAbsences(where: CourseAbsenceWhereInput, orderBy: CourseAbsenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseAbsence]!
  courseAbsencesConnection(where: CourseAbsenceWhereInput, orderBy: CourseAbsenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseAbsenceConnection!
  courseInstance(where: CourseInstanceWhereUniqueInput!): CourseInstance
  courseInstances(where: CourseInstanceWhereInput, orderBy: CourseInstanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseInstance]!
  courseInstancesConnection(where: CourseInstanceWhereInput, orderBy: CourseInstanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseInstanceConnection!
  expense(where: ExpenseWhereUniqueInput!): Expense
  expenses(where: ExpenseWhereInput, orderBy: ExpenseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Expense]!
  expensesConnection(where: ExpenseWhereInput, orderBy: ExpenseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExpenseConnection!
  loginResponse(where: LoginResponseWhereUniqueInput!): LoginResponse
  loginResponses(where: LoginResponseWhereInput, orderBy: LoginResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LoginResponse]!
  loginResponsesConnection(where: LoginResponseWhereInput, orderBy: LoginResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LoginResponseConnection!
  membership(where: MembershipWhereUniqueInput!): Membership
  memberships(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership]!
  membershipsConnection(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MembershipConnection!
  participant(where: ParticipantWhereUniqueInput!): Participant
  participants(where: ParticipantWhereInput, orderBy: ParticipantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Participant]!
  participantsConnection(where: ParticipantWhereInput, orderBy: ParticipantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ParticipantConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  room(where: RoomWhereUniqueInput!): Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  student(where: StudentWhereUniqueInput!): Student
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student]!
  studentsConnection(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudentConnection!
  studio(where: StudioWhereUniqueInput!): Studio
  studios(where: StudioWhereInput, orderBy: StudioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Studio]!
  studiosConnection(where: StudioWhereInput, orderBy: StudioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudioConnection!
  teacher(where: TeacherWhereUniqueInput!): Teacher
  teachers(where: TeacherWhereInput, orderBy: TeacherOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Teacher]!
  teachersConnection(where: TeacherWhereInput, orderBy: TeacherOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeacherConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Room {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  name: String
  capacity: Int
  studio: Studio!
}

type RoomConnection {
  pageInfo: PageInfo!
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  id: ID
  name: String
  capacity: Int
  studio: StudioCreateOneWithoutRoomsInput!
}

input RoomCreateManyWithoutStudioInput {
  create: [RoomCreateWithoutStudioInput!]
  connect: [RoomWhereUniqueInput!]
}

input RoomCreateOneInput {
  create: RoomCreateInput
  connect: RoomWhereUniqueInput
}

input RoomCreateWithoutStudioInput {
  id: ID
  name: String
  capacity: Int
}

type RoomEdge {
  node: Room!
  cursor: String!
}

enum RoomOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
  capacity_ASC
  capacity_DESC
}

type RoomPreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  name: String
  capacity: Int
}

input RoomScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  capacity: Int
  capacity_not: Int
  capacity_in: [Int!]
  capacity_not_in: [Int!]
  capacity_lt: Int
  capacity_lte: Int
  capacity_gt: Int
  capacity_gte: Int
  AND: [RoomScalarWhereInput!]
  OR: [RoomScalarWhereInput!]
  NOT: [RoomScalarWhereInput!]
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
  AND: [RoomSubscriptionWhereInput!]
  OR: [RoomSubscriptionWhereInput!]
  NOT: [RoomSubscriptionWhereInput!]
}

input RoomUpdateDataInput {
  name: String
  capacity: Int
  studio: StudioUpdateOneRequiredWithoutRoomsInput
}

input RoomUpdateInput {
  name: String
  capacity: Int
  studio: StudioUpdateOneRequiredWithoutRoomsInput
}

input RoomUpdateManyDataInput {
  name: String
  capacity: Int
}

input RoomUpdateManyMutationInput {
  name: String
  capacity: Int
}

input RoomUpdateManyWithoutStudioInput {
  create: [RoomCreateWithoutStudioInput!]
  delete: [RoomWhereUniqueInput!]
  connect: [RoomWhereUniqueInput!]
  set: [RoomWhereUniqueInput!]
  disconnect: [RoomWhereUniqueInput!]
  update: [RoomUpdateWithWhereUniqueWithoutStudioInput!]
  upsert: [RoomUpsertWithWhereUniqueWithoutStudioInput!]
  deleteMany: [RoomScalarWhereInput!]
  updateMany: [RoomUpdateManyWithWhereNestedInput!]
}

input RoomUpdateManyWithWhereNestedInput {
  where: RoomScalarWhereInput!
  data: RoomUpdateManyDataInput!
}

input RoomUpdateOneInput {
  create: RoomCreateInput
  update: RoomUpdateDataInput
  upsert: RoomUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: RoomWhereUniqueInput
}

input RoomUpdateWithoutStudioDataInput {
  name: String
  capacity: Int
}

input RoomUpdateWithWhereUniqueWithoutStudioInput {
  where: RoomWhereUniqueInput!
  data: RoomUpdateWithoutStudioDataInput!
}

input RoomUpsertNestedInput {
  update: RoomUpdateDataInput!
  create: RoomCreateInput!
}

input RoomUpsertWithWhereUniqueWithoutStudioInput {
  where: RoomWhereUniqueInput!
  update: RoomUpdateWithoutStudioDataInput!
  create: RoomCreateWithoutStudioInput!
}

input RoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  capacity: Int
  capacity_not: Int
  capacity_in: [Int!]
  capacity_not_in: [Int!]
  capacity_lt: Int
  capacity_lte: Int
  capacity_gt: Int
  capacity_gte: Int
  studio: StudioWhereInput
  AND: [RoomWhereInput!]
  OR: [RoomWhereInput!]
  NOT: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  id: ID
}

type Student {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  name: String!
  email: String!
  mobile: String
  memberships(where: MembershipWhereInput, orderBy: MembershipOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Membership!]
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card!]
  hasReferralBonus: Boolean!
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment!]
  user: User
}

type StudentConnection {
  pageInfo: PageInfo!
  edges: [StudentEdge]!
  aggregate: AggregateStudent!
}

input StudentCreateInput {
  id: ID
  name: String!
  email: String!
  mobile: String
  memberships: MembershipCreateManyWithoutStudentInput
  cards: CardCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentCreateManyWithoutStudentInput
  user: UserCreateOneWithoutStudentInput
}

input StudentCreateOneInput {
  create: StudentCreateInput
  connect: StudentWhereUniqueInput
}

input StudentCreateOneWithoutCardsInput {
  create: StudentCreateWithoutCardsInput
  connect: StudentWhereUniqueInput
}

input StudentCreateOneWithoutMembershipsInput {
  create: StudentCreateWithoutMembershipsInput
  connect: StudentWhereUniqueInput
}

input StudentCreateOneWithoutPaymentsInput {
  create: StudentCreateWithoutPaymentsInput
  connect: StudentWhereUniqueInput
}

input StudentCreateOneWithoutUserInput {
  create: StudentCreateWithoutUserInput
  connect: StudentWhereUniqueInput
}

input StudentCreateWithoutCardsInput {
  id: ID
  name: String!
  email: String!
  mobile: String
  memberships: MembershipCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentCreateManyWithoutStudentInput
  user: UserCreateOneWithoutStudentInput
}

input StudentCreateWithoutMembershipsInput {
  id: ID
  name: String!
  email: String!
  mobile: String
  cards: CardCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentCreateManyWithoutStudentInput
  user: UserCreateOneWithoutStudentInput
}

input StudentCreateWithoutPaymentsInput {
  id: ID
  name: String!
  email: String!
  mobile: String
  memberships: MembershipCreateManyWithoutStudentInput
  cards: CardCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
  user: UserCreateOneWithoutStudentInput
}

input StudentCreateWithoutUserInput {
  id: ID
  name: String!
  email: String!
  mobile: String
  memberships: MembershipCreateManyWithoutStudentInput
  cards: CardCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentCreateManyWithoutStudentInput
}

type StudentEdge {
  node: Student!
  cursor: String!
}

enum StudentOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  mobile_ASC
  mobile_DESC
  hasReferralBonus_ASC
  hasReferralBonus_DESC
}

type StudentPreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  name: String!
  email: String!
  mobile: String
  hasReferralBonus: Boolean!
}

type StudentSubscriptionPayload {
  mutation: MutationType!
  node: Student
  updatedFields: [String!]
  previousValues: StudentPreviousValues
}

input StudentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudentWhereInput
  AND: [StudentSubscriptionWhereInput!]
  OR: [StudentSubscriptionWhereInput!]
  NOT: [StudentSubscriptionWhereInput!]
}

input StudentUpdateDataInput {
  name: String
  email: String
  mobile: String
  memberships: MembershipUpdateManyWithoutStudentInput
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentUpdateManyWithoutStudentInput
  user: UserUpdateOneWithoutStudentInput
}

input StudentUpdateInput {
  name: String
  email: String
  mobile: String
  memberships: MembershipUpdateManyWithoutStudentInput
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentUpdateManyWithoutStudentInput
  user: UserUpdateOneWithoutStudentInput
}

input StudentUpdateManyMutationInput {
  name: String
  email: String
  mobile: String
  hasReferralBonus: Boolean
}

input StudentUpdateOneRequiredInput {
  create: StudentCreateInput
  update: StudentUpdateDataInput
  upsert: StudentUpsertNestedInput
  connect: StudentWhereUniqueInput
}

input StudentUpdateOneRequiredWithoutCardsInput {
  create: StudentCreateWithoutCardsInput
  update: StudentUpdateWithoutCardsDataInput
  upsert: StudentUpsertWithoutCardsInput
  connect: StudentWhereUniqueInput
}

input StudentUpdateOneRequiredWithoutMembershipsInput {
  create: StudentCreateWithoutMembershipsInput
  update: StudentUpdateWithoutMembershipsDataInput
  upsert: StudentUpsertWithoutMembershipsInput
  connect: StudentWhereUniqueInput
}

input StudentUpdateOneWithoutPaymentsInput {
  create: StudentCreateWithoutPaymentsInput
  update: StudentUpdateWithoutPaymentsDataInput
  upsert: StudentUpsertWithoutPaymentsInput
  delete: Boolean
  disconnect: Boolean
  connect: StudentWhereUniqueInput
}

input StudentUpdateOneWithoutUserInput {
  create: StudentCreateWithoutUserInput
  update: StudentUpdateWithoutUserDataInput
  upsert: StudentUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: StudentWhereUniqueInput
}

input StudentUpdateWithoutCardsDataInput {
  name: String
  email: String
  mobile: String
  memberships: MembershipUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentUpdateManyWithoutStudentInput
  user: UserUpdateOneWithoutStudentInput
}

input StudentUpdateWithoutMembershipsDataInput {
  name: String
  email: String
  mobile: String
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentUpdateManyWithoutStudentInput
  user: UserUpdateOneWithoutStudentInput
}

input StudentUpdateWithoutPaymentsDataInput {
  name: String
  email: String
  mobile: String
  memberships: MembershipUpdateManyWithoutStudentInput
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
  user: UserUpdateOneWithoutStudentInput
}

input StudentUpdateWithoutUserDataInput {
  name: String
  email: String
  mobile: String
  memberships: MembershipUpdateManyWithoutStudentInput
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentUpdateManyWithoutStudentInput
}

input StudentUpsertNestedInput {
  update: StudentUpdateDataInput!
  create: StudentCreateInput!
}

input StudentUpsertWithoutCardsInput {
  update: StudentUpdateWithoutCardsDataInput!
  create: StudentCreateWithoutCardsInput!
}

input StudentUpsertWithoutMembershipsInput {
  update: StudentUpdateWithoutMembershipsDataInput!
  create: StudentCreateWithoutMembershipsInput!
}

input StudentUpsertWithoutPaymentsInput {
  update: StudentUpdateWithoutPaymentsDataInput!
  create: StudentCreateWithoutPaymentsInput!
}

input StudentUpsertWithoutUserInput {
  update: StudentUpdateWithoutUserDataInput!
  create: StudentCreateWithoutUserInput!
}

input StudentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobile: String
  mobile_not: String
  mobile_in: [String!]
  mobile_not_in: [String!]
  mobile_lt: String
  mobile_lte: String
  mobile_gt: String
  mobile_gte: String
  mobile_contains: String
  mobile_not_contains: String
  mobile_starts_with: String
  mobile_not_starts_with: String
  mobile_ends_with: String
  mobile_not_ends_with: String
  memberships_every: MembershipWhereInput
  memberships_some: MembershipWhereInput
  memberships_none: MembershipWhereInput
  cards_every: CardWhereInput
  cards_some: CardWhereInput
  cards_none: CardWhereInput
  hasReferralBonus: Boolean
  hasReferralBonus_not: Boolean
  payments_every: PaymentWhereInput
  payments_some: PaymentWhereInput
  payments_none: PaymentWhereInput
  user: UserWhereInput
  AND: [StudentWhereInput!]
  OR: [StudentWhereInput!]
  NOT: [StudentWhereInput!]
}

input StudentWhereUniqueInput {
  id: ID
  name: String
  email: String
}

type Studio {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  name: String
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room!]
  address: String
}

type StudioConnection {
  pageInfo: PageInfo!
  edges: [StudioEdge]!
  aggregate: AggregateStudio!
}

input StudioCreateInput {
  id: ID
  name: String
  rooms: RoomCreateManyWithoutStudioInput
  address: String
}

input StudioCreateOneWithoutRoomsInput {
  create: StudioCreateWithoutRoomsInput
  connect: StudioWhereUniqueInput
}

input StudioCreateWithoutRoomsInput {
  id: ID
  name: String
  address: String
}

type StudioEdge {
  node: Studio!
  cursor: String!
}

enum StudioOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
  address_ASC
  address_DESC
}

type StudioPreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  name: String
  address: String
}

type StudioSubscriptionPayload {
  mutation: MutationType!
  node: Studio
  updatedFields: [String!]
  previousValues: StudioPreviousValues
}

input StudioSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudioWhereInput
  AND: [StudioSubscriptionWhereInput!]
  OR: [StudioSubscriptionWhereInput!]
  NOT: [StudioSubscriptionWhereInput!]
}

input StudioUpdateInput {
  name: String
  rooms: RoomUpdateManyWithoutStudioInput
  address: String
}

input StudioUpdateManyMutationInput {
  name: String
  address: String
}

input StudioUpdateOneRequiredWithoutRoomsInput {
  create: StudioCreateWithoutRoomsInput
  update: StudioUpdateWithoutRoomsDataInput
  upsert: StudioUpsertWithoutRoomsInput
  connect: StudioWhereUniqueInput
}

input StudioUpdateWithoutRoomsDataInput {
  name: String
  address: String
}

input StudioUpsertWithoutRoomsInput {
  update: StudioUpdateWithoutRoomsDataInput!
  create: StudioCreateWithoutRoomsInput!
}

input StudioWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  rooms_every: RoomWhereInput
  rooms_some: RoomWhereInput
  rooms_none: RoomWhereInput
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  AND: [StudioWhereInput!]
  OR: [StudioWhereInput!]
  NOT: [StudioWhereInput!]
}

input StudioWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  card(where: CardSubscriptionWhereInput): CardSubscriptionPayload
  course(where: CourseSubscriptionWhereInput): CourseSubscriptionPayload
  courseAbsence(where: CourseAbsenceSubscriptionWhereInput): CourseAbsenceSubscriptionPayload
  courseInstance(where: CourseInstanceSubscriptionWhereInput): CourseInstanceSubscriptionPayload
  expense(where: ExpenseSubscriptionWhereInput): ExpenseSubscriptionPayload
  loginResponse(where: LoginResponseSubscriptionWhereInput): LoginResponseSubscriptionPayload
  membership(where: MembershipSubscriptionWhereInput): MembershipSubscriptionPayload
  participant(where: ParticipantSubscriptionWhereInput): ParticipantSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  student(where: StudentSubscriptionWhereInput): StudentSubscriptionPayload
  studio(where: StudioSubscriptionWhereInput): StudioSubscriptionPayload
  teacher(where: TeacherSubscriptionWhereInput): TeacherSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Teacher {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  name: String!
  email: String!
  mobile: String
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
  user: User
}

type TeacherConnection {
  pageInfo: PageInfo!
  edges: [TeacherEdge]!
  aggregate: AggregateTeacher!
}

input TeacherCreateInput {
  id: ID
  name: String!
  email: String!
  mobile: String
  courses: CourseCreateManyWithoutTeachersInput
  user: UserCreateOneInput
}

input TeacherCreateManyWithoutCoursesInput {
  create: [TeacherCreateWithoutCoursesInput!]
  connect: [TeacherWhereUniqueInput!]
}

input TeacherCreateWithoutCoursesInput {
  id: ID
  name: String!
  email: String!
  mobile: String
  user: UserCreateOneInput
}

type TeacherEdge {
  node: Teacher!
  cursor: String!
}

enum TeacherOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  mobile_ASC
  mobile_DESC
}

type TeacherPreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  name: String!
  email: String!
  mobile: String
}

input TeacherScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobile: String
  mobile_not: String
  mobile_in: [String!]
  mobile_not_in: [String!]
  mobile_lt: String
  mobile_lte: String
  mobile_gt: String
  mobile_gte: String
  mobile_contains: String
  mobile_not_contains: String
  mobile_starts_with: String
  mobile_not_starts_with: String
  mobile_ends_with: String
  mobile_not_ends_with: String
  AND: [TeacherScalarWhereInput!]
  OR: [TeacherScalarWhereInput!]
  NOT: [TeacherScalarWhereInput!]
}

type TeacherSubscriptionPayload {
  mutation: MutationType!
  node: Teacher
  updatedFields: [String!]
  previousValues: TeacherPreviousValues
}

input TeacherSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeacherWhereInput
  AND: [TeacherSubscriptionWhereInput!]
  OR: [TeacherSubscriptionWhereInput!]
  NOT: [TeacherSubscriptionWhereInput!]
}

input TeacherUpdateInput {
  name: String
  email: String
  mobile: String
  courses: CourseUpdateManyWithoutTeachersInput
  user: UserUpdateOneInput
}

input TeacherUpdateManyDataInput {
  name: String
  email: String
  mobile: String
}

input TeacherUpdateManyMutationInput {
  name: String
  email: String
  mobile: String
}

input TeacherUpdateManyWithoutCoursesInput {
  create: [TeacherCreateWithoutCoursesInput!]
  delete: [TeacherWhereUniqueInput!]
  connect: [TeacherWhereUniqueInput!]
  set: [TeacherWhereUniqueInput!]
  disconnect: [TeacherWhereUniqueInput!]
  update: [TeacherUpdateWithWhereUniqueWithoutCoursesInput!]
  upsert: [TeacherUpsertWithWhereUniqueWithoutCoursesInput!]
  deleteMany: [TeacherScalarWhereInput!]
  updateMany: [TeacherUpdateManyWithWhereNestedInput!]
}

input TeacherUpdateManyWithWhereNestedInput {
  where: TeacherScalarWhereInput!
  data: TeacherUpdateManyDataInput!
}

input TeacherUpdateWithoutCoursesDataInput {
  name: String
  email: String
  mobile: String
  user: UserUpdateOneInput
}

input TeacherUpdateWithWhereUniqueWithoutCoursesInput {
  where: TeacherWhereUniqueInput!
  data: TeacherUpdateWithoutCoursesDataInput!
}

input TeacherUpsertWithWhereUniqueWithoutCoursesInput {
  where: TeacherWhereUniqueInput!
  update: TeacherUpdateWithoutCoursesDataInput!
  create: TeacherCreateWithoutCoursesInput!
}

input TeacherWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobile: String
  mobile_not: String
  mobile_in: [String!]
  mobile_not_in: [String!]
  mobile_lt: String
  mobile_lte: String
  mobile_gt: String
  mobile_gte: String
  mobile_contains: String
  mobile_not_contains: String
  mobile_starts_with: String
  mobile_not_starts_with: String
  mobile_ends_with: String
  mobile_not_ends_with: String
  courses_every: CourseWhereInput
  courses_some: CourseWhereInput
  courses_none: CourseWhereInput
  user: UserWhereInput
  AND: [TeacherWhereInput!]
  OR: [TeacherWhereInput!]
  NOT: [TeacherWhereInput!]
}

input TeacherWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  email: String
  password: String!
  student: Student
  admin: Boolean!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String
  password: String!
  student: StudentCreateOneWithoutUserInput
  admin: Boolean
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutStudentInput {
  create: UserCreateWithoutStudentInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutStudentInput {
  id: ID
  email: String
  password: String!
  admin: Boolean
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  admin_ASC
  admin_DESC
}

type UserPreviousValues {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  email: String
  password: String!
  admin: Boolean!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  password: String
  student: StudentUpdateOneWithoutUserInput
  admin: Boolean
}

input UserUpdateInput {
  email: String
  password: String
  student: StudentUpdateOneWithoutUserInput
  admin: Boolean
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  admin: Boolean
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutStudentInput {
  create: UserCreateWithoutStudentInput
  update: UserUpdateWithoutStudentDataInput
  upsert: UserUpsertWithoutStudentInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutStudentDataInput {
  email: String
  password: String
  admin: Boolean
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutStudentInput {
  update: UserUpdateWithoutStudentDataInput!
  create: UserCreateWithoutStudentInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  student: StudentWhereInput
  admin: Boolean
  admin_not: Boolean
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    