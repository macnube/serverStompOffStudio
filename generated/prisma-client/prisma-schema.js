module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.30.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCard {
  count: Int!
}

type AggregateCourse {
  count: Int!
}

type AggregateCourseInstance {
  count: Int!
}

type AggregateCourseStudent {
  count: Int!
}

type AggregateParticipant {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateStudent {
  count: Int!
}

type AggregateStudio {
  count: Int!
}

type AggregateTeacher {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Card {
  id: ID!
  student: Student!
  payment: Payment
  expirationDate: DateTime
  active: Boolean!
  paid: Boolean!
  value: Int!
  originalValue: Int!
  participationHistory(where: ParticipantWhereInput, orderBy: ParticipantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Participant!]
}

type CardConnection {
  pageInfo: PageInfo!
  edges: [CardEdge]!
  aggregate: AggregateCard!
}

input CardCreateInput {
  student: StudentCreateOneWithoutCardsInput!
  payment: PaymentCreateOneWithoutCardInput
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int!
  originalValue: Int!
  participationHistory: ParticipantCreateManyInput
}

input CardCreateManyWithoutStudentInput {
  create: [CardCreateWithoutStudentInput!]
  connect: [CardWhereUniqueInput!]
}

input CardCreateOneWithoutPaymentInput {
  create: CardCreateWithoutPaymentInput
  connect: CardWhereUniqueInput
}

input CardCreateWithoutPaymentInput {
  student: StudentCreateOneWithoutCardsInput!
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int!
  originalValue: Int!
  participationHistory: ParticipantCreateManyInput
}

input CardCreateWithoutStudentInput {
  payment: PaymentCreateOneWithoutCardInput
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int!
  originalValue: Int!
  participationHistory: ParticipantCreateManyInput
}

type CardEdge {
  node: Card!
  cursor: String!
}

enum CardOrderByInput {
  id_ASC
  id_DESC
  expirationDate_ASC
  expirationDate_DESC
  active_ASC
  active_DESC
  paid_ASC
  paid_DESC
  value_ASC
  value_DESC
  originalValue_ASC
  originalValue_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CardPreviousValues {
  id: ID!
  expirationDate: DateTime
  active: Boolean!
  paid: Boolean!
  value: Int!
  originalValue: Int!
}

input CardScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  expirationDate: DateTime
  expirationDate_not: DateTime
  expirationDate_in: [DateTime!]
  expirationDate_not_in: [DateTime!]
  expirationDate_lt: DateTime
  expirationDate_lte: DateTime
  expirationDate_gt: DateTime
  expirationDate_gte: DateTime
  active: Boolean
  active_not: Boolean
  paid: Boolean
  paid_not: Boolean
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  originalValue: Int
  originalValue_not: Int
  originalValue_in: [Int!]
  originalValue_not_in: [Int!]
  originalValue_lt: Int
  originalValue_lte: Int
  originalValue_gt: Int
  originalValue_gte: Int
  AND: [CardScalarWhereInput!]
  OR: [CardScalarWhereInput!]
  NOT: [CardScalarWhereInput!]
}

type CardSubscriptionPayload {
  mutation: MutationType!
  node: Card
  updatedFields: [String!]
  previousValues: CardPreviousValues
}

input CardSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CardWhereInput
  AND: [CardSubscriptionWhereInput!]
  OR: [CardSubscriptionWhereInput!]
  NOT: [CardSubscriptionWhereInput!]
}

input CardUpdateInput {
  student: StudentUpdateOneRequiredWithoutCardsInput
  payment: PaymentUpdateOneWithoutCardInput
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int
  originalValue: Int
  participationHistory: ParticipantUpdateManyInput
}

input CardUpdateManyDataInput {
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int
  originalValue: Int
}

input CardUpdateManyMutationInput {
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int
  originalValue: Int
}

input CardUpdateManyWithoutStudentInput {
  create: [CardCreateWithoutStudentInput!]
  delete: [CardWhereUniqueInput!]
  connect: [CardWhereUniqueInput!]
  set: [CardWhereUniqueInput!]
  disconnect: [CardWhereUniqueInput!]
  update: [CardUpdateWithWhereUniqueWithoutStudentInput!]
  upsert: [CardUpsertWithWhereUniqueWithoutStudentInput!]
  deleteMany: [CardScalarWhereInput!]
  updateMany: [CardUpdateManyWithWhereNestedInput!]
}

input CardUpdateManyWithWhereNestedInput {
  where: CardScalarWhereInput!
  data: CardUpdateManyDataInput!
}

input CardUpdateOneWithoutPaymentInput {
  create: CardCreateWithoutPaymentInput
  update: CardUpdateWithoutPaymentDataInput
  upsert: CardUpsertWithoutPaymentInput
  delete: Boolean
  disconnect: Boolean
  connect: CardWhereUniqueInput
}

input CardUpdateWithoutPaymentDataInput {
  student: StudentUpdateOneRequiredWithoutCardsInput
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int
  originalValue: Int
  participationHistory: ParticipantUpdateManyInput
}

input CardUpdateWithoutStudentDataInput {
  payment: PaymentUpdateOneWithoutCardInput
  expirationDate: DateTime
  active: Boolean
  paid: Boolean
  value: Int
  originalValue: Int
  participationHistory: ParticipantUpdateManyInput
}

input CardUpdateWithWhereUniqueWithoutStudentInput {
  where: CardWhereUniqueInput!
  data: CardUpdateWithoutStudentDataInput!
}

input CardUpsertWithoutPaymentInput {
  update: CardUpdateWithoutPaymentDataInput!
  create: CardCreateWithoutPaymentInput!
}

input CardUpsertWithWhereUniqueWithoutStudentInput {
  where: CardWhereUniqueInput!
  update: CardUpdateWithoutStudentDataInput!
  create: CardCreateWithoutStudentInput!
}

input CardWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  student: StudentWhereInput
  payment: PaymentWhereInput
  expirationDate: DateTime
  expirationDate_not: DateTime
  expirationDate_in: [DateTime!]
  expirationDate_not_in: [DateTime!]
  expirationDate_lt: DateTime
  expirationDate_lte: DateTime
  expirationDate_gt: DateTime
  expirationDate_gte: DateTime
  active: Boolean
  active_not: Boolean
  paid: Boolean
  paid_not: Boolean
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  originalValue: Int
  originalValue_not: Int
  originalValue_in: [Int!]
  originalValue_not_in: [Int!]
  originalValue_lt: Int
  originalValue_lte: Int
  originalValue_gt: Int
  originalValue_gte: Int
  participationHistory_every: ParticipantWhereInput
  participationHistory_some: ParticipantWhereInput
  participationHistory_none: ParticipantWhereInput
  AND: [CardWhereInput!]
  OR: [CardWhereInput!]
  NOT: [CardWhereInput!]
}

input CardWhereUniqueInput {
  id: ID
}

type Course {
  id: ID!
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers(where: TeacherWhereInput, orderBy: TeacherOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Teacher!]
  courseStudents(where: CourseStudentWhereInput, orderBy: CourseStudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseStudent!]
  instances(where: CourseInstanceWhereInput, orderBy: CourseInstanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseInstance!]
  studentLimit: Int
  room: Room
}

type CourseConnection {
  pageInfo: PageInfo!
  edges: [CourseEdge]!
  aggregate: AggregateCourse!
}

input CourseCreateInput {
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers: TeacherCreateManyWithoutCoursesInput
  courseStudents: CourseStudentCreateManyWithoutCourseInput
  instances: CourseInstanceCreateManyWithoutCourseInput
  studentLimit: Int
  room: RoomCreateOneInput
}

input CourseCreateManyWithoutTeachersInput {
  create: [CourseCreateWithoutTeachersInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateOneWithoutCourseStudentsInput {
  create: CourseCreateWithoutCourseStudentsInput
  connect: CourseWhereUniqueInput
}

input CourseCreateOneWithoutInstancesInput {
  create: CourseCreateWithoutInstancesInput
  connect: CourseWhereUniqueInput
}

input CourseCreateWithoutCourseStudentsInput {
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers: TeacherCreateManyWithoutCoursesInput
  instances: CourseInstanceCreateManyWithoutCourseInput
  studentLimit: Int
  room: RoomCreateOneInput
}

input CourseCreateWithoutInstancesInput {
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers: TeacherCreateManyWithoutCoursesInput
  courseStudents: CourseStudentCreateManyWithoutCourseInput
  studentLimit: Int
  room: RoomCreateOneInput
}

input CourseCreateWithoutTeachersInput {
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  courseStudents: CourseStudentCreateManyWithoutCourseInput
  instances: CourseInstanceCreateManyWithoutCourseInput
  studentLimit: Int
  room: RoomCreateOneInput
}

enum CourseDay {
  MON
  TUE
  WED
  THU
  FRI
  SAT
  SUN
}

type CourseEdge {
  node: Course!
  cursor: String!
}

type CourseInstance {
  id: ID!
  course: Course
  date: DateTime
  topic: String
  notes: String
  participants(where: ParticipantWhereInput, orderBy: ParticipantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Participant!]
  recapUrl: String
}

type CourseInstanceConnection {
  pageInfo: PageInfo!
  edges: [CourseInstanceEdge]!
  aggregate: AggregateCourseInstance!
}

input CourseInstanceCreateInput {
  course: CourseCreateOneWithoutInstancesInput
  date: DateTime
  topic: String
  notes: String
  participants: ParticipantCreateManyWithoutCourseInstanceInput
  recapUrl: String
}

input CourseInstanceCreateManyWithoutCourseInput {
  create: [CourseInstanceCreateWithoutCourseInput!]
  connect: [CourseInstanceWhereUniqueInput!]
}

input CourseInstanceCreateOneWithoutParticipantsInput {
  create: CourseInstanceCreateWithoutParticipantsInput
  connect: CourseInstanceWhereUniqueInput
}

input CourseInstanceCreateWithoutCourseInput {
  date: DateTime
  topic: String
  notes: String
  participants: ParticipantCreateManyWithoutCourseInstanceInput
  recapUrl: String
}

input CourseInstanceCreateWithoutParticipantsInput {
  course: CourseCreateOneWithoutInstancesInput
  date: DateTime
  topic: String
  notes: String
  recapUrl: String
}

type CourseInstanceEdge {
  node: CourseInstance!
  cursor: String!
}

enum CourseInstanceOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  topic_ASC
  topic_DESC
  notes_ASC
  notes_DESC
  recapUrl_ASC
  recapUrl_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CourseInstancePreviousValues {
  id: ID!
  date: DateTime
  topic: String
  notes: String
  recapUrl: String
}

input CourseInstanceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  topic: String
  topic_not: String
  topic_in: [String!]
  topic_not_in: [String!]
  topic_lt: String
  topic_lte: String
  topic_gt: String
  topic_gte: String
  topic_contains: String
  topic_not_contains: String
  topic_starts_with: String
  topic_not_starts_with: String
  topic_ends_with: String
  topic_not_ends_with: String
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  recapUrl: String
  recapUrl_not: String
  recapUrl_in: [String!]
  recapUrl_not_in: [String!]
  recapUrl_lt: String
  recapUrl_lte: String
  recapUrl_gt: String
  recapUrl_gte: String
  recapUrl_contains: String
  recapUrl_not_contains: String
  recapUrl_starts_with: String
  recapUrl_not_starts_with: String
  recapUrl_ends_with: String
  recapUrl_not_ends_with: String
  AND: [CourseInstanceScalarWhereInput!]
  OR: [CourseInstanceScalarWhereInput!]
  NOT: [CourseInstanceScalarWhereInput!]
}

type CourseInstanceSubscriptionPayload {
  mutation: MutationType!
  node: CourseInstance
  updatedFields: [String!]
  previousValues: CourseInstancePreviousValues
}

input CourseInstanceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseInstanceWhereInput
  AND: [CourseInstanceSubscriptionWhereInput!]
  OR: [CourseInstanceSubscriptionWhereInput!]
  NOT: [CourseInstanceSubscriptionWhereInput!]
}

input CourseInstanceUpdateInput {
  course: CourseUpdateOneWithoutInstancesInput
  date: DateTime
  topic: String
  notes: String
  participants: ParticipantUpdateManyWithoutCourseInstanceInput
  recapUrl: String
}

input CourseInstanceUpdateManyDataInput {
  date: DateTime
  topic: String
  notes: String
  recapUrl: String
}

input CourseInstanceUpdateManyMutationInput {
  date: DateTime
  topic: String
  notes: String
  recapUrl: String
}

input CourseInstanceUpdateManyWithoutCourseInput {
  create: [CourseInstanceCreateWithoutCourseInput!]
  delete: [CourseInstanceWhereUniqueInput!]
  connect: [CourseInstanceWhereUniqueInput!]
  set: [CourseInstanceWhereUniqueInput!]
  disconnect: [CourseInstanceWhereUniqueInput!]
  update: [CourseInstanceUpdateWithWhereUniqueWithoutCourseInput!]
  upsert: [CourseInstanceUpsertWithWhereUniqueWithoutCourseInput!]
  deleteMany: [CourseInstanceScalarWhereInput!]
  updateMany: [CourseInstanceUpdateManyWithWhereNestedInput!]
}

input CourseInstanceUpdateManyWithWhereNestedInput {
  where: CourseInstanceScalarWhereInput!
  data: CourseInstanceUpdateManyDataInput!
}

input CourseInstanceUpdateOneRequiredWithoutParticipantsInput {
  create: CourseInstanceCreateWithoutParticipantsInput
  update: CourseInstanceUpdateWithoutParticipantsDataInput
  upsert: CourseInstanceUpsertWithoutParticipantsInput
  connect: CourseInstanceWhereUniqueInput
}

input CourseInstanceUpdateWithoutCourseDataInput {
  date: DateTime
  topic: String
  notes: String
  participants: ParticipantUpdateManyWithoutCourseInstanceInput
  recapUrl: String
}

input CourseInstanceUpdateWithoutParticipantsDataInput {
  course: CourseUpdateOneWithoutInstancesInput
  date: DateTime
  topic: String
  notes: String
  recapUrl: String
}

input CourseInstanceUpdateWithWhereUniqueWithoutCourseInput {
  where: CourseInstanceWhereUniqueInput!
  data: CourseInstanceUpdateWithoutCourseDataInput!
}

input CourseInstanceUpsertWithoutParticipantsInput {
  update: CourseInstanceUpdateWithoutParticipantsDataInput!
  create: CourseInstanceCreateWithoutParticipantsInput!
}

input CourseInstanceUpsertWithWhereUniqueWithoutCourseInput {
  where: CourseInstanceWhereUniqueInput!
  update: CourseInstanceUpdateWithoutCourseDataInput!
  create: CourseInstanceCreateWithoutCourseInput!
}

input CourseInstanceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  course: CourseWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  topic: String
  topic_not: String
  topic_in: [String!]
  topic_not_in: [String!]
  topic_lt: String
  topic_lte: String
  topic_gt: String
  topic_gte: String
  topic_contains: String
  topic_not_contains: String
  topic_starts_with: String
  topic_not_starts_with: String
  topic_ends_with: String
  topic_not_ends_with: String
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  participants_every: ParticipantWhereInput
  participants_some: ParticipantWhereInput
  participants_none: ParticipantWhereInput
  recapUrl: String
  recapUrl_not: String
  recapUrl_in: [String!]
  recapUrl_not_in: [String!]
  recapUrl_lt: String
  recapUrl_lte: String
  recapUrl_gt: String
  recapUrl_gte: String
  recapUrl_contains: String
  recapUrl_not_contains: String
  recapUrl_starts_with: String
  recapUrl_not_starts_with: String
  recapUrl_ends_with: String
  recapUrl_not_ends_with: String
  AND: [CourseInstanceWhereInput!]
  OR: [CourseInstanceWhereInput!]
  NOT: [CourseInstanceWhereInput!]
}

input CourseInstanceWhereUniqueInput {
  id: ID
}

enum CourseOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  startDate_ASC
  startDate_DESC
  startTime_ASC
  startTime_DESC
  day_ASC
  day_DESC
  duration_ASC
  duration_DESC
  studentLimit_ASC
  studentLimit_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CoursePreviousValues {
  id: ID!
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  studentLimit: Int
}

input CourseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  day: CourseDay
  day_not: CourseDay
  day_in: [CourseDay!]
  day_not_in: [CourseDay!]
  duration: Int
  duration_not: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_gt: Int
  duration_gte: Int
  studentLimit: Int
  studentLimit_not: Int
  studentLimit_in: [Int!]
  studentLimit_not_in: [Int!]
  studentLimit_lt: Int
  studentLimit_lte: Int
  studentLimit_gt: Int
  studentLimit_gte: Int
  AND: [CourseScalarWhereInput!]
  OR: [CourseScalarWhereInput!]
  NOT: [CourseScalarWhereInput!]
}

type CourseStudent {
  id: ID!
  student: Student!
  course: Course!
  role: DanceRole!
}

type CourseStudentConnection {
  pageInfo: PageInfo!
  edges: [CourseStudentEdge]!
  aggregate: AggregateCourseStudent!
}

input CourseStudentCreateInput {
  student: StudentCreateOneWithoutCoursesInput!
  course: CourseCreateOneWithoutCourseStudentsInput!
  role: DanceRole!
}

input CourseStudentCreateManyWithoutCourseInput {
  create: [CourseStudentCreateWithoutCourseInput!]
  connect: [CourseStudentWhereUniqueInput!]
}

input CourseStudentCreateManyWithoutStudentInput {
  create: [CourseStudentCreateWithoutStudentInput!]
  connect: [CourseStudentWhereUniqueInput!]
}

input CourseStudentCreateOneInput {
  create: CourseStudentCreateInput
  connect: CourseStudentWhereUniqueInput
}

input CourseStudentCreateWithoutCourseInput {
  student: StudentCreateOneWithoutCoursesInput!
  role: DanceRole!
}

input CourseStudentCreateWithoutStudentInput {
  course: CourseCreateOneWithoutCourseStudentsInput!
  role: DanceRole!
}

type CourseStudentEdge {
  node: CourseStudent!
  cursor: String!
}

enum CourseStudentOrderByInput {
  id_ASC
  id_DESC
  role_ASC
  role_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CourseStudentPreviousValues {
  id: ID!
  role: DanceRole!
}

input CourseStudentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  role: DanceRole
  role_not: DanceRole
  role_in: [DanceRole!]
  role_not_in: [DanceRole!]
  AND: [CourseStudentScalarWhereInput!]
  OR: [CourseStudentScalarWhereInput!]
  NOT: [CourseStudentScalarWhereInput!]
}

type CourseStudentSubscriptionPayload {
  mutation: MutationType!
  node: CourseStudent
  updatedFields: [String!]
  previousValues: CourseStudentPreviousValues
}

input CourseStudentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseStudentWhereInput
  AND: [CourseStudentSubscriptionWhereInput!]
  OR: [CourseStudentSubscriptionWhereInput!]
  NOT: [CourseStudentSubscriptionWhereInput!]
}

input CourseStudentUpdateDataInput {
  student: StudentUpdateOneRequiredWithoutCoursesInput
  course: CourseUpdateOneRequiredWithoutCourseStudentsInput
  role: DanceRole
}

input CourseStudentUpdateInput {
  student: StudentUpdateOneRequiredWithoutCoursesInput
  course: CourseUpdateOneRequiredWithoutCourseStudentsInput
  role: DanceRole
}

input CourseStudentUpdateManyDataInput {
  role: DanceRole
}

input CourseStudentUpdateManyMutationInput {
  role: DanceRole
}

input CourseStudentUpdateManyWithoutCourseInput {
  create: [CourseStudentCreateWithoutCourseInput!]
  delete: [CourseStudentWhereUniqueInput!]
  connect: [CourseStudentWhereUniqueInput!]
  set: [CourseStudentWhereUniqueInput!]
  disconnect: [CourseStudentWhereUniqueInput!]
  update: [CourseStudentUpdateWithWhereUniqueWithoutCourseInput!]
  upsert: [CourseStudentUpsertWithWhereUniqueWithoutCourseInput!]
  deleteMany: [CourseStudentScalarWhereInput!]
  updateMany: [CourseStudentUpdateManyWithWhereNestedInput!]
}

input CourseStudentUpdateManyWithoutStudentInput {
  create: [CourseStudentCreateWithoutStudentInput!]
  delete: [CourseStudentWhereUniqueInput!]
  connect: [CourseStudentWhereUniqueInput!]
  set: [CourseStudentWhereUniqueInput!]
  disconnect: [CourseStudentWhereUniqueInput!]
  update: [CourseStudentUpdateWithWhereUniqueWithoutStudentInput!]
  upsert: [CourseStudentUpsertWithWhereUniqueWithoutStudentInput!]
  deleteMany: [CourseStudentScalarWhereInput!]
  updateMany: [CourseStudentUpdateManyWithWhereNestedInput!]
}

input CourseStudentUpdateManyWithWhereNestedInput {
  where: CourseStudentScalarWhereInput!
  data: CourseStudentUpdateManyDataInput!
}

input CourseStudentUpdateOneRequiredInput {
  create: CourseStudentCreateInput
  update: CourseStudentUpdateDataInput
  upsert: CourseStudentUpsertNestedInput
  connect: CourseStudentWhereUniqueInput
}

input CourseStudentUpdateWithoutCourseDataInput {
  student: StudentUpdateOneRequiredWithoutCoursesInput
  role: DanceRole
}

input CourseStudentUpdateWithoutStudentDataInput {
  course: CourseUpdateOneRequiredWithoutCourseStudentsInput
  role: DanceRole
}

input CourseStudentUpdateWithWhereUniqueWithoutCourseInput {
  where: CourseStudentWhereUniqueInput!
  data: CourseStudentUpdateWithoutCourseDataInput!
}

input CourseStudentUpdateWithWhereUniqueWithoutStudentInput {
  where: CourseStudentWhereUniqueInput!
  data: CourseStudentUpdateWithoutStudentDataInput!
}

input CourseStudentUpsertNestedInput {
  update: CourseStudentUpdateDataInput!
  create: CourseStudentCreateInput!
}

input CourseStudentUpsertWithWhereUniqueWithoutCourseInput {
  where: CourseStudentWhereUniqueInput!
  update: CourseStudentUpdateWithoutCourseDataInput!
  create: CourseStudentCreateWithoutCourseInput!
}

input CourseStudentUpsertWithWhereUniqueWithoutStudentInput {
  where: CourseStudentWhereUniqueInput!
  update: CourseStudentUpdateWithoutStudentDataInput!
  create: CourseStudentCreateWithoutStudentInput!
}

input CourseStudentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  student: StudentWhereInput
  course: CourseWhereInput
  role: DanceRole
  role_not: DanceRole
  role_in: [DanceRole!]
  role_not_in: [DanceRole!]
  AND: [CourseStudentWhereInput!]
  OR: [CourseStudentWhereInput!]
  NOT: [CourseStudentWhereInput!]
}

input CourseStudentWhereUniqueInput {
  id: ID
}

type CourseSubscriptionPayload {
  mutation: MutationType!
  node: Course
  updatedFields: [String!]
  previousValues: CoursePreviousValues
}

input CourseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseWhereInput
  AND: [CourseSubscriptionWhereInput!]
  OR: [CourseSubscriptionWhereInput!]
  NOT: [CourseSubscriptionWhereInput!]
}

input CourseUpdateInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers: TeacherUpdateManyWithoutCoursesInput
  courseStudents: CourseStudentUpdateManyWithoutCourseInput
  instances: CourseInstanceUpdateManyWithoutCourseInput
  studentLimit: Int
  room: RoomUpdateOneInput
}

input CourseUpdateManyDataInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  studentLimit: Int
}

input CourseUpdateManyMutationInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  studentLimit: Int
}

input CourseUpdateManyWithoutTeachersInput {
  create: [CourseCreateWithoutTeachersInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutTeachersInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutTeachersInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithWhereNestedInput {
  where: CourseScalarWhereInput!
  data: CourseUpdateManyDataInput!
}

input CourseUpdateOneRequiredWithoutCourseStudentsInput {
  create: CourseCreateWithoutCourseStudentsInput
  update: CourseUpdateWithoutCourseStudentsDataInput
  upsert: CourseUpsertWithoutCourseStudentsInput
  connect: CourseWhereUniqueInput
}

input CourseUpdateOneWithoutInstancesInput {
  create: CourseCreateWithoutInstancesInput
  update: CourseUpdateWithoutInstancesDataInput
  upsert: CourseUpsertWithoutInstancesInput
  delete: Boolean
  disconnect: Boolean
  connect: CourseWhereUniqueInput
}

input CourseUpdateWithoutCourseStudentsDataInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers: TeacherUpdateManyWithoutCoursesInput
  instances: CourseInstanceUpdateManyWithoutCourseInput
  studentLimit: Int
  room: RoomUpdateOneInput
}

input CourseUpdateWithoutInstancesDataInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  teachers: TeacherUpdateManyWithoutCoursesInput
  courseStudents: CourseStudentUpdateManyWithoutCourseInput
  studentLimit: Int
  room: RoomUpdateOneInput
}

input CourseUpdateWithoutTeachersDataInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  day: CourseDay
  duration: Int
  courseStudents: CourseStudentUpdateManyWithoutCourseInput
  instances: CourseInstanceUpdateManyWithoutCourseInput
  studentLimit: Int
  room: RoomUpdateOneInput
}

input CourseUpdateWithWhereUniqueWithoutTeachersInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutTeachersDataInput!
}

input CourseUpsertWithoutCourseStudentsInput {
  update: CourseUpdateWithoutCourseStudentsDataInput!
  create: CourseCreateWithoutCourseStudentsInput!
}

input CourseUpsertWithoutInstancesInput {
  update: CourseUpdateWithoutInstancesDataInput!
  create: CourseCreateWithoutInstancesInput!
}

input CourseUpsertWithWhereUniqueWithoutTeachersInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutTeachersDataInput!
  create: CourseCreateWithoutTeachersInput!
}

input CourseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  day: CourseDay
  day_not: CourseDay
  day_in: [CourseDay!]
  day_not_in: [CourseDay!]
  duration: Int
  duration_not: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_gt: Int
  duration_gte: Int
  teachers_every: TeacherWhereInput
  teachers_some: TeacherWhereInput
  teachers_none: TeacherWhereInput
  courseStudents_every: CourseStudentWhereInput
  courseStudents_some: CourseStudentWhereInput
  courseStudents_none: CourseStudentWhereInput
  instances_every: CourseInstanceWhereInput
  instances_some: CourseInstanceWhereInput
  instances_none: CourseInstanceWhereInput
  studentLimit: Int
  studentLimit_not: Int
  studentLimit_in: [Int!]
  studentLimit_not_in: [Int!]
  studentLimit_lt: Int
  studentLimit_lte: Int
  studentLimit_gt: Int
  studentLimit_gte: Int
  room: RoomWhereInput
  AND: [CourseWhereInput!]
  OR: [CourseWhereInput!]
  NOT: [CourseWhereInput!]
}

input CourseWhereUniqueInput {
  id: ID
}

enum DanceRole {
  LEADER
  FOLLOWER
  SOLO
}

scalar DateTime

scalar Long

type Mutation {
  createCard(data: CardCreateInput!): Card!
  updateCard(data: CardUpdateInput!, where: CardWhereUniqueInput!): Card
  updateManyCards(data: CardUpdateManyMutationInput!, where: CardWhereInput): BatchPayload!
  upsertCard(where: CardWhereUniqueInput!, create: CardCreateInput!, update: CardUpdateInput!): Card!
  deleteCard(where: CardWhereUniqueInput!): Card
  deleteManyCards(where: CardWhereInput): BatchPayload!
  createCourse(data: CourseCreateInput!): Course!
  updateCourse(data: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course
  updateManyCourses(data: CourseUpdateManyMutationInput!, where: CourseWhereInput): BatchPayload!
  upsertCourse(where: CourseWhereUniqueInput!, create: CourseCreateInput!, update: CourseUpdateInput!): Course!
  deleteCourse(where: CourseWhereUniqueInput!): Course
  deleteManyCourses(where: CourseWhereInput): BatchPayload!
  createCourseInstance(data: CourseInstanceCreateInput!): CourseInstance!
  updateCourseInstance(data: CourseInstanceUpdateInput!, where: CourseInstanceWhereUniqueInput!): CourseInstance
  updateManyCourseInstances(data: CourseInstanceUpdateManyMutationInput!, where: CourseInstanceWhereInput): BatchPayload!
  upsertCourseInstance(where: CourseInstanceWhereUniqueInput!, create: CourseInstanceCreateInput!, update: CourseInstanceUpdateInput!): CourseInstance!
  deleteCourseInstance(where: CourseInstanceWhereUniqueInput!): CourseInstance
  deleteManyCourseInstances(where: CourseInstanceWhereInput): BatchPayload!
  createCourseStudent(data: CourseStudentCreateInput!): CourseStudent!
  updateCourseStudent(data: CourseStudentUpdateInput!, where: CourseStudentWhereUniqueInput!): CourseStudent
  updateManyCourseStudents(data: CourseStudentUpdateManyMutationInput!, where: CourseStudentWhereInput): BatchPayload!
  upsertCourseStudent(where: CourseStudentWhereUniqueInput!, create: CourseStudentCreateInput!, update: CourseStudentUpdateInput!): CourseStudent!
  deleteCourseStudent(where: CourseStudentWhereUniqueInput!): CourseStudent
  deleteManyCourseStudents(where: CourseStudentWhereInput): BatchPayload!
  createParticipant(data: ParticipantCreateInput!): Participant!
  updateParticipant(data: ParticipantUpdateInput!, where: ParticipantWhereUniqueInput!): Participant
  updateManyParticipants(data: ParticipantUpdateManyMutationInput!, where: ParticipantWhereInput): BatchPayload!
  upsertParticipant(where: ParticipantWhereUniqueInput!, create: ParticipantCreateInput!, update: ParticipantUpdateInput!): Participant!
  deleteParticipant(where: ParticipantWhereUniqueInput!): Participant
  deleteManyParticipants(where: ParticipantWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createRoom(data: RoomCreateInput!): Room!
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateManyRooms(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  createStudent(data: StudentCreateInput!): Student!
  updateStudent(data: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student
  updateManyStudents(data: StudentUpdateManyMutationInput!, where: StudentWhereInput): BatchPayload!
  upsertStudent(where: StudentWhereUniqueInput!, create: StudentCreateInput!, update: StudentUpdateInput!): Student!
  deleteStudent(where: StudentWhereUniqueInput!): Student
  deleteManyStudents(where: StudentWhereInput): BatchPayload!
  createStudio(data: StudioCreateInput!): Studio!
  updateStudio(data: StudioUpdateInput!, where: StudioWhereUniqueInput!): Studio
  updateManyStudios(data: StudioUpdateManyMutationInput!, where: StudioWhereInput): BatchPayload!
  upsertStudio(where: StudioWhereUniqueInput!, create: StudioCreateInput!, update: StudioUpdateInput!): Studio!
  deleteStudio(where: StudioWhereUniqueInput!): Studio
  deleteManyStudios(where: StudioWhereInput): BatchPayload!
  createTeacher(data: TeacherCreateInput!): Teacher!
  updateTeacher(data: TeacherUpdateInput!, where: TeacherWhereUniqueInput!): Teacher
  updateManyTeachers(data: TeacherUpdateManyMutationInput!, where: TeacherWhereInput): BatchPayload!
  upsertTeacher(where: TeacherWhereUniqueInput!, create: TeacherCreateInput!, update: TeacherUpdateInput!): Teacher!
  deleteTeacher(where: TeacherWhereUniqueInput!): Teacher
  deleteManyTeachers(where: TeacherWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Participant {
  id: ID!
  courseStudent: CourseStudent!
  courseInstance: CourseInstance!
  status: ParticipantStatus
}

type ParticipantConnection {
  pageInfo: PageInfo!
  edges: [ParticipantEdge]!
  aggregate: AggregateParticipant!
}

input ParticipantCreateInput {
  courseStudent: CourseStudentCreateOneInput!
  courseInstance: CourseInstanceCreateOneWithoutParticipantsInput!
  status: ParticipantStatus
}

input ParticipantCreateManyInput {
  create: [ParticipantCreateInput!]
  connect: [ParticipantWhereUniqueInput!]
}

input ParticipantCreateManyWithoutCourseInstanceInput {
  create: [ParticipantCreateWithoutCourseInstanceInput!]
  connect: [ParticipantWhereUniqueInput!]
}

input ParticipantCreateWithoutCourseInstanceInput {
  courseStudent: CourseStudentCreateOneInput!
  status: ParticipantStatus
}

type ParticipantEdge {
  node: Participant!
  cursor: String!
}

enum ParticipantOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ParticipantPreviousValues {
  id: ID!
  status: ParticipantStatus
}

input ParticipantScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: ParticipantStatus
  status_not: ParticipantStatus
  status_in: [ParticipantStatus!]
  status_not_in: [ParticipantStatus!]
  AND: [ParticipantScalarWhereInput!]
  OR: [ParticipantScalarWhereInput!]
  NOT: [ParticipantScalarWhereInput!]
}

enum ParticipantStatus {
  PRESENT
  ABSENT
  NOT_LOGGED
}

type ParticipantSubscriptionPayload {
  mutation: MutationType!
  node: Participant
  updatedFields: [String!]
  previousValues: ParticipantPreviousValues
}

input ParticipantSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ParticipantWhereInput
  AND: [ParticipantSubscriptionWhereInput!]
  OR: [ParticipantSubscriptionWhereInput!]
  NOT: [ParticipantSubscriptionWhereInput!]
}

input ParticipantUpdateDataInput {
  courseStudent: CourseStudentUpdateOneRequiredInput
  courseInstance: CourseInstanceUpdateOneRequiredWithoutParticipantsInput
  status: ParticipantStatus
}

input ParticipantUpdateInput {
  courseStudent: CourseStudentUpdateOneRequiredInput
  courseInstance: CourseInstanceUpdateOneRequiredWithoutParticipantsInput
  status: ParticipantStatus
}

input ParticipantUpdateManyDataInput {
  status: ParticipantStatus
}

input ParticipantUpdateManyInput {
  create: [ParticipantCreateInput!]
  update: [ParticipantUpdateWithWhereUniqueNestedInput!]
  upsert: [ParticipantUpsertWithWhereUniqueNestedInput!]
  delete: [ParticipantWhereUniqueInput!]
  connect: [ParticipantWhereUniqueInput!]
  set: [ParticipantWhereUniqueInput!]
  disconnect: [ParticipantWhereUniqueInput!]
  deleteMany: [ParticipantScalarWhereInput!]
  updateMany: [ParticipantUpdateManyWithWhereNestedInput!]
}

input ParticipantUpdateManyMutationInput {
  status: ParticipantStatus
}

input ParticipantUpdateManyWithoutCourseInstanceInput {
  create: [ParticipantCreateWithoutCourseInstanceInput!]
  delete: [ParticipantWhereUniqueInput!]
  connect: [ParticipantWhereUniqueInput!]
  set: [ParticipantWhereUniqueInput!]
  disconnect: [ParticipantWhereUniqueInput!]
  update: [ParticipantUpdateWithWhereUniqueWithoutCourseInstanceInput!]
  upsert: [ParticipantUpsertWithWhereUniqueWithoutCourseInstanceInput!]
  deleteMany: [ParticipantScalarWhereInput!]
  updateMany: [ParticipantUpdateManyWithWhereNestedInput!]
}

input ParticipantUpdateManyWithWhereNestedInput {
  where: ParticipantScalarWhereInput!
  data: ParticipantUpdateManyDataInput!
}

input ParticipantUpdateWithoutCourseInstanceDataInput {
  courseStudent: CourseStudentUpdateOneRequiredInput
  status: ParticipantStatus
}

input ParticipantUpdateWithWhereUniqueNestedInput {
  where: ParticipantWhereUniqueInput!
  data: ParticipantUpdateDataInput!
}

input ParticipantUpdateWithWhereUniqueWithoutCourseInstanceInput {
  where: ParticipantWhereUniqueInput!
  data: ParticipantUpdateWithoutCourseInstanceDataInput!
}

input ParticipantUpsertWithWhereUniqueNestedInput {
  where: ParticipantWhereUniqueInput!
  update: ParticipantUpdateDataInput!
  create: ParticipantCreateInput!
}

input ParticipantUpsertWithWhereUniqueWithoutCourseInstanceInput {
  where: ParticipantWhereUniqueInput!
  update: ParticipantUpdateWithoutCourseInstanceDataInput!
  create: ParticipantCreateWithoutCourseInstanceInput!
}

input ParticipantWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  courseStudent: CourseStudentWhereInput
  courseInstance: CourseInstanceWhereInput
  status: ParticipantStatus
  status_not: ParticipantStatus
  status_in: [ParticipantStatus!]
  status_not_in: [ParticipantStatus!]
  AND: [ParticipantWhereInput!]
  OR: [ParticipantWhereInput!]
  NOT: [ParticipantWhereInput!]
}

input ParticipantWhereUniqueInput {
  id: ID
}

type Payment {
  id: ID!
  type: PaymentType!
  date: DateTime!
  amount: Int!
  student: Student
  card: Card
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  type: PaymentType!
  date: DateTime!
  amount: Int!
  student: StudentCreateOneWithoutPaymentsInput
  card: CardCreateOneWithoutPaymentInput
}

input PaymentCreateManyWithoutStudentInput {
  create: [PaymentCreateWithoutStudentInput!]
  connect: [PaymentWhereUniqueInput!]
}

input PaymentCreateOneWithoutCardInput {
  create: PaymentCreateWithoutCardInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutCardInput {
  type: PaymentType!
  date: DateTime!
  amount: Int!
  student: StudentCreateOneWithoutPaymentsInput
}

input PaymentCreateWithoutStudentInput {
  type: PaymentType!
  date: DateTime!
  amount: Int!
  card: CardCreateOneWithoutPaymentInput
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  date_ASC
  date_DESC
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PaymentPreviousValues {
  id: ID!
  type: PaymentType!
  date: DateTime!
  amount: Int!
}

input PaymentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: PaymentType
  type_not: PaymentType
  type_in: [PaymentType!]
  type_not_in: [PaymentType!]
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  AND: [PaymentScalarWhereInput!]
  OR: [PaymentScalarWhereInput!]
  NOT: [PaymentScalarWhereInput!]
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

enum PaymentType {
  CARD
  PRIVATE
  DROP_IN
}

input PaymentUpdateInput {
  type: PaymentType
  date: DateTime
  amount: Int
  student: StudentUpdateOneWithoutPaymentsInput
  card: CardUpdateOneWithoutPaymentInput
}

input PaymentUpdateManyDataInput {
  type: PaymentType
  date: DateTime
  amount: Int
}

input PaymentUpdateManyMutationInput {
  type: PaymentType
  date: DateTime
  amount: Int
}

input PaymentUpdateManyWithoutStudentInput {
  create: [PaymentCreateWithoutStudentInput!]
  delete: [PaymentWhereUniqueInput!]
  connect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  disconnect: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutStudentInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutStudentInput!]
  deleteMany: [PaymentScalarWhereInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
}

input PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput!
  data: PaymentUpdateManyDataInput!
}

input PaymentUpdateOneWithoutCardInput {
  create: PaymentCreateWithoutCardInput
  update: PaymentUpdateWithoutCardDataInput
  upsert: PaymentUpsertWithoutCardInput
  delete: Boolean
  disconnect: Boolean
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutCardDataInput {
  type: PaymentType
  date: DateTime
  amount: Int
  student: StudentUpdateOneWithoutPaymentsInput
}

input PaymentUpdateWithoutStudentDataInput {
  type: PaymentType
  date: DateTime
  amount: Int
  card: CardUpdateOneWithoutPaymentInput
}

input PaymentUpdateWithWhereUniqueWithoutStudentInput {
  where: PaymentWhereUniqueInput!
  data: PaymentUpdateWithoutStudentDataInput!
}

input PaymentUpsertWithoutCardInput {
  update: PaymentUpdateWithoutCardDataInput!
  create: PaymentCreateWithoutCardInput!
}

input PaymentUpsertWithWhereUniqueWithoutStudentInput {
  where: PaymentWhereUniqueInput!
  update: PaymentUpdateWithoutStudentDataInput!
  create: PaymentCreateWithoutStudentInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: PaymentType
  type_not: PaymentType
  type_in: [PaymentType!]
  type_not_in: [PaymentType!]
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  student: StudentWhereInput
  card: CardWhereInput
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type Query {
  card(where: CardWhereUniqueInput!): Card
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card]!
  cardsConnection(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CardConnection!
  course(where: CourseWhereUniqueInput!): Course
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course]!
  coursesConnection(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseConnection!
  courseInstance(where: CourseInstanceWhereUniqueInput!): CourseInstance
  courseInstances(where: CourseInstanceWhereInput, orderBy: CourseInstanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseInstance]!
  courseInstancesConnection(where: CourseInstanceWhereInput, orderBy: CourseInstanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseInstanceConnection!
  courseStudent(where: CourseStudentWhereUniqueInput!): CourseStudent
  courseStudents(where: CourseStudentWhereInput, orderBy: CourseStudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseStudent]!
  courseStudentsConnection(where: CourseStudentWhereInput, orderBy: CourseStudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseStudentConnection!
  participant(where: ParticipantWhereUniqueInput!): Participant
  participants(where: ParticipantWhereInput, orderBy: ParticipantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Participant]!
  participantsConnection(where: ParticipantWhereInput, orderBy: ParticipantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ParticipantConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  room(where: RoomWhereUniqueInput!): Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  student(where: StudentWhereUniqueInput!): Student
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student]!
  studentsConnection(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudentConnection!
  studio(where: StudioWhereUniqueInput!): Studio
  studios(where: StudioWhereInput, orderBy: StudioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Studio]!
  studiosConnection(where: StudioWhereInput, orderBy: StudioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudioConnection!
  teacher(where: TeacherWhereUniqueInput!): Teacher
  teachers(where: TeacherWhereInput, orderBy: TeacherOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Teacher]!
  teachersConnection(where: TeacherWhereInput, orderBy: TeacherOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeacherConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Room {
  id: ID!
  name: String
  capacity: Int
  studio: Studio!
}

type RoomConnection {
  pageInfo: PageInfo!
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  name: String
  capacity: Int
  studio: StudioCreateOneWithoutRoomsInput!
}

input RoomCreateManyWithoutStudioInput {
  create: [RoomCreateWithoutStudioInput!]
  connect: [RoomWhereUniqueInput!]
}

input RoomCreateOneInput {
  create: RoomCreateInput
  connect: RoomWhereUniqueInput
}

input RoomCreateWithoutStudioInput {
  name: String
  capacity: Int
}

type RoomEdge {
  node: Room!
  cursor: String!
}

enum RoomOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  capacity_ASC
  capacity_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RoomPreviousValues {
  id: ID!
  name: String
  capacity: Int
}

input RoomScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  capacity: Int
  capacity_not: Int
  capacity_in: [Int!]
  capacity_not_in: [Int!]
  capacity_lt: Int
  capacity_lte: Int
  capacity_gt: Int
  capacity_gte: Int
  AND: [RoomScalarWhereInput!]
  OR: [RoomScalarWhereInput!]
  NOT: [RoomScalarWhereInput!]
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
  AND: [RoomSubscriptionWhereInput!]
  OR: [RoomSubscriptionWhereInput!]
  NOT: [RoomSubscriptionWhereInput!]
}

input RoomUpdateDataInput {
  name: String
  capacity: Int
  studio: StudioUpdateOneRequiredWithoutRoomsInput
}

input RoomUpdateInput {
  name: String
  capacity: Int
  studio: StudioUpdateOneRequiredWithoutRoomsInput
}

input RoomUpdateManyDataInput {
  name: String
  capacity: Int
}

input RoomUpdateManyMutationInput {
  name: String
  capacity: Int
}

input RoomUpdateManyWithoutStudioInput {
  create: [RoomCreateWithoutStudioInput!]
  delete: [RoomWhereUniqueInput!]
  connect: [RoomWhereUniqueInput!]
  set: [RoomWhereUniqueInput!]
  disconnect: [RoomWhereUniqueInput!]
  update: [RoomUpdateWithWhereUniqueWithoutStudioInput!]
  upsert: [RoomUpsertWithWhereUniqueWithoutStudioInput!]
  deleteMany: [RoomScalarWhereInput!]
  updateMany: [RoomUpdateManyWithWhereNestedInput!]
}

input RoomUpdateManyWithWhereNestedInput {
  where: RoomScalarWhereInput!
  data: RoomUpdateManyDataInput!
}

input RoomUpdateOneInput {
  create: RoomCreateInput
  update: RoomUpdateDataInput
  upsert: RoomUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: RoomWhereUniqueInput
}

input RoomUpdateWithoutStudioDataInput {
  name: String
  capacity: Int
}

input RoomUpdateWithWhereUniqueWithoutStudioInput {
  where: RoomWhereUniqueInput!
  data: RoomUpdateWithoutStudioDataInput!
}

input RoomUpsertNestedInput {
  update: RoomUpdateDataInput!
  create: RoomCreateInput!
}

input RoomUpsertWithWhereUniqueWithoutStudioInput {
  where: RoomWhereUniqueInput!
  update: RoomUpdateWithoutStudioDataInput!
  create: RoomCreateWithoutStudioInput!
}

input RoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  capacity: Int
  capacity_not: Int
  capacity_in: [Int!]
  capacity_not_in: [Int!]
  capacity_lt: Int
  capacity_lte: Int
  capacity_gt: Int
  capacity_gte: Int
  studio: StudioWhereInput
  AND: [RoomWhereInput!]
  OR: [RoomWhereInput!]
  NOT: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  id: ID
}

type Student {
  id: ID!
  name: String!
  email: String!
  mobile: String
  courses(where: CourseStudentWhereInput, orderBy: CourseStudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseStudent!]
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card!]
  hasReferralBonus: Boolean!
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment!]
}

type StudentConnection {
  pageInfo: PageInfo!
  edges: [StudentEdge]!
  aggregate: AggregateStudent!
}

input StudentCreateInput {
  name: String!
  email: String!
  mobile: String
  courses: CourseStudentCreateManyWithoutStudentInput
  cards: CardCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentCreateManyWithoutStudentInput
}

input StudentCreateOneWithoutCardsInput {
  create: StudentCreateWithoutCardsInput
  connect: StudentWhereUniqueInput
}

input StudentCreateOneWithoutCoursesInput {
  create: StudentCreateWithoutCoursesInput
  connect: StudentWhereUniqueInput
}

input StudentCreateOneWithoutPaymentsInput {
  create: StudentCreateWithoutPaymentsInput
  connect: StudentWhereUniqueInput
}

input StudentCreateWithoutCardsInput {
  name: String!
  email: String!
  mobile: String
  courses: CourseStudentCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentCreateManyWithoutStudentInput
}

input StudentCreateWithoutCoursesInput {
  name: String!
  email: String!
  mobile: String
  cards: CardCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentCreateManyWithoutStudentInput
}

input StudentCreateWithoutPaymentsInput {
  name: String!
  email: String!
  mobile: String
  courses: CourseStudentCreateManyWithoutStudentInput
  cards: CardCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
}

type StudentEdge {
  node: Student!
  cursor: String!
}

enum StudentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  mobile_ASC
  mobile_DESC
  hasReferralBonus_ASC
  hasReferralBonus_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StudentPreviousValues {
  id: ID!
  name: String!
  email: String!
  mobile: String
  hasReferralBonus: Boolean!
}

type StudentSubscriptionPayload {
  mutation: MutationType!
  node: Student
  updatedFields: [String!]
  previousValues: StudentPreviousValues
}

input StudentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudentWhereInput
  AND: [StudentSubscriptionWhereInput!]
  OR: [StudentSubscriptionWhereInput!]
  NOT: [StudentSubscriptionWhereInput!]
}

input StudentUpdateInput {
  name: String
  email: String
  mobile: String
  courses: CourseStudentUpdateManyWithoutStudentInput
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentUpdateManyWithoutStudentInput
}

input StudentUpdateManyMutationInput {
  name: String
  email: String
  mobile: String
  hasReferralBonus: Boolean
}

input StudentUpdateOneRequiredWithoutCardsInput {
  create: StudentCreateWithoutCardsInput
  update: StudentUpdateWithoutCardsDataInput
  upsert: StudentUpsertWithoutCardsInput
  connect: StudentWhereUniqueInput
}

input StudentUpdateOneRequiredWithoutCoursesInput {
  create: StudentCreateWithoutCoursesInput
  update: StudentUpdateWithoutCoursesDataInput
  upsert: StudentUpsertWithoutCoursesInput
  connect: StudentWhereUniqueInput
}

input StudentUpdateOneWithoutPaymentsInput {
  create: StudentCreateWithoutPaymentsInput
  update: StudentUpdateWithoutPaymentsDataInput
  upsert: StudentUpsertWithoutPaymentsInput
  delete: Boolean
  disconnect: Boolean
  connect: StudentWhereUniqueInput
}

input StudentUpdateWithoutCardsDataInput {
  name: String
  email: String
  mobile: String
  courses: CourseStudentUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentUpdateManyWithoutStudentInput
}

input StudentUpdateWithoutCoursesDataInput {
  name: String
  email: String
  mobile: String
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentUpdateManyWithoutStudentInput
}

input StudentUpdateWithoutPaymentsDataInput {
  name: String
  email: String
  mobile: String
  courses: CourseStudentUpdateManyWithoutStudentInput
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
}

input StudentUpsertWithoutCardsInput {
  update: StudentUpdateWithoutCardsDataInput!
  create: StudentCreateWithoutCardsInput!
}

input StudentUpsertWithoutCoursesInput {
  update: StudentUpdateWithoutCoursesDataInput!
  create: StudentCreateWithoutCoursesInput!
}

input StudentUpsertWithoutPaymentsInput {
  update: StudentUpdateWithoutPaymentsDataInput!
  create: StudentCreateWithoutPaymentsInput!
}

input StudentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobile: String
  mobile_not: String
  mobile_in: [String!]
  mobile_not_in: [String!]
  mobile_lt: String
  mobile_lte: String
  mobile_gt: String
  mobile_gte: String
  mobile_contains: String
  mobile_not_contains: String
  mobile_starts_with: String
  mobile_not_starts_with: String
  mobile_ends_with: String
  mobile_not_ends_with: String
  courses_every: CourseStudentWhereInput
  courses_some: CourseStudentWhereInput
  courses_none: CourseStudentWhereInput
  cards_every: CardWhereInput
  cards_some: CardWhereInput
  cards_none: CardWhereInput
  hasReferralBonus: Boolean
  hasReferralBonus_not: Boolean
  payments_every: PaymentWhereInput
  payments_some: PaymentWhereInput
  payments_none: PaymentWhereInput
  AND: [StudentWhereInput!]
  OR: [StudentWhereInput!]
  NOT: [StudentWhereInput!]
}

input StudentWhereUniqueInput {
  id: ID
  name: String
  email: String
}

type Studio {
  id: ID!
  name: String
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room!]
  address: String
}

type StudioConnection {
  pageInfo: PageInfo!
  edges: [StudioEdge]!
  aggregate: AggregateStudio!
}

input StudioCreateInput {
  name: String
  rooms: RoomCreateManyWithoutStudioInput
  address: String
}

input StudioCreateOneWithoutRoomsInput {
  create: StudioCreateWithoutRoomsInput
  connect: StudioWhereUniqueInput
}

input StudioCreateWithoutRoomsInput {
  name: String
  address: String
}

type StudioEdge {
  node: Studio!
  cursor: String!
}

enum StudioOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  address_ASC
  address_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StudioPreviousValues {
  id: ID!
  name: String
  address: String
}

type StudioSubscriptionPayload {
  mutation: MutationType!
  node: Studio
  updatedFields: [String!]
  previousValues: StudioPreviousValues
}

input StudioSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudioWhereInput
  AND: [StudioSubscriptionWhereInput!]
  OR: [StudioSubscriptionWhereInput!]
  NOT: [StudioSubscriptionWhereInput!]
}

input StudioUpdateInput {
  name: String
  rooms: RoomUpdateManyWithoutStudioInput
  address: String
}

input StudioUpdateManyMutationInput {
  name: String
  address: String
}

input StudioUpdateOneRequiredWithoutRoomsInput {
  create: StudioCreateWithoutRoomsInput
  update: StudioUpdateWithoutRoomsDataInput
  upsert: StudioUpsertWithoutRoomsInput
  connect: StudioWhereUniqueInput
}

input StudioUpdateWithoutRoomsDataInput {
  name: String
  address: String
}

input StudioUpsertWithoutRoomsInput {
  update: StudioUpdateWithoutRoomsDataInput!
  create: StudioCreateWithoutRoomsInput!
}

input StudioWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  rooms_every: RoomWhereInput
  rooms_some: RoomWhereInput
  rooms_none: RoomWhereInput
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  AND: [StudioWhereInput!]
  OR: [StudioWhereInput!]
  NOT: [StudioWhereInput!]
}

input StudioWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  card(where: CardSubscriptionWhereInput): CardSubscriptionPayload
  course(where: CourseSubscriptionWhereInput): CourseSubscriptionPayload
  courseInstance(where: CourseInstanceSubscriptionWhereInput): CourseInstanceSubscriptionPayload
  courseStudent(where: CourseStudentSubscriptionWhereInput): CourseStudentSubscriptionPayload
  participant(where: ParticipantSubscriptionWhereInput): ParticipantSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  student(where: StudentSubscriptionWhereInput): StudentSubscriptionPayload
  studio(where: StudioSubscriptionWhereInput): StudioSubscriptionPayload
  teacher(where: TeacherSubscriptionWhereInput): TeacherSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Teacher {
  id: ID!
  name: String!
  email: String!
  mobile: String
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
}

type TeacherConnection {
  pageInfo: PageInfo!
  edges: [TeacherEdge]!
  aggregate: AggregateTeacher!
}

input TeacherCreateInput {
  name: String!
  email: String!
  mobile: String
  courses: CourseCreateManyWithoutTeachersInput
}

input TeacherCreateManyWithoutCoursesInput {
  create: [TeacherCreateWithoutCoursesInput!]
  connect: [TeacherWhereUniqueInput!]
}

input TeacherCreateWithoutCoursesInput {
  name: String!
  email: String!
  mobile: String
}

type TeacherEdge {
  node: Teacher!
  cursor: String!
}

enum TeacherOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  mobile_ASC
  mobile_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TeacherPreviousValues {
  id: ID!
  name: String!
  email: String!
  mobile: String
}

input TeacherScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobile: String
  mobile_not: String
  mobile_in: [String!]
  mobile_not_in: [String!]
  mobile_lt: String
  mobile_lte: String
  mobile_gt: String
  mobile_gte: String
  mobile_contains: String
  mobile_not_contains: String
  mobile_starts_with: String
  mobile_not_starts_with: String
  mobile_ends_with: String
  mobile_not_ends_with: String
  AND: [TeacherScalarWhereInput!]
  OR: [TeacherScalarWhereInput!]
  NOT: [TeacherScalarWhereInput!]
}

type TeacherSubscriptionPayload {
  mutation: MutationType!
  node: Teacher
  updatedFields: [String!]
  previousValues: TeacherPreviousValues
}

input TeacherSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeacherWhereInput
  AND: [TeacherSubscriptionWhereInput!]
  OR: [TeacherSubscriptionWhereInput!]
  NOT: [TeacherSubscriptionWhereInput!]
}

input TeacherUpdateInput {
  name: String
  email: String
  mobile: String
  courses: CourseUpdateManyWithoutTeachersInput
}

input TeacherUpdateManyDataInput {
  name: String
  email: String
  mobile: String
}

input TeacherUpdateManyMutationInput {
  name: String
  email: String
  mobile: String
}

input TeacherUpdateManyWithoutCoursesInput {
  create: [TeacherCreateWithoutCoursesInput!]
  delete: [TeacherWhereUniqueInput!]
  connect: [TeacherWhereUniqueInput!]
  set: [TeacherWhereUniqueInput!]
  disconnect: [TeacherWhereUniqueInput!]
  update: [TeacherUpdateWithWhereUniqueWithoutCoursesInput!]
  upsert: [TeacherUpsertWithWhereUniqueWithoutCoursesInput!]
  deleteMany: [TeacherScalarWhereInput!]
  updateMany: [TeacherUpdateManyWithWhereNestedInput!]
}

input TeacherUpdateManyWithWhereNestedInput {
  where: TeacherScalarWhereInput!
  data: TeacherUpdateManyDataInput!
}

input TeacherUpdateWithoutCoursesDataInput {
  name: String
  email: String
  mobile: String
}

input TeacherUpdateWithWhereUniqueWithoutCoursesInput {
  where: TeacherWhereUniqueInput!
  data: TeacherUpdateWithoutCoursesDataInput!
}

input TeacherUpsertWithWhereUniqueWithoutCoursesInput {
  where: TeacherWhereUniqueInput!
  update: TeacherUpdateWithoutCoursesDataInput!
  create: TeacherCreateWithoutCoursesInput!
}

input TeacherWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobile: String
  mobile_not: String
  mobile_in: [String!]
  mobile_not_in: [String!]
  mobile_lt: String
  mobile_lte: String
  mobile_gt: String
  mobile_gte: String
  mobile_contains: String
  mobile_not_contains: String
  mobile_starts_with: String
  mobile_not_starts_with: String
  mobile_ends_with: String
  mobile_not_ends_with: String
  courses_every: CourseWhereInput
  courses_some: CourseWhereInput
  courses_none: CourseWhereInput
  AND: [TeacherWhereInput!]
  OR: [TeacherWhereInput!]
  NOT: [TeacherWhereInput!]
}

input TeacherWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  email: String
  password: String!
  name: String!
  admin: Boolean!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  email: String
  password: String!
  name: String!
  admin: Boolean
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  admin_ASC
  admin_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String
  password: String!
  name: String!
  admin: Boolean!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  password: String
  name: String
  admin: Boolean
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  name: String
  admin: Boolean
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  admin: Boolean
  admin_not: Boolean
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    