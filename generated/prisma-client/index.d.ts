// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  card: (where?: CardWhereInput) => Promise<boolean>;
  course: (where?: CourseWhereInput) => Promise<boolean>;
  courseAbsence: (where?: CourseAbsenceWhereInput) => Promise<boolean>;
  courseInstance: (where?: CourseInstanceWhereInput) => Promise<boolean>;
  expense: (where?: ExpenseWhereInput) => Promise<boolean>;
  loginResponse: (where?: LoginResponseWhereInput) => Promise<boolean>;
  mailgunEmailPayload: (
    where?: MailgunEmailPayloadWhereInput
  ) => Promise<boolean>;
  membership: (where?: MembershipWhereInput) => Promise<boolean>;
  participant: (where?: ParticipantWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  room: (where?: RoomWhereInput) => Promise<boolean>;
  student: (where?: StudentWhereInput) => Promise<boolean>;
  studio: (where?: StudioWhereInput) => Promise<boolean>;
  teacher: (where?: TeacherWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  card: (where: CardWhereUniqueInput) => CardNullablePromise;
  cards: (args?: {
    where?: CardWhereInput;
    orderBy?: CardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Card>;
  cardsConnection: (args?: {
    where?: CardWhereInput;
    orderBy?: CardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CardConnectionPromise;
  course: (where: CourseWhereUniqueInput) => CourseNullablePromise;
  courses: (args?: {
    where?: CourseWhereInput;
    orderBy?: CourseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Course>;
  coursesConnection: (args?: {
    where?: CourseWhereInput;
    orderBy?: CourseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CourseConnectionPromise;
  courseAbsence: (
    where: CourseAbsenceWhereUniqueInput
  ) => CourseAbsenceNullablePromise;
  courseAbsences: (args?: {
    where?: CourseAbsenceWhereInput;
    orderBy?: CourseAbsenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CourseAbsence>;
  courseAbsencesConnection: (args?: {
    where?: CourseAbsenceWhereInput;
    orderBy?: CourseAbsenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CourseAbsenceConnectionPromise;
  courseInstance: (
    where: CourseInstanceWhereUniqueInput
  ) => CourseInstanceNullablePromise;
  courseInstances: (args?: {
    where?: CourseInstanceWhereInput;
    orderBy?: CourseInstanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CourseInstance>;
  courseInstancesConnection: (args?: {
    where?: CourseInstanceWhereInput;
    orderBy?: CourseInstanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CourseInstanceConnectionPromise;
  expense: (where: ExpenseWhereUniqueInput) => ExpenseNullablePromise;
  expenses: (args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Expense>;
  expensesConnection: (args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExpenseConnectionPromise;
  loginResponse: (
    where: LoginResponseWhereUniqueInput
  ) => LoginResponseNullablePromise;
  loginResponses: (args?: {
    where?: LoginResponseWhereInput;
    orderBy?: LoginResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LoginResponse>;
  loginResponsesConnection: (args?: {
    where?: LoginResponseWhereInput;
    orderBy?: LoginResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LoginResponseConnectionPromise;
  mailgunEmailPayload: (
    where: MailgunEmailPayloadWhereUniqueInput
  ) => MailgunEmailPayloadNullablePromise;
  mailgunEmailPayloads: (args?: {
    where?: MailgunEmailPayloadWhereInput;
    orderBy?: MailgunEmailPayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MailgunEmailPayload>;
  mailgunEmailPayloadsConnection: (args?: {
    where?: MailgunEmailPayloadWhereInput;
    orderBy?: MailgunEmailPayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MailgunEmailPayloadConnectionPromise;
  membership: (where: MembershipWhereUniqueInput) => MembershipNullablePromise;
  memberships: (args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Membership>;
  membershipsConnection: (args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MembershipConnectionPromise;
  participant: (
    where: ParticipantWhereUniqueInput
  ) => ParticipantNullablePromise;
  participants: (args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Participant>;
  participantsConnection: (args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ParticipantConnectionPromise;
  payment: (where: PaymentWhereUniqueInput) => PaymentNullablePromise;
  payments: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Payment>;
  paymentsConnection: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaymentConnectionPromise;
  room: (where: RoomWhereUniqueInput) => RoomNullablePromise;
  rooms: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Room>;
  roomsConnection: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoomConnectionPromise;
  student: (where: StudentWhereUniqueInput) => StudentNullablePromise;
  students: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Student>;
  studentsConnection: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudentConnectionPromise;
  studio: (where: StudioWhereUniqueInput) => StudioNullablePromise;
  studios: (args?: {
    where?: StudioWhereInput;
    orderBy?: StudioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Studio>;
  studiosConnection: (args?: {
    where?: StudioWhereInput;
    orderBy?: StudioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudioConnectionPromise;
  teacher: (where: TeacherWhereUniqueInput) => TeacherNullablePromise;
  teachers: (args?: {
    where?: TeacherWhereInput;
    orderBy?: TeacherOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Teacher>;
  teachersConnection: (args?: {
    where?: TeacherWhereInput;
    orderBy?: TeacherOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TeacherConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCard: (data: CardCreateInput) => CardPromise;
  updateCard: (args: {
    data: CardUpdateInput;
    where: CardWhereUniqueInput;
  }) => CardPromise;
  updateManyCards: (args: {
    data: CardUpdateManyMutationInput;
    where?: CardWhereInput;
  }) => BatchPayloadPromise;
  upsertCard: (args: {
    where: CardWhereUniqueInput;
    create: CardCreateInput;
    update: CardUpdateInput;
  }) => CardPromise;
  deleteCard: (where: CardWhereUniqueInput) => CardPromise;
  deleteManyCards: (where?: CardWhereInput) => BatchPayloadPromise;
  createCourse: (data: CourseCreateInput) => CoursePromise;
  updateCourse: (args: {
    data: CourseUpdateInput;
    where: CourseWhereUniqueInput;
  }) => CoursePromise;
  updateManyCourses: (args: {
    data: CourseUpdateManyMutationInput;
    where?: CourseWhereInput;
  }) => BatchPayloadPromise;
  upsertCourse: (args: {
    where: CourseWhereUniqueInput;
    create: CourseCreateInput;
    update: CourseUpdateInput;
  }) => CoursePromise;
  deleteCourse: (where: CourseWhereUniqueInput) => CoursePromise;
  deleteManyCourses: (where?: CourseWhereInput) => BatchPayloadPromise;
  createCourseAbsence: (data: CourseAbsenceCreateInput) => CourseAbsencePromise;
  updateCourseAbsence: (args: {
    data: CourseAbsenceUpdateInput;
    where: CourseAbsenceWhereUniqueInput;
  }) => CourseAbsencePromise;
  updateManyCourseAbsences: (args: {
    data: CourseAbsenceUpdateManyMutationInput;
    where?: CourseAbsenceWhereInput;
  }) => BatchPayloadPromise;
  upsertCourseAbsence: (args: {
    where: CourseAbsenceWhereUniqueInput;
    create: CourseAbsenceCreateInput;
    update: CourseAbsenceUpdateInput;
  }) => CourseAbsencePromise;
  deleteCourseAbsence: (
    where: CourseAbsenceWhereUniqueInput
  ) => CourseAbsencePromise;
  deleteManyCourseAbsences: (
    where?: CourseAbsenceWhereInput
  ) => BatchPayloadPromise;
  createCourseInstance: (
    data: CourseInstanceCreateInput
  ) => CourseInstancePromise;
  updateCourseInstance: (args: {
    data: CourseInstanceUpdateInput;
    where: CourseInstanceWhereUniqueInput;
  }) => CourseInstancePromise;
  updateManyCourseInstances: (args: {
    data: CourseInstanceUpdateManyMutationInput;
    where?: CourseInstanceWhereInput;
  }) => BatchPayloadPromise;
  upsertCourseInstance: (args: {
    where: CourseInstanceWhereUniqueInput;
    create: CourseInstanceCreateInput;
    update: CourseInstanceUpdateInput;
  }) => CourseInstancePromise;
  deleteCourseInstance: (
    where: CourseInstanceWhereUniqueInput
  ) => CourseInstancePromise;
  deleteManyCourseInstances: (
    where?: CourseInstanceWhereInput
  ) => BatchPayloadPromise;
  createExpense: (data: ExpenseCreateInput) => ExpensePromise;
  updateExpense: (args: {
    data: ExpenseUpdateInput;
    where: ExpenseWhereUniqueInput;
  }) => ExpensePromise;
  updateManyExpenses: (args: {
    data: ExpenseUpdateManyMutationInput;
    where?: ExpenseWhereInput;
  }) => BatchPayloadPromise;
  upsertExpense: (args: {
    where: ExpenseWhereUniqueInput;
    create: ExpenseCreateInput;
    update: ExpenseUpdateInput;
  }) => ExpensePromise;
  deleteExpense: (where: ExpenseWhereUniqueInput) => ExpensePromise;
  deleteManyExpenses: (where?: ExpenseWhereInput) => BatchPayloadPromise;
  createLoginResponse: (data: LoginResponseCreateInput) => LoginResponsePromise;
  updateLoginResponse: (args: {
    data: LoginResponseUpdateInput;
    where: LoginResponseWhereUniqueInput;
  }) => LoginResponsePromise;
  updateManyLoginResponses: (args: {
    data: LoginResponseUpdateManyMutationInput;
    where?: LoginResponseWhereInput;
  }) => BatchPayloadPromise;
  upsertLoginResponse: (args: {
    where: LoginResponseWhereUniqueInput;
    create: LoginResponseCreateInput;
    update: LoginResponseUpdateInput;
  }) => LoginResponsePromise;
  deleteLoginResponse: (
    where: LoginResponseWhereUniqueInput
  ) => LoginResponsePromise;
  deleteManyLoginResponses: (
    where?: LoginResponseWhereInput
  ) => BatchPayloadPromise;
  createMailgunEmailPayload: (
    data: MailgunEmailPayloadCreateInput
  ) => MailgunEmailPayloadPromise;
  updateMailgunEmailPayload: (args: {
    data: MailgunEmailPayloadUpdateInput;
    where: MailgunEmailPayloadWhereUniqueInput;
  }) => MailgunEmailPayloadPromise;
  updateManyMailgunEmailPayloads: (args: {
    data: MailgunEmailPayloadUpdateManyMutationInput;
    where?: MailgunEmailPayloadWhereInput;
  }) => BatchPayloadPromise;
  upsertMailgunEmailPayload: (args: {
    where: MailgunEmailPayloadWhereUniqueInput;
    create: MailgunEmailPayloadCreateInput;
    update: MailgunEmailPayloadUpdateInput;
  }) => MailgunEmailPayloadPromise;
  deleteMailgunEmailPayload: (
    where: MailgunEmailPayloadWhereUniqueInput
  ) => MailgunEmailPayloadPromise;
  deleteManyMailgunEmailPayloads: (
    where?: MailgunEmailPayloadWhereInput
  ) => BatchPayloadPromise;
  createMembership: (data: MembershipCreateInput) => MembershipPromise;
  updateMembership: (args: {
    data: MembershipUpdateInput;
    where: MembershipWhereUniqueInput;
  }) => MembershipPromise;
  updateManyMemberships: (args: {
    data: MembershipUpdateManyMutationInput;
    where?: MembershipWhereInput;
  }) => BatchPayloadPromise;
  upsertMembership: (args: {
    where: MembershipWhereUniqueInput;
    create: MembershipCreateInput;
    update: MembershipUpdateInput;
  }) => MembershipPromise;
  deleteMembership: (where: MembershipWhereUniqueInput) => MembershipPromise;
  deleteManyMemberships: (where?: MembershipWhereInput) => BatchPayloadPromise;
  createParticipant: (data: ParticipantCreateInput) => ParticipantPromise;
  updateParticipant: (args: {
    data: ParticipantUpdateInput;
    where: ParticipantWhereUniqueInput;
  }) => ParticipantPromise;
  updateManyParticipants: (args: {
    data: ParticipantUpdateManyMutationInput;
    where?: ParticipantWhereInput;
  }) => BatchPayloadPromise;
  upsertParticipant: (args: {
    where: ParticipantWhereUniqueInput;
    create: ParticipantCreateInput;
    update: ParticipantUpdateInput;
  }) => ParticipantPromise;
  deleteParticipant: (where: ParticipantWhereUniqueInput) => ParticipantPromise;
  deleteManyParticipants: (
    where?: ParticipantWhereInput
  ) => BatchPayloadPromise;
  createPayment: (data: PaymentCreateInput) => PaymentPromise;
  updatePayment: (args: {
    data: PaymentUpdateInput;
    where: PaymentWhereUniqueInput;
  }) => PaymentPromise;
  updateManyPayments: (args: {
    data: PaymentUpdateManyMutationInput;
    where?: PaymentWhereInput;
  }) => BatchPayloadPromise;
  upsertPayment: (args: {
    where: PaymentWhereUniqueInput;
    create: PaymentCreateInput;
    update: PaymentUpdateInput;
  }) => PaymentPromise;
  deletePayment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayloadPromise;
  createRoom: (data: RoomCreateInput) => RoomPromise;
  updateRoom: (args: {
    data: RoomUpdateInput;
    where: RoomWhereUniqueInput;
  }) => RoomPromise;
  updateManyRooms: (args: {
    data: RoomUpdateManyMutationInput;
    where?: RoomWhereInput;
  }) => BatchPayloadPromise;
  upsertRoom: (args: {
    where: RoomWhereUniqueInput;
    create: RoomCreateInput;
    update: RoomUpdateInput;
  }) => RoomPromise;
  deleteRoom: (where: RoomWhereUniqueInput) => RoomPromise;
  deleteManyRooms: (where?: RoomWhereInput) => BatchPayloadPromise;
  createStudent: (data: StudentCreateInput) => StudentPromise;
  updateStudent: (args: {
    data: StudentUpdateInput;
    where: StudentWhereUniqueInput;
  }) => StudentPromise;
  updateManyStudents: (args: {
    data: StudentUpdateManyMutationInput;
    where?: StudentWhereInput;
  }) => BatchPayloadPromise;
  upsertStudent: (args: {
    where: StudentWhereUniqueInput;
    create: StudentCreateInput;
    update: StudentUpdateInput;
  }) => StudentPromise;
  deleteStudent: (where: StudentWhereUniqueInput) => StudentPromise;
  deleteManyStudents: (where?: StudentWhereInput) => BatchPayloadPromise;
  createStudio: (data: StudioCreateInput) => StudioPromise;
  updateStudio: (args: {
    data: StudioUpdateInput;
    where: StudioWhereUniqueInput;
  }) => StudioPromise;
  updateManyStudios: (args: {
    data: StudioUpdateManyMutationInput;
    where?: StudioWhereInput;
  }) => BatchPayloadPromise;
  upsertStudio: (args: {
    where: StudioWhereUniqueInput;
    create: StudioCreateInput;
    update: StudioUpdateInput;
  }) => StudioPromise;
  deleteStudio: (where: StudioWhereUniqueInput) => StudioPromise;
  deleteManyStudios: (where?: StudioWhereInput) => BatchPayloadPromise;
  createTeacher: (data: TeacherCreateInput) => TeacherPromise;
  updateTeacher: (args: {
    data: TeacherUpdateInput;
    where: TeacherWhereUniqueInput;
  }) => TeacherPromise;
  updateManyTeachers: (args: {
    data: TeacherUpdateManyMutationInput;
    where?: TeacherWhereInput;
  }) => BatchPayloadPromise;
  upsertTeacher: (args: {
    where: TeacherWhereUniqueInput;
    create: TeacherCreateInput;
    update: TeacherUpdateInput;
  }) => TeacherPromise;
  deleteTeacher: (where: TeacherWhereUniqueInput) => TeacherPromise;
  deleteManyTeachers: (where?: TeacherWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  card: (
    where?: CardSubscriptionWhereInput
  ) => CardSubscriptionPayloadSubscription;
  course: (
    where?: CourseSubscriptionWhereInput
  ) => CourseSubscriptionPayloadSubscription;
  courseAbsence: (
    where?: CourseAbsenceSubscriptionWhereInput
  ) => CourseAbsenceSubscriptionPayloadSubscription;
  courseInstance: (
    where?: CourseInstanceSubscriptionWhereInput
  ) => CourseInstanceSubscriptionPayloadSubscription;
  expense: (
    where?: ExpenseSubscriptionWhereInput
  ) => ExpenseSubscriptionPayloadSubscription;
  loginResponse: (
    where?: LoginResponseSubscriptionWhereInput
  ) => LoginResponseSubscriptionPayloadSubscription;
  mailgunEmailPayload: (
    where?: MailgunEmailPayloadSubscriptionWhereInput
  ) => MailgunEmailPayloadSubscriptionPayloadSubscription;
  membership: (
    where?: MembershipSubscriptionWhereInput
  ) => MembershipSubscriptionPayloadSubscription;
  participant: (
    where?: ParticipantSubscriptionWhereInput
  ) => ParticipantSubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
  room: (
    where?: RoomSubscriptionWhereInput
  ) => RoomSubscriptionPayloadSubscription;
  student: (
    where?: StudentSubscriptionWhereInput
  ) => StudentSubscriptionPayloadSubscription;
  studio: (
    where?: StudioSubscriptionWhereInput
  ) => StudioSubscriptionPayloadSubscription;
  teacher: (
    where?: TeacherSubscriptionWhereInput
  ) => TeacherSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CardOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "expirationDate_ASC"
  | "expirationDate_DESC"
  | "active_ASC"
  | "active_DESC"
  | "paid_ASC"
  | "paid_DESC"
  | "value_ASC"
  | "value_DESC"
  | "originalValue_ASC"
  | "originalValue_DESC"
  | "privateLessonLength_ASC"
  | "privateLessonLength_DESC"
  | "privateLessonUseDate_ASC"
  | "privateLessonUseDate_DESC";

export type DanceRole = "LEADER" | "FOLLOWER" | "SOLO";

export type CourseAbsenceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "date_ASC"
  | "date_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "admin_ASC"
  | "admin_DESC";

export type RoomOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "capacity_ASC"
  | "capacity_DESC";

export type StudentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "mobile_ASC"
  | "mobile_DESC"
  | "hasReferralBonus_ASC"
  | "hasReferralBonus_DESC";

export type ParticipantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "status_ASC"
  | "status_DESC";

export type LoginResponseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "token_ASC"
  | "token_DESC";

export type CourseDay = "MON" | "TUE" | "WED" | "THU" | "FRI" | "SAT" | "SUN";

export type ExpenseType = "RENT" | "MISC";

export type CourseInstanceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "date_ASC"
  | "date_DESC"
  | "topic_ASC"
  | "topic_DESC"
  | "notes_ASC"
  | "notes_DESC"
  | "recapUrl_ASC"
  | "recapUrl_DESC"
  | "isCancelled_ASC"
  | "isCancelled_DESC";

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "date_ASC"
  | "date_DESC"
  | "amount_ASC"
  | "amount_DESC";

export type CourseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "day_ASC"
  | "day_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "studentLimit_ASC"
  | "studentLimit_DESC";

export type StudioOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC";

export type ParticipantStatus = "PRESENT" | "ABSENT" | "NOT_LOGGED" | "NO_SHOW";

export type MembershipStatus = "ACTIVE" | "INACTIVE" | "WAITLIST";

export type MembershipOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "role_ASC"
  | "role_DESC"
  | "status_ASC"
  | "status_DESC"
  | "waitlistDate_ASC"
  | "waitlistDate_DESC";

export type TeacherOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "mobile_ASC"
  | "mobile_DESC";

export type MailgunEmailPayloadOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "success_ASC"
  | "success_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PaymentType = "CARD" | "PRIVATE" | "DROP_IN" | "OLD_CARD";

export type ExpenseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "date_ASC"
  | "date_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "note_ASC"
  | "note_DESC";

export interface UserUpdateOneWithoutStudentInput {
  create?: Maybe<UserCreateWithoutStudentInput>;
  update?: Maybe<UserUpdateWithoutStudentDataInput>;
  upsert?: Maybe<UserUpsertWithoutStudentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type CardWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PaymentUpdateManyWithoutStudentInput {
  create?: Maybe<
    PaymentCreateWithoutStudentInput[] | PaymentCreateWithoutStudentInput
  >;
  delete?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  set?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  disconnect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  update?: Maybe<
    | PaymentUpdateWithWhereUniqueWithoutStudentInput[]
    | PaymentUpdateWithWhereUniqueWithoutStudentInput
  >;
  upsert?: Maybe<
    | PaymentUpsertWithWhereUniqueWithoutStudentInput[]
    | PaymentUpsertWithWhereUniqueWithoutStudentInput
  >;
  deleteMany?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  updateMany?: Maybe<
    | PaymentUpdateManyWithWhereNestedInput[]
    | PaymentUpdateManyWithWhereNestedInput
  >;
}

export interface CourseAbsenceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  student?: Maybe<StudentWhereInput>;
  course?: Maybe<CourseWhereInput>;
  AND?: Maybe<CourseAbsenceWhereInput[] | CourseAbsenceWhereInput>;
  OR?: Maybe<CourseAbsenceWhereInput[] | CourseAbsenceWhereInput>;
  NOT?: Maybe<CourseAbsenceWhereInput[] | CourseAbsenceWhereInput>;
}

export interface MembershipCreateWithoutCourseInput {
  id?: Maybe<ID_Input>;
  student: StudentCreateOneWithoutMembershipsInput;
  role: DanceRole;
  status?: Maybe<MembershipStatus>;
  waitlistDate?: Maybe<DateTimeInput>;
}

export interface CourseUpdateWithoutAbsencesDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startTime?: Maybe<String>;
  day?: Maybe<CourseDay>;
  duration?: Maybe<Int>;
  teachers?: Maybe<TeacherUpdateManyWithoutCoursesInput>;
  memberships?: Maybe<MembershipUpdateManyWithoutCourseInput>;
  instances?: Maybe<CourseInstanceUpdateManyWithoutCourseInput>;
  studentLimit?: Maybe<Int>;
  room?: Maybe<RoomUpdateOneInput>;
}

export interface RoomCreateOneInput {
  create?: Maybe<RoomCreateInput>;
  connect?: Maybe<RoomWhereUniqueInput>;
}

export interface PaymentUpdateWithWhereUniqueWithoutStudentInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutStudentDataInput;
}

export interface RoomCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  capacity?: Maybe<Int>;
  studio: StudioCreateOneWithoutRoomsInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface StudioCreateOneWithoutRoomsInput {
  create?: Maybe<StudioCreateWithoutRoomsInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface TeacherSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TeacherWhereInput>;
  AND?: Maybe<TeacherSubscriptionWhereInput[] | TeacherSubscriptionWhereInput>;
  OR?: Maybe<TeacherSubscriptionWhereInput[] | TeacherSubscriptionWhereInput>;
  NOT?: Maybe<TeacherSubscriptionWhereInput[] | TeacherSubscriptionWhereInput>;
}

export interface StudioCreateWithoutRoomsInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  address?: Maybe<String>;
}

export interface StudioSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StudioWhereInput>;
  AND?: Maybe<StudioSubscriptionWhereInput[] | StudioSubscriptionWhereInput>;
  OR?: Maybe<StudioSubscriptionWhereInput[] | StudioSubscriptionWhereInput>;
  NOT?: Maybe<StudioSubscriptionWhereInput[] | StudioSubscriptionWhereInput>;
}

export interface CourseAbsenceCreateManyWithoutCourseInput {
  create?: Maybe<
    | CourseAbsenceCreateWithoutCourseInput[]
    | CourseAbsenceCreateWithoutCourseInput
  >;
  connect?: Maybe<
    CourseAbsenceWhereUniqueInput[] | CourseAbsenceWhereUniqueInput
  >;
}

export interface StudentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StudentWhereInput>;
  AND?: Maybe<StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput>;
  OR?: Maybe<StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput>;
  NOT?: Maybe<StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput>;
}

export interface CourseAbsenceCreateWithoutCourseInput {
  id?: Maybe<ID_Input>;
  date: DateTimeInput;
  student: StudentCreateOneInput;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PaymentWhereInput>;
  AND?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
  OR?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
  NOT?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
}

export interface StudentCreateOneInput {
  create?: Maybe<StudentCreateInput>;
  connect?: Maybe<StudentWhereUniqueInput>;
}

export interface ParticipantWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  membership?: Maybe<MembershipWhereInput>;
  courseInstance?: Maybe<CourseInstanceWhereInput>;
  status?: Maybe<ParticipantStatus>;
  status_not?: Maybe<ParticipantStatus>;
  status_in?: Maybe<ParticipantStatus[] | ParticipantStatus>;
  status_not_in?: Maybe<ParticipantStatus[] | ParticipantStatus>;
  AND?: Maybe<ParticipantWhereInput[] | ParticipantWhereInput>;
  OR?: Maybe<ParticipantWhereInput[] | ParticipantWhereInput>;
  NOT?: Maybe<ParticipantWhereInput[] | ParticipantWhereInput>;
}

export interface StudentCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  mobile?: Maybe<String>;
  memberships?: Maybe<MembershipCreateManyWithoutStudentInput>;
  cards?: Maybe<CardCreateManyWithoutStudentInput>;
  hasReferralBonus?: Maybe<Boolean>;
  payments?: Maybe<PaymentCreateManyWithoutStudentInput>;
  user?: Maybe<UserCreateOneWithoutStudentInput>;
}

export interface MembershipSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MembershipWhereInput>;
  AND?: Maybe<
    MembershipSubscriptionWhereInput[] | MembershipSubscriptionWhereInput
  >;
  OR?: Maybe<
    MembershipSubscriptionWhereInput[] | MembershipSubscriptionWhereInput
  >;
  NOT?: Maybe<
    MembershipSubscriptionWhereInput[] | MembershipSubscriptionWhereInput
  >;
}

export interface CourseInstanceCreateManyWithoutCourseInput {
  create?: Maybe<
    | CourseInstanceCreateWithoutCourseInput[]
    | CourseInstanceCreateWithoutCourseInput
  >;
  connect?: Maybe<
    CourseInstanceWhereUniqueInput[] | CourseInstanceWhereUniqueInput
  >;
}

export interface LoginResponseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LoginResponseWhereInput>;
  AND?: Maybe<
    LoginResponseSubscriptionWhereInput[] | LoginResponseSubscriptionWhereInput
  >;
  OR?: Maybe<
    LoginResponseSubscriptionWhereInput[] | LoginResponseSubscriptionWhereInput
  >;
  NOT?: Maybe<
    LoginResponseSubscriptionWhereInput[] | LoginResponseSubscriptionWhereInput
  >;
}

export interface CourseInstanceCreateWithoutCourseInput {
  id?: Maybe<ID_Input>;
  date: DateTimeInput;
  topic?: Maybe<String>;
  notes?: Maybe<String>;
  participants?: Maybe<ParticipantCreateManyWithoutCourseInstanceInput>;
  recapUrl?: Maybe<String>;
  isCancelled?: Maybe<Boolean>;
}

export interface CourseInstanceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CourseInstanceWhereInput>;
  AND?: Maybe<
    | CourseInstanceSubscriptionWhereInput[]
    | CourseInstanceSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CourseInstanceSubscriptionWhereInput[]
    | CourseInstanceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CourseInstanceSubscriptionWhereInput[]
    | CourseInstanceSubscriptionWhereInput
  >;
}

export interface ParticipantCreateManyWithoutCourseInstanceInput {
  create?: Maybe<
    | ParticipantCreateWithoutCourseInstanceInput[]
    | ParticipantCreateWithoutCourseInstanceInput
  >;
  connect?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
}

export interface CourseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CourseWhereInput>;
  AND?: Maybe<CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput>;
  OR?: Maybe<CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput>;
  NOT?: Maybe<CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput>;
}

export interface ParticipantCreateWithoutCourseInstanceInput {
  id?: Maybe<ID_Input>;
  membership: MembershipCreateOneInput;
  status?: Maybe<ParticipantStatus>;
}

export interface CardSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CardWhereInput>;
  AND?: Maybe<CardSubscriptionWhereInput[] | CardSubscriptionWhereInput>;
  OR?: Maybe<CardSubscriptionWhereInput[] | CardSubscriptionWhereInput>;
  NOT?: Maybe<CardSubscriptionWhereInput[] | CardSubscriptionWhereInput>;
}

export interface CardUpdateInput {
  student?: Maybe<StudentUpdateOneRequiredWithoutCardsInput>;
  payment?: Maybe<PaymentUpdateOneWithoutCardInput>;
  expirationDate?: Maybe<DateTimeInput>;
  active?: Maybe<Boolean>;
  paid?: Maybe<Boolean>;
  value?: Maybe<Int>;
  originalValue?: Maybe<Int>;
  participationHistory?: Maybe<ParticipantUpdateManyInput>;
  privateLessonLength?: Maybe<Int>;
  privateLessonUseDate?: Maybe<DateTimeInput>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  student?: Maybe<StudentUpdateOneWithoutUserInput>;
  admin?: Maybe<Boolean>;
}

export interface StudentUpdateOneRequiredWithoutCardsInput {
  create?: Maybe<StudentCreateWithoutCardsInput>;
  update?: Maybe<StudentUpdateWithoutCardsDataInput>;
  upsert?: Maybe<StudentUpsertWithoutCardsInput>;
  connect?: Maybe<StudentWhereUniqueInput>;
}

export interface TeacherUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  mobile?: Maybe<String>;
}

export interface StudentUpdateWithoutCardsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  mobile?: Maybe<String>;
  memberships?: Maybe<MembershipUpdateManyWithoutStudentInput>;
  hasReferralBonus?: Maybe<Boolean>;
  payments?: Maybe<PaymentUpdateManyWithoutStudentInput>;
  user?: Maybe<UserUpdateOneWithoutStudentInput>;
}

export interface CourseUpdateManyWithWhereNestedInput {
  where: CourseScalarWhereInput;
  data: CourseUpdateManyDataInput;
}

export interface MembershipUpdateManyWithoutStudentInput {
  create?: Maybe<
    MembershipCreateWithoutStudentInput[] | MembershipCreateWithoutStudentInput
  >;
  delete?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  connect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  set?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  disconnect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  update?: Maybe<
    | MembershipUpdateWithWhereUniqueWithoutStudentInput[]
    | MembershipUpdateWithWhereUniqueWithoutStudentInput
  >;
  upsert?: Maybe<
    | MembershipUpsertWithWhereUniqueWithoutStudentInput[]
    | MembershipUpsertWithWhereUniqueWithoutStudentInput
  >;
  deleteMany?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
  updateMany?: Maybe<
    | MembershipUpdateManyWithWhereNestedInput[]
    | MembershipUpdateManyWithWhereNestedInput
  >;
}

export interface CourseScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  day?: Maybe<CourseDay>;
  day_not?: Maybe<CourseDay>;
  day_in?: Maybe<CourseDay[] | CourseDay>;
  day_not_in?: Maybe<CourseDay[] | CourseDay>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  studentLimit?: Maybe<Int>;
  studentLimit_not?: Maybe<Int>;
  studentLimit_in?: Maybe<Int[] | Int>;
  studentLimit_not_in?: Maybe<Int[] | Int>;
  studentLimit_lt?: Maybe<Int>;
  studentLimit_lte?: Maybe<Int>;
  studentLimit_gt?: Maybe<Int>;
  studentLimit_gte?: Maybe<Int>;
  AND?: Maybe<CourseScalarWhereInput[] | CourseScalarWhereInput>;
  OR?: Maybe<CourseScalarWhereInput[] | CourseScalarWhereInput>;
  NOT?: Maybe<CourseScalarWhereInput[] | CourseScalarWhereInput>;
}

export interface MembershipUpdateWithWhereUniqueWithoutStudentInput {
  where: MembershipWhereUniqueInput;
  data: MembershipUpdateWithoutStudentDataInput;
}

export interface CourseUpdateWithoutTeachersDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startTime?: Maybe<String>;
  day?: Maybe<CourseDay>;
  duration?: Maybe<Int>;
  memberships?: Maybe<MembershipUpdateManyWithoutCourseInput>;
  instances?: Maybe<CourseInstanceUpdateManyWithoutCourseInput>;
  studentLimit?: Maybe<Int>;
  room?: Maybe<RoomUpdateOneInput>;
  absences?: Maybe<CourseAbsenceUpdateManyWithoutCourseInput>;
}

export interface MembershipUpdateWithoutStudentDataInput {
  course?: Maybe<CourseUpdateOneRequiredWithoutMembershipsInput>;
  role?: Maybe<DanceRole>;
  status?: Maybe<MembershipStatus>;
  waitlistDate?: Maybe<DateTimeInput>;
}

export interface CourseUpdateWithWhereUniqueWithoutTeachersInput {
  where: CourseWhereUniqueInput;
  data: CourseUpdateWithoutTeachersDataInput;
}

export interface CourseUpdateOneRequiredWithoutMembershipsInput {
  create?: Maybe<CourseCreateWithoutMembershipsInput>;
  update?: Maybe<CourseUpdateWithoutMembershipsDataInput>;
  upsert?: Maybe<CourseUpsertWithoutMembershipsInput>;
  connect?: Maybe<CourseWhereUniqueInput>;
}

export interface ExpenseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<ExpenseType>;
  type_not?: Maybe<ExpenseType>;
  type_in?: Maybe<ExpenseType[] | ExpenseType>;
  type_not_in?: Maybe<ExpenseType[] | ExpenseType>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  AND?: Maybe<ExpenseWhereInput[] | ExpenseWhereInput>;
  OR?: Maybe<ExpenseWhereInput[] | ExpenseWhereInput>;
  NOT?: Maybe<ExpenseWhereInput[] | ExpenseWhereInput>;
}

export interface CourseUpdateWithoutMembershipsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startTime?: Maybe<String>;
  day?: Maybe<CourseDay>;
  duration?: Maybe<Int>;
  teachers?: Maybe<TeacherUpdateManyWithoutCoursesInput>;
  instances?: Maybe<CourseInstanceUpdateManyWithoutCourseInput>;
  studentLimit?: Maybe<Int>;
  room?: Maybe<RoomUpdateOneInput>;
  absences?: Maybe<CourseAbsenceUpdateManyWithoutCourseInput>;
}

export interface CourseUpdateManyWithoutTeachersInput {
  create?: Maybe<
    CourseCreateWithoutTeachersInput[] | CourseCreateWithoutTeachersInput
  >;
  delete?: Maybe<CourseWhereUniqueInput[] | CourseWhereUniqueInput>;
  connect?: Maybe<CourseWhereUniqueInput[] | CourseWhereUniqueInput>;
  set?: Maybe<CourseWhereUniqueInput[] | CourseWhereUniqueInput>;
  disconnect?: Maybe<CourseWhereUniqueInput[] | CourseWhereUniqueInput>;
  update?: Maybe<
    | CourseUpdateWithWhereUniqueWithoutTeachersInput[]
    | CourseUpdateWithWhereUniqueWithoutTeachersInput
  >;
  upsert?: Maybe<
    | CourseUpsertWithWhereUniqueWithoutTeachersInput[]
    | CourseUpsertWithWhereUniqueWithoutTeachersInput
  >;
  deleteMany?: Maybe<CourseScalarWhereInput[] | CourseScalarWhereInput>;
  updateMany?: Maybe<
    | CourseUpdateManyWithWhereNestedInput[]
    | CourseUpdateManyWithWhereNestedInput
  >;
}

export interface TeacherUpdateManyWithoutCoursesInput {
  create?: Maybe<
    TeacherCreateWithoutCoursesInput[] | TeacherCreateWithoutCoursesInput
  >;
  delete?: Maybe<TeacherWhereUniqueInput[] | TeacherWhereUniqueInput>;
  connect?: Maybe<TeacherWhereUniqueInput[] | TeacherWhereUniqueInput>;
  set?: Maybe<TeacherWhereUniqueInput[] | TeacherWhereUniqueInput>;
  disconnect?: Maybe<TeacherWhereUniqueInput[] | TeacherWhereUniqueInput>;
  update?: Maybe<
    | TeacherUpdateWithWhereUniqueWithoutCoursesInput[]
    | TeacherUpdateWithWhereUniqueWithoutCoursesInput
  >;
  upsert?: Maybe<
    | TeacherUpsertWithWhereUniqueWithoutCoursesInput[]
    | TeacherUpsertWithWhereUniqueWithoutCoursesInput
  >;
  deleteMany?: Maybe<TeacherScalarWhereInput[] | TeacherScalarWhereInput>;
  updateMany?: Maybe<
    | TeacherUpdateManyWithWhereNestedInput[]
    | TeacherUpdateManyWithWhereNestedInput
  >;
}

export interface CourseCreateWithoutTeachersInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startTime?: Maybe<String>;
  day?: Maybe<CourseDay>;
  duration?: Maybe<Int>;
  memberships?: Maybe<MembershipCreateManyWithoutCourseInput>;
  instances?: Maybe<CourseInstanceCreateManyWithoutCourseInput>;
  studentLimit?: Maybe<Int>;
  room?: Maybe<RoomCreateOneInput>;
  absences?: Maybe<CourseAbsenceCreateManyWithoutCourseInput>;
}

export interface TeacherUpdateWithWhereUniqueWithoutCoursesInput {
  where: TeacherWhereUniqueInput;
  data: TeacherUpdateWithoutCoursesDataInput;
}

export interface CourseCreateManyWithoutTeachersInput {
  create?: Maybe<
    CourseCreateWithoutTeachersInput[] | CourseCreateWithoutTeachersInput
  >;
  connect?: Maybe<CourseWhereUniqueInput[] | CourseWhereUniqueInput>;
}

export interface TeacherUpdateWithoutCoursesDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  mobile?: Maybe<String>;
  user?: Maybe<UserUpdateOneInput>;
}

export interface StudentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  memberships_every?: Maybe<MembershipWhereInput>;
  memberships_some?: Maybe<MembershipWhereInput>;
  memberships_none?: Maybe<MembershipWhereInput>;
  cards_every?: Maybe<CardWhereInput>;
  cards_some?: Maybe<CardWhereInput>;
  cards_none?: Maybe<CardWhereInput>;
  hasReferralBonus?: Maybe<Boolean>;
  hasReferralBonus_not?: Maybe<Boolean>;
  payments_every?: Maybe<PaymentWhereInput>;
  payments_some?: Maybe<PaymentWhereInput>;
  payments_none?: Maybe<PaymentWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<StudentWhereInput[] | StudentWhereInput>;
  OR?: Maybe<StudentWhereInput[] | StudentWhereInput>;
  NOT?: Maybe<StudentWhereInput[] | StudentWhereInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface StudioUpdateManyMutationInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
}

export interface UserUpdateDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  student?: Maybe<StudentUpdateOneWithoutUserInput>;
  admin?: Maybe<Boolean>;
}

export type MailgunEmailPayloadWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface StudentUpdateOneWithoutUserInput {
  create?: Maybe<StudentCreateWithoutUserInput>;
  update?: Maybe<StudentUpdateWithoutUserDataInput>;
  upsert?: Maybe<StudentUpsertWithoutUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<StudentWhereUniqueInput>;
}

export interface MailgunEmailPayloadWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  success?: Maybe<Boolean>;
  success_not?: Maybe<Boolean>;
  AND?: Maybe<MailgunEmailPayloadWhereInput[] | MailgunEmailPayloadWhereInput>;
  OR?: Maybe<MailgunEmailPayloadWhereInput[] | MailgunEmailPayloadWhereInput>;
  NOT?: Maybe<MailgunEmailPayloadWhereInput[] | MailgunEmailPayloadWhereInput>;
}

export interface StudentUpdateWithoutUserDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  mobile?: Maybe<String>;
  memberships?: Maybe<MembershipUpdateManyWithoutStudentInput>;
  cards?: Maybe<CardUpdateManyWithoutStudentInput>;
  hasReferralBonus?: Maybe<Boolean>;
  payments?: Maybe<PaymentUpdateManyWithoutStudentInput>;
}

export interface RoomScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  capacity?: Maybe<Int>;
  capacity_not?: Maybe<Int>;
  capacity_in?: Maybe<Int[] | Int>;
  capacity_not_in?: Maybe<Int[] | Int>;
  capacity_lt?: Maybe<Int>;
  capacity_lte?: Maybe<Int>;
  capacity_gt?: Maybe<Int>;
  capacity_gte?: Maybe<Int>;
  AND?: Maybe<RoomScalarWhereInput[] | RoomScalarWhereInput>;
  OR?: Maybe<RoomScalarWhereInput[] | RoomScalarWhereInput>;
  NOT?: Maybe<RoomScalarWhereInput[] | RoomScalarWhereInput>;
}

export interface CardUpdateManyWithoutStudentInput {
  create?: Maybe<
    CardCreateWithoutStudentInput[] | CardCreateWithoutStudentInput
  >;
  delete?: Maybe<CardWhereUniqueInput[] | CardWhereUniqueInput>;
  connect?: Maybe<CardWhereUniqueInput[] | CardWhereUniqueInput>;
  set?: Maybe<CardWhereUniqueInput[] | CardWhereUniqueInput>;
  disconnect?: Maybe<CardWhereUniqueInput[] | CardWhereUniqueInput>;
  update?: Maybe<
    | CardUpdateWithWhereUniqueWithoutStudentInput[]
    | CardUpdateWithWhereUniqueWithoutStudentInput
  >;
  upsert?: Maybe<
    | CardUpsertWithWhereUniqueWithoutStudentInput[]
    | CardUpsertWithWhereUniqueWithoutStudentInput
  >;
  deleteMany?: Maybe<CardScalarWhereInput[] | CardScalarWhereInput>;
  updateMany?: Maybe<
    CardUpdateManyWithWhereNestedInput[] | CardUpdateManyWithWhereNestedInput
  >;
}

export interface RoomUpdateWithoutStudioDataInput {
  name?: Maybe<String>;
  capacity?: Maybe<Int>;
}

export interface CardUpdateWithWhereUniqueWithoutStudentInput {
  where: CardWhereUniqueInput;
  data: CardUpdateWithoutStudentDataInput;
}

export interface RoomUpdateWithWhereUniqueWithoutStudioInput {
  where: RoomWhereUniqueInput;
  data: RoomUpdateWithoutStudioDataInput;
}

export interface CardUpdateWithoutStudentDataInput {
  payment?: Maybe<PaymentUpdateOneWithoutCardInput>;
  expirationDate?: Maybe<DateTimeInput>;
  active?: Maybe<Boolean>;
  paid?: Maybe<Boolean>;
  value?: Maybe<Int>;
  originalValue?: Maybe<Int>;
  participationHistory?: Maybe<ParticipantUpdateManyInput>;
  privateLessonLength?: Maybe<Int>;
  privateLessonUseDate?: Maybe<DateTimeInput>;
}

export interface StudioUpdateInput {
  name?: Maybe<String>;
  rooms?: Maybe<RoomUpdateManyWithoutStudioInput>;
  address?: Maybe<String>;
}

export interface PaymentUpdateOneWithoutCardInput {
  create?: Maybe<PaymentCreateWithoutCardInput>;
  update?: Maybe<PaymentUpdateWithoutCardDataInput>;
  upsert?: Maybe<PaymentUpsertWithoutCardInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface RoomCreateWithoutStudioInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  capacity?: Maybe<Int>;
}

export interface PaymentUpdateWithoutCardDataInput {
  type?: Maybe<PaymentType>;
  date?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  student?: Maybe<StudentUpdateOneWithoutPaymentsInput>;
}

export interface StudioCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  rooms?: Maybe<RoomCreateManyWithoutStudioInput>;
  address?: Maybe<String>;
}

export interface StudentUpdateOneWithoutPaymentsInput {
  create?: Maybe<StudentCreateWithoutPaymentsInput>;
  update?: Maybe<StudentUpdateWithoutPaymentsDataInput>;
  upsert?: Maybe<StudentUpsertWithoutPaymentsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<StudentWhereUniqueInput>;
}

export interface StudentUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  mobile?: Maybe<String>;
  hasReferralBonus?: Maybe<Boolean>;
}

export interface StudentUpdateWithoutPaymentsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  mobile?: Maybe<String>;
  memberships?: Maybe<MembershipUpdateManyWithoutStudentInput>;
  cards?: Maybe<CardUpdateManyWithoutStudentInput>;
  hasReferralBonus?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneWithoutStudentInput>;
}

export interface RoomUpdateManyMutationInput {
  name?: Maybe<String>;
  capacity?: Maybe<Int>;
}

export interface CourseInstanceUpdateInput {
  course?: Maybe<CourseUpdateOneWithoutInstancesInput>;
  date?: Maybe<DateTimeInput>;
  topic?: Maybe<String>;
  notes?: Maybe<String>;
  participants?: Maybe<ParticipantUpdateManyWithoutCourseInstanceInput>;
  recapUrl?: Maybe<String>;
  isCancelled?: Maybe<Boolean>;
}

export interface RoomUpdateInput {
  name?: Maybe<String>;
  capacity?: Maybe<Int>;
  studio?: Maybe<StudioUpdateOneRequiredWithoutRoomsInput>;
}

export interface UserUpdateWithoutStudentDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  admin?: Maybe<Boolean>;
}

export interface PaymentUpdateInput {
  type?: Maybe<PaymentType>;
  date?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  student?: Maybe<StudentUpdateOneWithoutPaymentsInput>;
  card?: Maybe<CardUpdateOneWithoutPaymentInput>;
}

export interface UserUpsertWithoutStudentInput {
  update: UserUpdateWithoutStudentDataInput;
  create: UserCreateWithoutStudentInput;
}

export interface PaymentCreateInput {
  id?: Maybe<ID_Input>;
  type: PaymentType;
  date: DateTimeInput;
  amount: Int;
  student?: Maybe<StudentCreateOneWithoutPaymentsInput>;
  card?: Maybe<CardCreateOneWithoutPaymentInput>;
}

export interface StudentUpsertWithoutPaymentsInput {
  update: StudentUpdateWithoutPaymentsDataInput;
  create: StudentCreateWithoutPaymentsInput;
}

export interface ParticipantUpdateInput {
  membership?: Maybe<MembershipUpdateOneRequiredInput>;
  courseInstance?: Maybe<
    CourseInstanceUpdateOneRequiredWithoutParticipantsInput
  >;
  status?: Maybe<ParticipantStatus>;
}

export interface PaymentUpsertWithoutCardInput {
  update: PaymentUpdateWithoutCardDataInput;
  create: PaymentCreateWithoutCardInput;
}

export type StudioWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface ParticipantUpdateManyInput {
  create?: Maybe<ParticipantCreateInput[] | ParticipantCreateInput>;
  update?: Maybe<
    | ParticipantUpdateWithWhereUniqueNestedInput[]
    | ParticipantUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ParticipantUpsertWithWhereUniqueNestedInput[]
    | ParticipantUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
  connect?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
  set?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
  disconnect?: Maybe<
    ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ParticipantScalarWhereInput[] | ParticipantScalarWhereInput
  >;
  updateMany?: Maybe<
    | ParticipantUpdateManyWithWhereNestedInput[]
    | ParticipantUpdateManyWithWhereNestedInput
  >;
}

export interface MailgunEmailPayloadUpdateManyMutationInput {
  success?: Maybe<Boolean>;
}

export interface ParticipantUpdateWithWhereUniqueNestedInput {
  where: ParticipantWhereUniqueInput;
  data: ParticipantUpdateDataInput;
}

export interface MailgunEmailPayloadCreateInput {
  id?: Maybe<ID_Input>;
  success: Boolean;
}

export interface ParticipantUpdateDataInput {
  membership?: Maybe<MembershipUpdateOneRequiredInput>;
  courseInstance?: Maybe<
    CourseInstanceUpdateOneRequiredWithoutParticipantsInput
  >;
  status?: Maybe<ParticipantStatus>;
}

export interface LoginResponseUpdateManyMutationInput {
  token?: Maybe<String>;
}

export interface MembershipUpdateOneRequiredInput {
  create?: Maybe<MembershipCreateInput>;
  update?: Maybe<MembershipUpdateDataInput>;
  upsert?: Maybe<MembershipUpsertNestedInput>;
  connect?: Maybe<MembershipWhereUniqueInput>;
}

export interface LoginResponseCreateInput {
  id?: Maybe<ID_Input>;
  token?: Maybe<String>;
  user?: Maybe<UserCreateOneInput>;
}

export interface MembershipUpdateDataInput {
  student?: Maybe<StudentUpdateOneRequiredWithoutMembershipsInput>;
  course?: Maybe<CourseUpdateOneRequiredWithoutMembershipsInput>;
  role?: Maybe<DanceRole>;
  status?: Maybe<MembershipStatus>;
  waitlistDate?: Maybe<DateTimeInput>;
}

export interface ExpenseUpdateManyMutationInput {
  type?: Maybe<ExpenseType>;
  date?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  note?: Maybe<String>;
}

export interface StudentUpdateOneRequiredWithoutMembershipsInput {
  create?: Maybe<StudentCreateWithoutMembershipsInput>;
  update?: Maybe<StudentUpdateWithoutMembershipsDataInput>;
  upsert?: Maybe<StudentUpsertWithoutMembershipsInput>;
  connect?: Maybe<StudentWhereUniqueInput>;
}

export interface ExpenseCreateInput {
  id?: Maybe<ID_Input>;
  type: ExpenseType;
  date: DateTimeInput;
  amount: Int;
  note?: Maybe<String>;
}

export interface StudentUpdateWithoutMembershipsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  mobile?: Maybe<String>;
  cards?: Maybe<CardUpdateManyWithoutStudentInput>;
  hasReferralBonus?: Maybe<Boolean>;
  payments?: Maybe<PaymentUpdateManyWithoutStudentInput>;
  user?: Maybe<UserUpdateOneWithoutStudentInput>;
}

export interface StudentCreateOneWithoutCardsInput {
  create?: Maybe<StudentCreateWithoutCardsInput>;
  connect?: Maybe<StudentWhereUniqueInput>;
}

export interface StudioWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  rooms_every?: Maybe<RoomWhereInput>;
  rooms_some?: Maybe<RoomWhereInput>;
  rooms_none?: Maybe<RoomWhereInput>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  AND?: Maybe<StudioWhereInput[] | StudioWhereInput>;
  OR?: Maybe<StudioWhereInput[] | StudioWhereInput>;
  NOT?: Maybe<StudioWhereInput[] | StudioWhereInput>;
}

export interface MembershipCreateManyWithoutStudentInput {
  create?: Maybe<
    MembershipCreateWithoutStudentInput[] | MembershipCreateWithoutStudentInput
  >;
  connect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
}

export interface CourseInstanceCreateInput {
  id?: Maybe<ID_Input>;
  course?: Maybe<CourseCreateOneWithoutInstancesInput>;
  date: DateTimeInput;
  topic?: Maybe<String>;
  notes?: Maybe<String>;
  participants?: Maybe<ParticipantCreateManyWithoutCourseInstanceInput>;
  recapUrl?: Maybe<String>;
  isCancelled?: Maybe<Boolean>;
}

export interface CourseCreateOneWithoutMembershipsInput {
  create?: Maybe<CourseCreateWithoutMembershipsInput>;
  connect?: Maybe<CourseWhereUniqueInput>;
}

export interface PaymentUpdateWithoutStudentDataInput {
  type?: Maybe<PaymentType>;
  date?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  card?: Maybe<CardUpdateOneWithoutPaymentInput>;
}

export interface TeacherCreateManyWithoutCoursesInput {
  create?: Maybe<
    TeacherCreateWithoutCoursesInput[] | TeacherCreateWithoutCoursesInput
  >;
  connect?: Maybe<TeacherWhereUniqueInput[] | TeacherWhereUniqueInput>;
}

export interface CardUpdateOneWithoutPaymentInput {
  create?: Maybe<CardCreateWithoutPaymentInput>;
  update?: Maybe<CardUpdateWithoutPaymentDataInput>;
  upsert?: Maybe<CardUpsertWithoutPaymentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CardWhereUniqueInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CardUpdateWithoutPaymentDataInput {
  student?: Maybe<StudentUpdateOneRequiredWithoutCardsInput>;
  expirationDate?: Maybe<DateTimeInput>;
  active?: Maybe<Boolean>;
  paid?: Maybe<Boolean>;
  value?: Maybe<Int>;
  originalValue?: Maybe<Int>;
  participationHistory?: Maybe<ParticipantUpdateManyInput>;
  privateLessonLength?: Maybe<Int>;
  privateLessonUseDate?: Maybe<DateTimeInput>;
}

export interface StudentCreateOneWithoutUserInput {
  create?: Maybe<StudentCreateWithoutUserInput>;
  connect?: Maybe<StudentWhereUniqueInput>;
}

export interface CardUpsertWithoutPaymentInput {
  update: CardUpdateWithoutPaymentDataInput;
  create: CardCreateWithoutPaymentInput;
}

export interface CardCreateManyWithoutStudentInput {
  create?: Maybe<
    CardCreateWithoutStudentInput[] | CardCreateWithoutStudentInput
  >;
  connect?: Maybe<CardWhereUniqueInput[] | CardWhereUniqueInput>;
}

export interface PaymentUpsertWithWhereUniqueWithoutStudentInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutStudentDataInput;
  create: PaymentCreateWithoutStudentInput;
}

export interface PaymentCreateOneWithoutCardInput {
  create?: Maybe<PaymentCreateWithoutCardInput>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface PaymentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<PaymentType>;
  type_not?: Maybe<PaymentType>;
  type_in?: Maybe<PaymentType[] | PaymentType>;
  type_not_in?: Maybe<PaymentType[] | PaymentType>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  AND?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  OR?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  NOT?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
}

export interface StudentCreateOneWithoutPaymentsInput {
  create?: Maybe<StudentCreateWithoutPaymentsInput>;
  connect?: Maybe<StudentWhereUniqueInput>;
}

export interface PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput;
  data: PaymentUpdateManyDataInput;
}

export interface UserCreateOneWithoutStudentInput {
  create?: Maybe<UserCreateWithoutStudentInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface PaymentUpdateManyDataInput {
  type?: Maybe<PaymentType>;
  date?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
}

export interface ParticipantCreateManyInput {
  create?: Maybe<ParticipantCreateInput[] | ParticipantCreateInput>;
  connect?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
}

export interface StudentUpsertWithoutMembershipsInput {
  update: StudentUpdateWithoutMembershipsDataInput;
  create: StudentCreateWithoutMembershipsInput;
}

export interface MembershipCreateOneInput {
  create?: Maybe<MembershipCreateInput>;
  connect?: Maybe<MembershipWhereUniqueInput>;
}

export interface MembershipUpsertNestedInput {
  update: MembershipUpdateDataInput;
  create: MembershipCreateInput;
}

export interface StudentCreateOneWithoutMembershipsInput {
  create?: Maybe<StudentCreateWithoutMembershipsInput>;
  connect?: Maybe<StudentWhereUniqueInput>;
}

export interface CourseInstanceUpdateOneRequiredWithoutParticipantsInput {
  create?: Maybe<CourseInstanceCreateWithoutParticipantsInput>;
  update?: Maybe<CourseInstanceUpdateWithoutParticipantsDataInput>;
  upsert?: Maybe<CourseInstanceUpsertWithoutParticipantsInput>;
  connect?: Maybe<CourseInstanceWhereUniqueInput>;
}

export interface PaymentCreateManyWithoutStudentInput {
  create?: Maybe<
    PaymentCreateWithoutStudentInput[] | PaymentCreateWithoutStudentInput
  >;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
}

export interface CourseInstanceUpdateWithoutParticipantsDataInput {
  course?: Maybe<CourseUpdateOneWithoutInstancesInput>;
  date?: Maybe<DateTimeInput>;
  topic?: Maybe<String>;
  notes?: Maybe<String>;
  recapUrl?: Maybe<String>;
  isCancelled?: Maybe<Boolean>;
}

export interface CardCreateOneWithoutPaymentInput {
  create?: Maybe<CardCreateWithoutPaymentInput>;
  connect?: Maybe<CardWhereUniqueInput>;
}

export interface CourseUpdateOneWithoutInstancesInput {
  create?: Maybe<CourseCreateWithoutInstancesInput>;
  update?: Maybe<CourseUpdateWithoutInstancesDataInput>;
  upsert?: Maybe<CourseUpsertWithoutInstancesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CourseWhereUniqueInput>;
}

export interface CourseInstanceCreateOneWithoutParticipantsInput {
  create?: Maybe<CourseInstanceCreateWithoutParticipantsInput>;
  connect?: Maybe<CourseInstanceWhereUniqueInput>;
}

export interface CourseUpdateWithoutInstancesDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startTime?: Maybe<String>;
  day?: Maybe<CourseDay>;
  duration?: Maybe<Int>;
  teachers?: Maybe<TeacherUpdateManyWithoutCoursesInput>;
  memberships?: Maybe<MembershipUpdateManyWithoutCourseInput>;
  studentLimit?: Maybe<Int>;
  room?: Maybe<RoomUpdateOneInput>;
  absences?: Maybe<CourseAbsenceUpdateManyWithoutCourseInput>;
}

export interface CourseCreateOneWithoutInstancesInput {
  create?: Maybe<CourseCreateWithoutInstancesInput>;
  connect?: Maybe<CourseWhereUniqueInput>;
}

export interface MembershipUpdateManyWithoutCourseInput {
  create?: Maybe<
    MembershipCreateWithoutCourseInput[] | MembershipCreateWithoutCourseInput
  >;
  delete?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  connect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  set?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  disconnect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
  update?: Maybe<
    | MembershipUpdateWithWhereUniqueWithoutCourseInput[]
    | MembershipUpdateWithWhereUniqueWithoutCourseInput
  >;
  upsert?: Maybe<
    | MembershipUpsertWithWhereUniqueWithoutCourseInput[]
    | MembershipUpsertWithWhereUniqueWithoutCourseInput
  >;
  deleteMany?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
  updateMany?: Maybe<
    | MembershipUpdateManyWithWhereNestedInput[]
    | MembershipUpdateManyWithWhereNestedInput
  >;
}

export interface MembershipCreateManyWithoutCourseInput {
  create?: Maybe<
    MembershipCreateWithoutCourseInput[] | MembershipCreateWithoutCourseInput
  >;
  connect?: Maybe<MembershipWhereUniqueInput[] | MembershipWhereUniqueInput>;
}

export interface MembershipUpdateWithWhereUniqueWithoutCourseInput {
  where: MembershipWhereUniqueInput;
  data: MembershipUpdateWithoutCourseDataInput;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  student?: Maybe<StudentWhereInput>;
  admin?: Maybe<Boolean>;
  admin_not?: Maybe<Boolean>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface MembershipUpdateWithoutCourseDataInput {
  student?: Maybe<StudentUpdateOneRequiredWithoutMembershipsInput>;
  role?: Maybe<DanceRole>;
  status?: Maybe<MembershipStatus>;
  waitlistDate?: Maybe<DateTimeInput>;
}

export interface CourseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  day?: Maybe<CourseDay>;
  day_not?: Maybe<CourseDay>;
  day_in?: Maybe<CourseDay[] | CourseDay>;
  day_not_in?: Maybe<CourseDay[] | CourseDay>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  teachers_every?: Maybe<TeacherWhereInput>;
  teachers_some?: Maybe<TeacherWhereInput>;
  teachers_none?: Maybe<TeacherWhereInput>;
  memberships_every?: Maybe<MembershipWhereInput>;
  memberships_some?: Maybe<MembershipWhereInput>;
  memberships_none?: Maybe<MembershipWhereInput>;
  instances_every?: Maybe<CourseInstanceWhereInput>;
  instances_some?: Maybe<CourseInstanceWhereInput>;
  instances_none?: Maybe<CourseInstanceWhereInput>;
  studentLimit?: Maybe<Int>;
  studentLimit_not?: Maybe<Int>;
  studentLimit_in?: Maybe<Int[] | Int>;
  studentLimit_not_in?: Maybe<Int[] | Int>;
  studentLimit_lt?: Maybe<Int>;
  studentLimit_lte?: Maybe<Int>;
  studentLimit_gt?: Maybe<Int>;
  studentLimit_gte?: Maybe<Int>;
  room?: Maybe<RoomWhereInput>;
  absences_every?: Maybe<CourseAbsenceWhereInput>;
  absences_some?: Maybe<CourseAbsenceWhereInput>;
  absences_none?: Maybe<CourseAbsenceWhereInput>;
  AND?: Maybe<CourseWhereInput[] | CourseWhereInput>;
  OR?: Maybe<CourseWhereInput[] | CourseWhereInput>;
  NOT?: Maybe<CourseWhereInput[] | CourseWhereInput>;
}

export interface MembershipUpsertWithWhereUniqueWithoutCourseInput {
  where: MembershipWhereUniqueInput;
  update: MembershipUpdateWithoutCourseDataInput;
  create: MembershipCreateWithoutCourseInput;
}

export interface CourseInstanceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  course?: Maybe<CourseWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  topic?: Maybe<String>;
  topic_not?: Maybe<String>;
  topic_in?: Maybe<String[] | String>;
  topic_not_in?: Maybe<String[] | String>;
  topic_lt?: Maybe<String>;
  topic_lte?: Maybe<String>;
  topic_gt?: Maybe<String>;
  topic_gte?: Maybe<String>;
  topic_contains?: Maybe<String>;
  topic_not_contains?: Maybe<String>;
  topic_starts_with?: Maybe<String>;
  topic_not_starts_with?: Maybe<String>;
  topic_ends_with?: Maybe<String>;
  topic_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  participants_every?: Maybe<ParticipantWhereInput>;
  participants_some?: Maybe<ParticipantWhereInput>;
  participants_none?: Maybe<ParticipantWhereInput>;
  recapUrl?: Maybe<String>;
  recapUrl_not?: Maybe<String>;
  recapUrl_in?: Maybe<String[] | String>;
  recapUrl_not_in?: Maybe<String[] | String>;
  recapUrl_lt?: Maybe<String>;
  recapUrl_lte?: Maybe<String>;
  recapUrl_gt?: Maybe<String>;
  recapUrl_gte?: Maybe<String>;
  recapUrl_contains?: Maybe<String>;
  recapUrl_not_contains?: Maybe<String>;
  recapUrl_starts_with?: Maybe<String>;
  recapUrl_not_starts_with?: Maybe<String>;
  recapUrl_ends_with?: Maybe<String>;
  recapUrl_not_ends_with?: Maybe<String>;
  isCancelled?: Maybe<Boolean>;
  isCancelled_not?: Maybe<Boolean>;
  AND?: Maybe<CourseInstanceWhereInput[] | CourseInstanceWhereInput>;
  OR?: Maybe<CourseInstanceWhereInput[] | CourseInstanceWhereInput>;
  NOT?: Maybe<CourseInstanceWhereInput[] | CourseInstanceWhereInput>;
}

export interface MembershipScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  role?: Maybe<DanceRole>;
  role_not?: Maybe<DanceRole>;
  role_in?: Maybe<DanceRole[] | DanceRole>;
  role_not_in?: Maybe<DanceRole[] | DanceRole>;
  status?: Maybe<MembershipStatus>;
  status_not?: Maybe<MembershipStatus>;
  status_in?: Maybe<MembershipStatus[] | MembershipStatus>;
  status_not_in?: Maybe<MembershipStatus[] | MembershipStatus>;
  waitlistDate?: Maybe<DateTimeInput>;
  waitlistDate_not?: Maybe<DateTimeInput>;
  waitlistDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  waitlistDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  waitlistDate_lt?: Maybe<DateTimeInput>;
  waitlistDate_lte?: Maybe<DateTimeInput>;
  waitlistDate_gt?: Maybe<DateTimeInput>;
  waitlistDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
  OR?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
  NOT?: Maybe<MembershipScalarWhereInput[] | MembershipScalarWhereInput>;
}

export interface MailgunEmailPayloadSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MailgunEmailPayloadWhereInput>;
  AND?: Maybe<
    | MailgunEmailPayloadSubscriptionWhereInput[]
    | MailgunEmailPayloadSubscriptionWhereInput
  >;
  OR?: Maybe<
    | MailgunEmailPayloadSubscriptionWhereInput[]
    | MailgunEmailPayloadSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MailgunEmailPayloadSubscriptionWhereInput[]
    | MailgunEmailPayloadSubscriptionWhereInput
  >;
}

export interface MembershipUpdateManyWithWhereNestedInput {
  where: MembershipScalarWhereInput;
  data: MembershipUpdateManyDataInput;
}

export interface CourseAbsenceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CourseAbsenceWhereInput>;
  AND?: Maybe<
    CourseAbsenceSubscriptionWhereInput[] | CourseAbsenceSubscriptionWhereInput
  >;
  OR?: Maybe<
    CourseAbsenceSubscriptionWhereInput[] | CourseAbsenceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CourseAbsenceSubscriptionWhereInput[] | CourseAbsenceSubscriptionWhereInput
  >;
}

export interface MembershipUpdateManyDataInput {
  role?: Maybe<DanceRole>;
  status?: Maybe<MembershipStatus>;
  waitlistDate?: Maybe<DateTimeInput>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  admin?: Maybe<Boolean>;
}

export interface RoomUpdateOneInput {
  create?: Maybe<RoomCreateInput>;
  update?: Maybe<RoomUpdateDataInput>;
  upsert?: Maybe<RoomUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<RoomWhereUniqueInput>;
}

export interface CourseUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startTime?: Maybe<String>;
  day?: Maybe<CourseDay>;
  duration?: Maybe<Int>;
  studentLimit?: Maybe<Int>;
}

export interface RoomUpdateDataInput {
  name?: Maybe<String>;
  capacity?: Maybe<Int>;
  studio?: Maybe<StudioUpdateOneRequiredWithoutRoomsInput>;
}

export interface CourseUpsertWithWhereUniqueWithoutTeachersInput {
  where: CourseWhereUniqueInput;
  update: CourseUpdateWithoutTeachersDataInput;
  create: CourseCreateWithoutTeachersInput;
}

export interface StudioUpdateOneRequiredWithoutRoomsInput {
  create?: Maybe<StudioCreateWithoutRoomsInput>;
  update?: Maybe<StudioUpdateWithoutRoomsDataInput>;
  upsert?: Maybe<StudioUpsertWithoutRoomsInput>;
  connect?: Maybe<StudioWhereUniqueInput>;
}

export interface PaymentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<PaymentType>;
  type_not?: Maybe<PaymentType>;
  type_in?: Maybe<PaymentType[] | PaymentType>;
  type_not_in?: Maybe<PaymentType[] | PaymentType>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  student?: Maybe<StudentWhereInput>;
  card?: Maybe<CardWhereInput>;
  AND?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
  OR?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
  NOT?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
}

export interface StudioUpdateWithoutRoomsDataInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
}

export interface TeacherUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  mobile?: Maybe<String>;
  courses?: Maybe<CourseUpdateManyWithoutTeachersInput>;
  user?: Maybe<UserUpdateOneInput>;
}

export interface StudioUpsertWithoutRoomsInput {
  update: StudioUpdateWithoutRoomsDataInput;
  create: StudioCreateWithoutRoomsInput;
}

export interface LoginResponseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  token?: Maybe<String>;
  token_not?: Maybe<String>;
  token_in?: Maybe<String[] | String>;
  token_not_in?: Maybe<String[] | String>;
  token_lt?: Maybe<String>;
  token_lte?: Maybe<String>;
  token_gt?: Maybe<String>;
  token_gte?: Maybe<String>;
  token_contains?: Maybe<String>;
  token_not_contains?: Maybe<String>;
  token_starts_with?: Maybe<String>;
  token_not_starts_with?: Maybe<String>;
  token_ends_with?: Maybe<String>;
  token_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<LoginResponseWhereInput[] | LoginResponseWhereInput>;
  OR?: Maybe<LoginResponseWhereInput[] | LoginResponseWhereInput>;
  NOT?: Maybe<LoginResponseWhereInput[] | LoginResponseWhereInput>;
}

export interface RoomUpsertNestedInput {
  update: RoomUpdateDataInput;
  create: RoomCreateInput;
}

export interface RoomUpdateManyDataInput {
  name?: Maybe<String>;
  capacity?: Maybe<Int>;
}

export interface CourseAbsenceUpdateManyWithoutCourseInput {
  create?: Maybe<
    | CourseAbsenceCreateWithoutCourseInput[]
    | CourseAbsenceCreateWithoutCourseInput
  >;
  delete?: Maybe<
    CourseAbsenceWhereUniqueInput[] | CourseAbsenceWhereUniqueInput
  >;
  connect?: Maybe<
    CourseAbsenceWhereUniqueInput[] | CourseAbsenceWhereUniqueInput
  >;
  set?: Maybe<CourseAbsenceWhereUniqueInput[] | CourseAbsenceWhereUniqueInput>;
  disconnect?: Maybe<
    CourseAbsenceWhereUniqueInput[] | CourseAbsenceWhereUniqueInput
  >;
  update?: Maybe<
    | CourseAbsenceUpdateWithWhereUniqueWithoutCourseInput[]
    | CourseAbsenceUpdateWithWhereUniqueWithoutCourseInput
  >;
  upsert?: Maybe<
    | CourseAbsenceUpsertWithWhereUniqueWithoutCourseInput[]
    | CourseAbsenceUpsertWithWhereUniqueWithoutCourseInput
  >;
  deleteMany?: Maybe<
    CourseAbsenceScalarWhereInput[] | CourseAbsenceScalarWhereInput
  >;
  updateMany?: Maybe<
    | CourseAbsenceUpdateManyWithWhereNestedInput[]
    | CourseAbsenceUpdateManyWithWhereNestedInput
  >;
}

export interface MembershipWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  student?: Maybe<StudentWhereInput>;
  course?: Maybe<CourseWhereInput>;
  role?: Maybe<DanceRole>;
  role_not?: Maybe<DanceRole>;
  role_in?: Maybe<DanceRole[] | DanceRole>;
  role_not_in?: Maybe<DanceRole[] | DanceRole>;
  status?: Maybe<MembershipStatus>;
  status_not?: Maybe<MembershipStatus>;
  status_in?: Maybe<MembershipStatus[] | MembershipStatus>;
  status_not_in?: Maybe<MembershipStatus[] | MembershipStatus>;
  waitlistDate?: Maybe<DateTimeInput>;
  waitlistDate_not?: Maybe<DateTimeInput>;
  waitlistDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  waitlistDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  waitlistDate_lt?: Maybe<DateTimeInput>;
  waitlistDate_lte?: Maybe<DateTimeInput>;
  waitlistDate_gt?: Maybe<DateTimeInput>;
  waitlistDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MembershipWhereInput[] | MembershipWhereInput>;
  OR?: Maybe<MembershipWhereInput[] | MembershipWhereInput>;
  NOT?: Maybe<MembershipWhereInput[] | MembershipWhereInput>;
}

export interface CourseAbsenceUpdateWithWhereUniqueWithoutCourseInput {
  where: CourseAbsenceWhereUniqueInput;
  data: CourseAbsenceUpdateWithoutCourseDataInput;
}

export type MembershipWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CourseAbsenceUpdateWithoutCourseDataInput {
  date?: Maybe<DateTimeInput>;
  student?: Maybe<StudentUpdateOneRequiredInput>;
}

export type ParticipantWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface StudentUpdateOneRequiredInput {
  create?: Maybe<StudentCreateInput>;
  update?: Maybe<StudentUpdateDataInput>;
  upsert?: Maybe<StudentUpsertNestedInput>;
  connect?: Maybe<StudentWhereUniqueInput>;
}

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface StudentUpdateDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  mobile?: Maybe<String>;
  memberships?: Maybe<MembershipUpdateManyWithoutStudentInput>;
  cards?: Maybe<CardUpdateManyWithoutStudentInput>;
  hasReferralBonus?: Maybe<Boolean>;
  payments?: Maybe<PaymentUpdateManyWithoutStudentInput>;
  user?: Maybe<UserUpdateOneWithoutStudentInput>;
}

export type RoomWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface StudentUpsertNestedInput {
  update: StudentUpdateDataInput;
  create: StudentCreateInput;
}

export type StudentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
  email?: Maybe<String>;
}>;

export interface CourseAbsenceUpsertWithWhereUniqueWithoutCourseInput {
  where: CourseAbsenceWhereUniqueInput;
  update: CourseAbsenceUpdateWithoutCourseDataInput;
  create: CourseAbsenceCreateWithoutCourseInput;
}

export interface MembershipUpdateManyMutationInput {
  role?: Maybe<DanceRole>;
  status?: Maybe<MembershipStatus>;
  waitlistDate?: Maybe<DateTimeInput>;
}

export interface CourseAbsenceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CourseAbsenceScalarWhereInput[] | CourseAbsenceScalarWhereInput>;
  OR?: Maybe<CourseAbsenceScalarWhereInput[] | CourseAbsenceScalarWhereInput>;
  NOT?: Maybe<CourseAbsenceScalarWhereInput[] | CourseAbsenceScalarWhereInput>;
}

export interface MailgunEmailPayloadUpdateInput {
  success?: Maybe<Boolean>;
}

export interface CourseAbsenceUpdateManyWithWhereNestedInput {
  where: CourseAbsenceScalarWhereInput;
  data: CourseAbsenceUpdateManyDataInput;
}

export interface LoginResponseUpdateInput {
  token?: Maybe<String>;
  user?: Maybe<UserUpdateOneInput>;
}

export interface CourseAbsenceUpdateManyDataInput {
  date?: Maybe<DateTimeInput>;
}

export interface ExpenseUpdateInput {
  type?: Maybe<ExpenseType>;
  date?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  note?: Maybe<String>;
}

export interface CourseUpsertWithoutInstancesInput {
  update: CourseUpdateWithoutInstancesDataInput;
  create: CourseCreateWithoutInstancesInput;
}

export interface CardCreateInput {
  id?: Maybe<ID_Input>;
  student: StudentCreateOneWithoutCardsInput;
  payment?: Maybe<PaymentCreateOneWithoutCardInput>;
  expirationDate?: Maybe<DateTimeInput>;
  active?: Maybe<Boolean>;
  paid?: Maybe<Boolean>;
  value: Int;
  originalValue: Int;
  participationHistory?: Maybe<ParticipantCreateManyInput>;
  privateLessonLength?: Maybe<Int>;
  privateLessonUseDate?: Maybe<DateTimeInput>;
}

export interface CourseInstanceUpsertWithoutParticipantsInput {
  update: CourseInstanceUpdateWithoutParticipantsDataInput;
  create: CourseInstanceCreateWithoutParticipantsInput;
}

export interface MembershipCreateWithoutStudentInput {
  id?: Maybe<ID_Input>;
  course: CourseCreateOneWithoutMembershipsInput;
  role: DanceRole;
  status?: Maybe<MembershipStatus>;
  waitlistDate?: Maybe<DateTimeInput>;
}

export interface ParticipantUpsertWithWhereUniqueNestedInput {
  where: ParticipantWhereUniqueInput;
  update: ParticipantUpdateDataInput;
  create: ParticipantCreateInput;
}

export interface TeacherCreateWithoutCoursesInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  mobile?: Maybe<String>;
  user?: Maybe<UserCreateOneInput>;
}

export interface ParticipantScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  status?: Maybe<ParticipantStatus>;
  status_not?: Maybe<ParticipantStatus>;
  status_in?: Maybe<ParticipantStatus[] | ParticipantStatus>;
  status_not_in?: Maybe<ParticipantStatus[] | ParticipantStatus>;
  AND?: Maybe<ParticipantScalarWhereInput[] | ParticipantScalarWhereInput>;
  OR?: Maybe<ParticipantScalarWhereInput[] | ParticipantScalarWhereInput>;
  NOT?: Maybe<ParticipantScalarWhereInput[] | ParticipantScalarWhereInput>;
}

export interface StudentCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  mobile?: Maybe<String>;
  memberships?: Maybe<MembershipCreateManyWithoutStudentInput>;
  cards?: Maybe<CardCreateManyWithoutStudentInput>;
  hasReferralBonus?: Maybe<Boolean>;
  payments?: Maybe<PaymentCreateManyWithoutStudentInput>;
}

export interface ParticipantUpdateManyWithWhereNestedInput {
  where: ParticipantScalarWhereInput;
  data: ParticipantUpdateManyDataInput;
}

export interface PaymentCreateWithoutCardInput {
  id?: Maybe<ID_Input>;
  type: PaymentType;
  date: DateTimeInput;
  amount: Int;
  student?: Maybe<StudentCreateOneWithoutPaymentsInput>;
}

export interface ParticipantUpdateManyDataInput {
  status?: Maybe<ParticipantStatus>;
}

export interface UserCreateWithoutStudentInput {
  id?: Maybe<ID_Input>;
  email?: Maybe<String>;
  password: String;
  admin?: Maybe<Boolean>;
}

export interface CardUpsertWithWhereUniqueWithoutStudentInput {
  where: CardWhereUniqueInput;
  update: CardUpdateWithoutStudentDataInput;
  create: CardCreateWithoutStudentInput;
}

export interface MembershipCreateInput {
  id?: Maybe<ID_Input>;
  student: StudentCreateOneWithoutMembershipsInput;
  course: CourseCreateOneWithoutMembershipsInput;
  role: DanceRole;
  status?: Maybe<MembershipStatus>;
  waitlistDate?: Maybe<DateTimeInput>;
}

export interface CardScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  expirationDate?: Maybe<DateTimeInput>;
  expirationDate_not?: Maybe<DateTimeInput>;
  expirationDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expirationDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expirationDate_lt?: Maybe<DateTimeInput>;
  expirationDate_lte?: Maybe<DateTimeInput>;
  expirationDate_gt?: Maybe<DateTimeInput>;
  expirationDate_gte?: Maybe<DateTimeInput>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  paid?: Maybe<Boolean>;
  paid_not?: Maybe<Boolean>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  originalValue?: Maybe<Int>;
  originalValue_not?: Maybe<Int>;
  originalValue_in?: Maybe<Int[] | Int>;
  originalValue_not_in?: Maybe<Int[] | Int>;
  originalValue_lt?: Maybe<Int>;
  originalValue_lte?: Maybe<Int>;
  originalValue_gt?: Maybe<Int>;
  originalValue_gte?: Maybe<Int>;
  privateLessonLength?: Maybe<Int>;
  privateLessonLength_not?: Maybe<Int>;
  privateLessonLength_in?: Maybe<Int[] | Int>;
  privateLessonLength_not_in?: Maybe<Int[] | Int>;
  privateLessonLength_lt?: Maybe<Int>;
  privateLessonLength_lte?: Maybe<Int>;
  privateLessonLength_gt?: Maybe<Int>;
  privateLessonLength_gte?: Maybe<Int>;
  privateLessonUseDate?: Maybe<DateTimeInput>;
  privateLessonUseDate_not?: Maybe<DateTimeInput>;
  privateLessonUseDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  privateLessonUseDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  privateLessonUseDate_lt?: Maybe<DateTimeInput>;
  privateLessonUseDate_lte?: Maybe<DateTimeInput>;
  privateLessonUseDate_gt?: Maybe<DateTimeInput>;
  privateLessonUseDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CardScalarWhereInput[] | CardScalarWhereInput>;
  OR?: Maybe<CardScalarWhereInput[] | CardScalarWhereInput>;
  NOT?: Maybe<CardScalarWhereInput[] | CardScalarWhereInput>;
}

export interface PaymentCreateWithoutStudentInput {
  id?: Maybe<ID_Input>;
  type: PaymentType;
  date: DateTimeInput;
  amount: Int;
  card?: Maybe<CardCreateOneWithoutPaymentInput>;
}

export interface CardUpdateManyWithWhereNestedInput {
  where: CardScalarWhereInput;
  data: CardUpdateManyDataInput;
}

export interface CourseInstanceCreateWithoutParticipantsInput {
  id?: Maybe<ID_Input>;
  course?: Maybe<CourseCreateOneWithoutInstancesInput>;
  date: DateTimeInput;
  topic?: Maybe<String>;
  notes?: Maybe<String>;
  recapUrl?: Maybe<String>;
  isCancelled?: Maybe<Boolean>;
}

export interface CardUpdateManyDataInput {
  expirationDate?: Maybe<DateTimeInput>;
  active?: Maybe<Boolean>;
  paid?: Maybe<Boolean>;
  value?: Maybe<Int>;
  originalValue?: Maybe<Int>;
  privateLessonLength?: Maybe<Int>;
  privateLessonUseDate?: Maybe<DateTimeInput>;
}

export interface RoomWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  capacity?: Maybe<Int>;
  capacity_not?: Maybe<Int>;
  capacity_in?: Maybe<Int[] | Int>;
  capacity_not_in?: Maybe<Int[] | Int>;
  capacity_lt?: Maybe<Int>;
  capacity_lte?: Maybe<Int>;
  capacity_gt?: Maybe<Int>;
  capacity_gte?: Maybe<Int>;
  studio?: Maybe<StudioWhereInput>;
  AND?: Maybe<RoomWhereInput[] | RoomWhereInput>;
  OR?: Maybe<RoomWhereInput[] | RoomWhereInput>;
  NOT?: Maybe<RoomWhereInput[] | RoomWhereInput>;
}

export interface StudentUpsertWithoutUserInput {
  update: StudentUpdateWithoutUserDataInput;
  create: StudentCreateWithoutUserInput;
}

export interface RoomSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoomWhereInput>;
  AND?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
  OR?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
  NOT?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ExpenseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExpenseWhereInput>;
  AND?: Maybe<ExpenseSubscriptionWhereInput[] | ExpenseSubscriptionWhereInput>;
  OR?: Maybe<ExpenseSubscriptionWhereInput[] | ExpenseSubscriptionWhereInput>;
  NOT?: Maybe<ExpenseSubscriptionWhereInput[] | ExpenseSubscriptionWhereInput>;
}

export interface TeacherUpsertWithWhereUniqueWithoutCoursesInput {
  where: TeacherWhereUniqueInput;
  update: TeacherUpdateWithoutCoursesDataInput;
  create: TeacherCreateWithoutCoursesInput;
}

export type CourseAbsenceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TeacherScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  AND?: Maybe<TeacherScalarWhereInput[] | TeacherScalarWhereInput>;
  OR?: Maybe<TeacherScalarWhereInput[] | TeacherScalarWhereInput>;
  NOT?: Maybe<TeacherScalarWhereInput[] | TeacherScalarWhereInput>;
}

export type ExpenseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TeacherUpdateManyWithWhereNestedInput {
  where: TeacherScalarWhereInput;
  data: TeacherUpdateManyDataInput;
}

export type LoginResponseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TeacherUpdateManyDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  mobile?: Maybe<String>;
}

export interface RoomUpdateManyWithWhereNestedInput {
  where: RoomScalarWhereInput;
  data: RoomUpdateManyDataInput;
}

export interface CourseInstanceUpdateManyWithoutCourseInput {
  create?: Maybe<
    | CourseInstanceCreateWithoutCourseInput[]
    | CourseInstanceCreateWithoutCourseInput
  >;
  delete?: Maybe<
    CourseInstanceWhereUniqueInput[] | CourseInstanceWhereUniqueInput
  >;
  connect?: Maybe<
    CourseInstanceWhereUniqueInput[] | CourseInstanceWhereUniqueInput
  >;
  set?: Maybe<
    CourseInstanceWhereUniqueInput[] | CourseInstanceWhereUniqueInput
  >;
  disconnect?: Maybe<
    CourseInstanceWhereUniqueInput[] | CourseInstanceWhereUniqueInput
  >;
  update?: Maybe<
    | CourseInstanceUpdateWithWhereUniqueWithoutCourseInput[]
    | CourseInstanceUpdateWithWhereUniqueWithoutCourseInput
  >;
  upsert?: Maybe<
    | CourseInstanceUpsertWithWhereUniqueWithoutCourseInput[]
    | CourseInstanceUpsertWithWhereUniqueWithoutCourseInput
  >;
  deleteMany?: Maybe<
    CourseInstanceScalarWhereInput[] | CourseInstanceScalarWhereInput
  >;
  updateMany?: Maybe<
    | CourseInstanceUpdateManyWithWhereNestedInput[]
    | CourseInstanceUpdateManyWithWhereNestedInput
  >;
}

export interface RoomUpdateManyWithoutStudioInput {
  create?: Maybe<RoomCreateWithoutStudioInput[] | RoomCreateWithoutStudioInput>;
  delete?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
  connect?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
  set?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
  disconnect?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
  update?: Maybe<
    | RoomUpdateWithWhereUniqueWithoutStudioInput[]
    | RoomUpdateWithWhereUniqueWithoutStudioInput
  >;
  upsert?: Maybe<
    | RoomUpsertWithWhereUniqueWithoutStudioInput[]
    | RoomUpsertWithWhereUniqueWithoutStudioInput
  >;
  deleteMany?: Maybe<RoomScalarWhereInput[] | RoomScalarWhereInput>;
  updateMany?: Maybe<
    RoomUpdateManyWithWhereNestedInput[] | RoomUpdateManyWithWhereNestedInput
  >;
}

export interface CourseInstanceUpdateWithWhereUniqueWithoutCourseInput {
  where: CourseInstanceWhereUniqueInput;
  data: CourseInstanceUpdateWithoutCourseDataInput;
}

export interface StudentUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  mobile?: Maybe<String>;
  memberships?: Maybe<MembershipUpdateManyWithoutStudentInput>;
  cards?: Maybe<CardUpdateManyWithoutStudentInput>;
  hasReferralBonus?: Maybe<Boolean>;
  payments?: Maybe<PaymentUpdateManyWithoutStudentInput>;
  user?: Maybe<UserUpdateOneWithoutStudentInput>;
}

export interface CourseInstanceUpdateWithoutCourseDataInput {
  date?: Maybe<DateTimeInput>;
  topic?: Maybe<String>;
  notes?: Maybe<String>;
  participants?: Maybe<ParticipantUpdateManyWithoutCourseInstanceInput>;
  recapUrl?: Maybe<String>;
  isCancelled?: Maybe<Boolean>;
}

export interface ParticipantUpdateManyMutationInput {
  status?: Maybe<ParticipantStatus>;
}

export interface ParticipantUpdateManyWithoutCourseInstanceInput {
  create?: Maybe<
    | ParticipantCreateWithoutCourseInstanceInput[]
    | ParticipantCreateWithoutCourseInstanceInput
  >;
  delete?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
  connect?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
  set?: Maybe<ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput>;
  disconnect?: Maybe<
    ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput
  >;
  update?: Maybe<
    | ParticipantUpdateWithWhereUniqueWithoutCourseInstanceInput[]
    | ParticipantUpdateWithWhereUniqueWithoutCourseInstanceInput
  >;
  upsert?: Maybe<
    | ParticipantUpsertWithWhereUniqueWithoutCourseInstanceInput[]
    | ParticipantUpsertWithWhereUniqueWithoutCourseInstanceInput
  >;
  deleteMany?: Maybe<
    ParticipantScalarWhereInput[] | ParticipantScalarWhereInput
  >;
  updateMany?: Maybe<
    | ParticipantUpdateManyWithWhereNestedInput[]
    | ParticipantUpdateManyWithWhereNestedInput
  >;
}

export type TeacherWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ParticipantUpdateWithWhereUniqueWithoutCourseInstanceInput {
  where: ParticipantWhereUniqueInput;
  data: ParticipantUpdateWithoutCourseInstanceDataInput;
}

export interface CourseInstanceUpdateManyMutationInput {
  date?: Maybe<DateTimeInput>;
  topic?: Maybe<String>;
  notes?: Maybe<String>;
  recapUrl?: Maybe<String>;
  isCancelled?: Maybe<Boolean>;
}

export interface ParticipantUpdateWithoutCourseInstanceDataInput {
  membership?: Maybe<MembershipUpdateOneRequiredInput>;
  status?: Maybe<ParticipantStatus>;
}

export interface CourseCreateWithoutMembershipsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startTime?: Maybe<String>;
  day?: Maybe<CourseDay>;
  duration?: Maybe<Int>;
  teachers?: Maybe<TeacherCreateManyWithoutCoursesInput>;
  instances?: Maybe<CourseInstanceCreateManyWithoutCourseInput>;
  studentLimit?: Maybe<Int>;
  room?: Maybe<RoomCreateOneInput>;
  absences?: Maybe<CourseAbsenceCreateManyWithoutCourseInput>;
}

export interface ParticipantUpsertWithWhereUniqueWithoutCourseInstanceInput {
  where: ParticipantWhereUniqueInput;
  update: ParticipantUpdateWithoutCourseInstanceDataInput;
  create: ParticipantCreateWithoutCourseInstanceInput;
}

export interface CardCreateWithoutStudentInput {
  id?: Maybe<ID_Input>;
  payment?: Maybe<PaymentCreateOneWithoutCardInput>;
  expirationDate?: Maybe<DateTimeInput>;
  active?: Maybe<Boolean>;
  paid?: Maybe<Boolean>;
  value: Int;
  originalValue: Int;
  participationHistory?: Maybe<ParticipantCreateManyInput>;
  privateLessonLength?: Maybe<Int>;
  privateLessonUseDate?: Maybe<DateTimeInput>;
}

export interface CourseInstanceUpsertWithWhereUniqueWithoutCourseInput {
  where: CourseInstanceWhereUniqueInput;
  update: CourseInstanceUpdateWithoutCourseDataInput;
  create: CourseInstanceCreateWithoutCourseInput;
}

export interface ParticipantCreateInput {
  id?: Maybe<ID_Input>;
  membership: MembershipCreateOneInput;
  courseInstance: CourseInstanceCreateOneWithoutParticipantsInput;
  status?: Maybe<ParticipantStatus>;
}

export interface CourseInstanceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  topic?: Maybe<String>;
  topic_not?: Maybe<String>;
  topic_in?: Maybe<String[] | String>;
  topic_not_in?: Maybe<String[] | String>;
  topic_lt?: Maybe<String>;
  topic_lte?: Maybe<String>;
  topic_gt?: Maybe<String>;
  topic_gte?: Maybe<String>;
  topic_contains?: Maybe<String>;
  topic_not_contains?: Maybe<String>;
  topic_starts_with?: Maybe<String>;
  topic_not_starts_with?: Maybe<String>;
  topic_ends_with?: Maybe<String>;
  topic_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  recapUrl?: Maybe<String>;
  recapUrl_not?: Maybe<String>;
  recapUrl_in?: Maybe<String[] | String>;
  recapUrl_not_in?: Maybe<String[] | String>;
  recapUrl_lt?: Maybe<String>;
  recapUrl_lte?: Maybe<String>;
  recapUrl_gt?: Maybe<String>;
  recapUrl_gte?: Maybe<String>;
  recapUrl_contains?: Maybe<String>;
  recapUrl_not_contains?: Maybe<String>;
  recapUrl_starts_with?: Maybe<String>;
  recapUrl_not_starts_with?: Maybe<String>;
  recapUrl_ends_with?: Maybe<String>;
  recapUrl_not_ends_with?: Maybe<String>;
  isCancelled?: Maybe<Boolean>;
  isCancelled_not?: Maybe<Boolean>;
  AND?: Maybe<
    CourseInstanceScalarWhereInput[] | CourseInstanceScalarWhereInput
  >;
  OR?: Maybe<CourseInstanceScalarWhereInput[] | CourseInstanceScalarWhereInput>;
  NOT?: Maybe<
    CourseInstanceScalarWhereInput[] | CourseInstanceScalarWhereInput
  >;
}

export interface CardCreateWithoutPaymentInput {
  id?: Maybe<ID_Input>;
  student: StudentCreateOneWithoutCardsInput;
  expirationDate?: Maybe<DateTimeInput>;
  active?: Maybe<Boolean>;
  paid?: Maybe<Boolean>;
  value: Int;
  originalValue: Int;
  participationHistory?: Maybe<ParticipantCreateManyInput>;
  privateLessonLength?: Maybe<Int>;
  privateLessonUseDate?: Maybe<DateTimeInput>;
}

export interface CourseInstanceUpdateManyWithWhereNestedInput {
  where: CourseInstanceScalarWhereInput;
  data: CourseInstanceUpdateManyDataInput;
}

export interface TeacherWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  courses_every?: Maybe<CourseWhereInput>;
  courses_some?: Maybe<CourseWhereInput>;
  courses_none?: Maybe<CourseWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<TeacherWhereInput[] | TeacherWhereInput>;
  OR?: Maybe<TeacherWhereInput[] | TeacherWhereInput>;
  NOT?: Maybe<TeacherWhereInput[] | TeacherWhereInput>;
}

export interface CourseInstanceUpdateManyDataInput {
  date?: Maybe<DateTimeInput>;
  topic?: Maybe<String>;
  notes?: Maybe<String>;
  recapUrl?: Maybe<String>;
  isCancelled?: Maybe<Boolean>;
}

export type CourseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CourseUpsertWithoutMembershipsInput {
  update: CourseUpdateWithoutMembershipsDataInput;
  create: CourseCreateWithoutMembershipsInput;
}

export interface CardWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  student?: Maybe<StudentWhereInput>;
  payment?: Maybe<PaymentWhereInput>;
  expirationDate?: Maybe<DateTimeInput>;
  expirationDate_not?: Maybe<DateTimeInput>;
  expirationDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expirationDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expirationDate_lt?: Maybe<DateTimeInput>;
  expirationDate_lte?: Maybe<DateTimeInput>;
  expirationDate_gt?: Maybe<DateTimeInput>;
  expirationDate_gte?: Maybe<DateTimeInput>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  paid?: Maybe<Boolean>;
  paid_not?: Maybe<Boolean>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  originalValue?: Maybe<Int>;
  originalValue_not?: Maybe<Int>;
  originalValue_in?: Maybe<Int[] | Int>;
  originalValue_not_in?: Maybe<Int[] | Int>;
  originalValue_lt?: Maybe<Int>;
  originalValue_lte?: Maybe<Int>;
  originalValue_gt?: Maybe<Int>;
  originalValue_gte?: Maybe<Int>;
  participationHistory_every?: Maybe<ParticipantWhereInput>;
  participationHistory_some?: Maybe<ParticipantWhereInput>;
  participationHistory_none?: Maybe<ParticipantWhereInput>;
  privateLessonLength?: Maybe<Int>;
  privateLessonLength_not?: Maybe<Int>;
  privateLessonLength_in?: Maybe<Int[] | Int>;
  privateLessonLength_not_in?: Maybe<Int[] | Int>;
  privateLessonLength_lt?: Maybe<Int>;
  privateLessonLength_lte?: Maybe<Int>;
  privateLessonLength_gt?: Maybe<Int>;
  privateLessonLength_gte?: Maybe<Int>;
  privateLessonUseDate?: Maybe<DateTimeInput>;
  privateLessonUseDate_not?: Maybe<DateTimeInput>;
  privateLessonUseDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  privateLessonUseDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  privateLessonUseDate_lt?: Maybe<DateTimeInput>;
  privateLessonUseDate_lte?: Maybe<DateTimeInput>;
  privateLessonUseDate_gt?: Maybe<DateTimeInput>;
  privateLessonUseDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CardWhereInput[] | CardWhereInput>;
  OR?: Maybe<CardWhereInput[] | CardWhereInput>;
  NOT?: Maybe<CardWhereInput[] | CardWhereInput>;
}

export interface MembershipUpsertWithWhereUniqueWithoutStudentInput {
  where: MembershipWhereUniqueInput;
  update: MembershipUpdateWithoutStudentDataInput;
  create: MembershipCreateWithoutStudentInput;
}

export interface RoomUpsertWithWhereUniqueWithoutStudioInput {
  where: RoomWhereUniqueInput;
  update: RoomUpdateWithoutStudioDataInput;
  create: RoomCreateWithoutStudioInput;
}

export interface StudentUpsertWithoutCardsInput {
  update: StudentUpdateWithoutCardsDataInput;
  create: StudentCreateWithoutCardsInput;
}

export interface PaymentUpdateManyMutationInput {
  type?: Maybe<PaymentType>;
  date?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
}

export interface CardUpdateManyMutationInput {
  expirationDate?: Maybe<DateTimeInput>;
  active?: Maybe<Boolean>;
  paid?: Maybe<Boolean>;
  value?: Maybe<Int>;
  originalValue?: Maybe<Int>;
  privateLessonLength?: Maybe<Int>;
  privateLessonUseDate?: Maybe<DateTimeInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface CourseAbsenceUpdateManyMutationInput {
  date?: Maybe<DateTimeInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email?: Maybe<String>;
  password: String;
  student?: Maybe<StudentCreateOneWithoutUserInput>;
  admin?: Maybe<Boolean>;
}

export interface CourseUpsertWithoutAbsencesInput {
  update: CourseUpdateWithoutAbsencesDataInput;
  create: CourseCreateWithoutAbsencesInput;
}

export interface StudentCreateWithoutMembershipsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  mobile?: Maybe<String>;
  cards?: Maybe<CardCreateManyWithoutStudentInput>;
  hasReferralBonus?: Maybe<Boolean>;
  payments?: Maybe<PaymentCreateManyWithoutStudentInput>;
  user?: Maybe<UserCreateOneWithoutStudentInput>;
}

export interface CourseCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startTime?: Maybe<String>;
  day?: Maybe<CourseDay>;
  duration?: Maybe<Int>;
  teachers?: Maybe<TeacherCreateManyWithoutCoursesInput>;
  memberships?: Maybe<MembershipCreateManyWithoutCourseInput>;
  instances?: Maybe<CourseInstanceCreateManyWithoutCourseInput>;
  studentLimit?: Maybe<Int>;
  room?: Maybe<RoomCreateOneInput>;
  absences?: Maybe<CourseAbsenceCreateManyWithoutCourseInput>;
}

export interface ParticipantSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ParticipantWhereInput>;
  AND?: Maybe<
    ParticipantSubscriptionWhereInput[] | ParticipantSubscriptionWhereInput
  >;
  OR?: Maybe<
    ParticipantSubscriptionWhereInput[] | ParticipantSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ParticipantSubscriptionWhereInput[] | ParticipantSubscriptionWhereInput
  >;
}

export interface CourseUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startTime?: Maybe<String>;
  day?: Maybe<CourseDay>;
  duration?: Maybe<Int>;
  teachers?: Maybe<TeacherUpdateManyWithoutCoursesInput>;
  memberships?: Maybe<MembershipUpdateManyWithoutCourseInput>;
  instances?: Maybe<CourseInstanceUpdateManyWithoutCourseInput>;
  studentLimit?: Maybe<Int>;
  room?: Maybe<RoomUpdateOneInput>;
  absences?: Maybe<CourseAbsenceUpdateManyWithoutCourseInput>;
}

export interface TeacherCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  mobile?: Maybe<String>;
  courses?: Maybe<CourseCreateManyWithoutTeachersInput>;
  user?: Maybe<UserCreateOneInput>;
}

export interface CourseUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startTime?: Maybe<String>;
  day?: Maybe<CourseDay>;
  duration?: Maybe<Int>;
  studentLimit?: Maybe<Int>;
}

export interface MembershipUpdateInput {
  student?: Maybe<StudentUpdateOneRequiredWithoutMembershipsInput>;
  course?: Maybe<CourseUpdateOneRequiredWithoutMembershipsInput>;
  role?: Maybe<DanceRole>;
  status?: Maybe<MembershipStatus>;
  waitlistDate?: Maybe<DateTimeInput>;
}

export interface CourseAbsenceCreateInput {
  id?: Maybe<ID_Input>;
  date: DateTimeInput;
  student: StudentCreateOneInput;
  course: CourseCreateOneWithoutAbsencesInput;
}

export interface StudentCreateWithoutPaymentsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  mobile?: Maybe<String>;
  memberships?: Maybe<MembershipCreateManyWithoutStudentInput>;
  cards?: Maybe<CardCreateManyWithoutStudentInput>;
  hasReferralBonus?: Maybe<Boolean>;
  user?: Maybe<UserCreateOneWithoutStudentInput>;
}

export interface CourseUpdateOneRequiredWithoutAbsencesInput {
  create?: Maybe<CourseCreateWithoutAbsencesInput>;
  update?: Maybe<CourseUpdateWithoutAbsencesDataInput>;
  upsert?: Maybe<CourseUpsertWithoutAbsencesInput>;
  connect?: Maybe<CourseWhereUniqueInput>;
}

export interface CourseAbsenceUpdateInput {
  date?: Maybe<DateTimeInput>;
  student?: Maybe<StudentUpdateOneRequiredInput>;
  course?: Maybe<CourseUpdateOneRequiredWithoutAbsencesInput>;
}

export interface CourseCreateWithoutAbsencesInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startTime?: Maybe<String>;
  day?: Maybe<CourseDay>;
  duration?: Maybe<Int>;
  teachers?: Maybe<TeacherCreateManyWithoutCoursesInput>;
  memberships?: Maybe<MembershipCreateManyWithoutCourseInput>;
  instances?: Maybe<CourseInstanceCreateManyWithoutCourseInput>;
  studentLimit?: Maybe<Int>;
  room?: Maybe<RoomCreateOneInput>;
}

export interface CourseCreateOneWithoutAbsencesInput {
  create?: Maybe<CourseCreateWithoutAbsencesInput>;
  connect?: Maybe<CourseWhereUniqueInput>;
}

export interface CourseCreateWithoutInstancesInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startTime?: Maybe<String>;
  day?: Maybe<CourseDay>;
  duration?: Maybe<Int>;
  teachers?: Maybe<TeacherCreateManyWithoutCoursesInput>;
  memberships?: Maybe<MembershipCreateManyWithoutCourseInput>;
  studentLimit?: Maybe<Int>;
  room?: Maybe<RoomCreateOneInput>;
  absences?: Maybe<CourseAbsenceCreateManyWithoutCourseInput>;
}

export interface StudentCreateWithoutCardsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  mobile?: Maybe<String>;
  memberships?: Maybe<MembershipCreateManyWithoutStudentInput>;
  hasReferralBonus?: Maybe<Boolean>;
  payments?: Maybe<PaymentCreateManyWithoutStudentInput>;
  user?: Maybe<UserCreateOneWithoutStudentInput>;
}

export interface RoomCreateManyWithoutStudioInput {
  create?: Maybe<RoomCreateWithoutStudioInput[] | RoomCreateWithoutStudioInput>;
  connect?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
}

export type CourseInstanceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  email?: String;
  password: String;
  admin: Boolean;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  admin: () => Promise<Boolean>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  admin: () => Promise<AsyncIterator<Boolean>>;
}

export interface CourseAbsenceConnection {
  pageInfo: PageInfo;
  edges: CourseAbsenceEdge[];
}

export interface CourseAbsenceConnectionPromise
  extends Promise<CourseAbsenceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CourseAbsenceEdge>>() => T;
  aggregate: <T = AggregateCourseAbsencePromise>() => T;
}

export interface CourseAbsenceConnectionSubscription
  extends Promise<AsyncIterator<CourseAbsenceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CourseAbsenceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCourseAbsenceSubscription>() => T;
}

export interface Membership {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  role: DanceRole;
  status?: MembershipStatus;
  waitlistDate?: DateTimeOutput;
}

export interface MembershipPromise extends Promise<Membership>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  student: <T = StudentPromise>() => T;
  course: <T = CoursePromise>() => T;
  role: () => Promise<DanceRole>;
  status: () => Promise<MembershipStatus>;
  waitlistDate: () => Promise<DateTimeOutput>;
}

export interface MembershipSubscription
  extends Promise<AsyncIterator<Membership>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  student: <T = StudentSubscription>() => T;
  course: <T = CourseSubscription>() => T;
  role: () => Promise<AsyncIterator<DanceRole>>;
  status: () => Promise<AsyncIterator<MembershipStatus>>;
  waitlistDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MembershipNullablePromise
  extends Promise<Membership | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  student: <T = StudentPromise>() => T;
  course: <T = CoursePromise>() => T;
  role: () => Promise<DanceRole>;
  status: () => Promise<MembershipStatus>;
  waitlistDate: () => Promise<DateTimeOutput>;
}

export interface AggregateCourse {
  count: Int;
}

export interface AggregateCoursePromise
  extends Promise<AggregateCourse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCourseSubscription
  extends Promise<AsyncIterator<AggregateCourse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Course {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  name: String;
  description?: String;
  startDate?: DateTimeOutput;
  startTime?: String;
  day?: CourseDay;
  duration?: Int;
  studentLimit?: Int;
}

export interface CoursePromise extends Promise<Course>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  startTime: () => Promise<String>;
  day: () => Promise<CourseDay>;
  duration: () => Promise<Int>;
  teachers: <T = FragmentableArray<Teacher>>(args?: {
    where?: TeacherWhereInput;
    orderBy?: TeacherOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  memberships: <T = FragmentableArray<Membership>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  instances: <T = FragmentableArray<CourseInstance>>(args?: {
    where?: CourseInstanceWhereInput;
    orderBy?: CourseInstanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studentLimit: () => Promise<Int>;
  room: <T = RoomPromise>() => T;
  absences: <T = FragmentableArray<CourseAbsence>>(args?: {
    where?: CourseAbsenceWhereInput;
    orderBy?: CourseAbsenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CourseSubscription
  extends Promise<AsyncIterator<Course>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  startTime: () => Promise<AsyncIterator<String>>;
  day: () => Promise<AsyncIterator<CourseDay>>;
  duration: () => Promise<AsyncIterator<Int>>;
  teachers: <T = Promise<AsyncIterator<TeacherSubscription>>>(args?: {
    where?: TeacherWhereInput;
    orderBy?: TeacherOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  memberships: <T = Promise<AsyncIterator<MembershipSubscription>>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  instances: <T = Promise<AsyncIterator<CourseInstanceSubscription>>>(args?: {
    where?: CourseInstanceWhereInput;
    orderBy?: CourseInstanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studentLimit: () => Promise<AsyncIterator<Int>>;
  room: <T = RoomSubscription>() => T;
  absences: <T = Promise<AsyncIterator<CourseAbsenceSubscription>>>(args?: {
    where?: CourseAbsenceWhereInput;
    orderBy?: CourseAbsenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CourseNullablePromise
  extends Promise<Course | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  startTime: () => Promise<String>;
  day: () => Promise<CourseDay>;
  duration: () => Promise<Int>;
  teachers: <T = FragmentableArray<Teacher>>(args?: {
    where?: TeacherWhereInput;
    orderBy?: TeacherOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  memberships: <T = FragmentableArray<Membership>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  instances: <T = FragmentableArray<CourseInstance>>(args?: {
    where?: CourseInstanceWhereInput;
    orderBy?: CourseInstanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studentLimit: () => Promise<Int>;
  room: <T = RoomPromise>() => T;
  absences: <T = FragmentableArray<CourseAbsence>>(args?: {
    where?: CourseAbsenceWhereInput;
    orderBy?: CourseAbsenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CourseEdge {
  node: Course;
  cursor: String;
}

export interface CourseEdgePromise extends Promise<CourseEdge>, Fragmentable {
  node: <T = CoursePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CourseEdgeSubscription
  extends Promise<AsyncIterator<CourseEdge>>,
    Fragmentable {
  node: <T = CourseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CourseConnection {
  pageInfo: PageInfo;
  edges: CourseEdge[];
}

export interface CourseConnectionPromise
  extends Promise<CourseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CourseEdge>>() => T;
  aggregate: <T = AggregateCoursePromise>() => T;
}

export interface CourseConnectionSubscription
  extends Promise<AsyncIterator<CourseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CourseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCourseSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Card {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  expirationDate?: DateTimeOutput;
  active: Boolean;
  paid: Boolean;
  value: Int;
  originalValue: Int;
  privateLessonLength: Int;
  privateLessonUseDate?: DateTimeOutput;
}

export interface CardPromise extends Promise<Card>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  student: <T = StudentPromise>() => T;
  payment: <T = PaymentPromise>() => T;
  expirationDate: () => Promise<DateTimeOutput>;
  active: () => Promise<Boolean>;
  paid: () => Promise<Boolean>;
  value: () => Promise<Int>;
  originalValue: () => Promise<Int>;
  participationHistory: <T = FragmentableArray<Participant>>(args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  privateLessonLength: () => Promise<Int>;
  privateLessonUseDate: () => Promise<DateTimeOutput>;
}

export interface CardSubscription
  extends Promise<AsyncIterator<Card>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  student: <T = StudentSubscription>() => T;
  payment: <T = PaymentSubscription>() => T;
  expirationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  paid: () => Promise<AsyncIterator<Boolean>>;
  value: () => Promise<AsyncIterator<Int>>;
  originalValue: () => Promise<AsyncIterator<Int>>;
  participationHistory: <
    T = Promise<AsyncIterator<ParticipantSubscription>>
  >(args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  privateLessonLength: () => Promise<AsyncIterator<Int>>;
  privateLessonUseDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CardNullablePromise
  extends Promise<Card | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  student: <T = StudentPromise>() => T;
  payment: <T = PaymentPromise>() => T;
  expirationDate: () => Promise<DateTimeOutput>;
  active: () => Promise<Boolean>;
  paid: () => Promise<Boolean>;
  value: () => Promise<Int>;
  originalValue: () => Promise<Int>;
  participationHistory: <T = FragmentableArray<Participant>>(args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  privateLessonLength: () => Promise<Int>;
  privateLessonUseDate: () => Promise<DateTimeOutput>;
}

export interface AggregateTeacher {
  count: Int;
}

export interface AggregateTeacherPromise
  extends Promise<AggregateTeacher>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTeacherSubscription
  extends Promise<AsyncIterator<AggregateTeacher>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CardSubscriptionPayload {
  mutation: MutationType;
  node: Card;
  updatedFields: String[];
  previousValues: CardPreviousValues;
}

export interface CardSubscriptionPayloadPromise
  extends Promise<CardSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CardPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CardPreviousValuesPromise>() => T;
}

export interface CardSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CardSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CardSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CardPreviousValuesSubscription>() => T;
}

export interface TeacherConnection {
  pageInfo: PageInfo;
  edges: TeacherEdge[];
}

export interface TeacherConnectionPromise
  extends Promise<TeacherConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TeacherEdge>>() => T;
  aggregate: <T = AggregateTeacherPromise>() => T;
}

export interface TeacherConnectionSubscription
  extends Promise<AsyncIterator<TeacherConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TeacherEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTeacherSubscription>() => T;
}

export interface CardPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  expirationDate?: DateTimeOutput;
  active: Boolean;
  paid: Boolean;
  value: Int;
  originalValue: Int;
  privateLessonLength: Int;
  privateLessonUseDate?: DateTimeOutput;
}

export interface CardPreviousValuesPromise
  extends Promise<CardPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  expirationDate: () => Promise<DateTimeOutput>;
  active: () => Promise<Boolean>;
  paid: () => Promise<Boolean>;
  value: () => Promise<Int>;
  originalValue: () => Promise<Int>;
  privateLessonLength: () => Promise<Int>;
  privateLessonUseDate: () => Promise<DateTimeOutput>;
}

export interface CardPreviousValuesSubscription
  extends Promise<AsyncIterator<CardPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  expirationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  paid: () => Promise<AsyncIterator<Boolean>>;
  value: () => Promise<AsyncIterator<Int>>;
  originalValue: () => Promise<AsyncIterator<Int>>;
  privateLessonLength: () => Promise<AsyncIterator<Int>>;
  privateLessonUseDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StudioEdge {
  node: Studio;
  cursor: String;
}

export interface StudioEdgePromise extends Promise<StudioEdge>, Fragmentable {
  node: <T = StudioPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudioEdgeSubscription
  extends Promise<AsyncIterator<StudioEdge>>,
    Fragmentable {
  node: <T = StudioSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCard {
  count: Int;
}

export interface AggregateCardPromise
  extends Promise<AggregateCard>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCardSubscription
  extends Promise<AsyncIterator<AggregateCard>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Student {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  name: String;
  email: String;
  mobile?: String;
  hasReferralBonus: Boolean;
}

export interface StudentPromise extends Promise<Student>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  mobile: () => Promise<String>;
  memberships: <T = FragmentableArray<Membership>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cards: <T = FragmentableArray<Card>>(args?: {
    where?: CardWhereInput;
    orderBy?: CardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hasReferralBonus: () => Promise<Boolean>;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserPromise>() => T;
}

export interface StudentSubscription
  extends Promise<AsyncIterator<Student>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  memberships: <T = Promise<AsyncIterator<MembershipSubscription>>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cards: <T = Promise<AsyncIterator<CardSubscription>>>(args?: {
    where?: CardWhereInput;
    orderBy?: CardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hasReferralBonus: () => Promise<AsyncIterator<Boolean>>;
  payments: <T = Promise<AsyncIterator<PaymentSubscription>>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserSubscription>() => T;
}

export interface StudentNullablePromise
  extends Promise<Student | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  mobile: () => Promise<String>;
  memberships: <T = FragmentableArray<Membership>>(args?: {
    where?: MembershipWhereInput;
    orderBy?: MembershipOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cards: <T = FragmentableArray<Card>>(args?: {
    where?: CardWhereInput;
    orderBy?: CardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hasReferralBonus: () => Promise<Boolean>;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserPromise>() => T;
}

export interface CourseSubscriptionPayload {
  mutation: MutationType;
  node: Course;
  updatedFields: String[];
  previousValues: CoursePreviousValues;
}

export interface CourseSubscriptionPayloadPromise
  extends Promise<CourseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CoursePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CoursePreviousValuesPromise>() => T;
}

export interface CourseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CourseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CourseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CoursePreviousValuesSubscription>() => T;
}

export interface StudentEdge {
  node: Student;
  cursor: String;
}

export interface StudentEdgePromise extends Promise<StudentEdge>, Fragmentable {
  node: <T = StudentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentEdgeSubscription
  extends Promise<AsyncIterator<StudentEdge>>,
    Fragmentable {
  node: <T = StudentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudent {
  count: Int;
}

export interface AggregateStudentPromise
  extends Promise<AggregateStudent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentSubscription
  extends Promise<AsyncIterator<AggregateStudent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  email?: String;
  password: String;
  admin: Boolean;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  student: <T = StudentPromise>() => T;
  admin: () => Promise<Boolean>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  student: <T = StudentSubscription>() => T;
  admin: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  student: <T = StudentPromise>() => T;
  admin: () => Promise<Boolean>;
}

export interface StudentConnection {
  pageInfo: PageInfo;
  edges: StudentEdge[];
}

export interface StudentConnectionPromise
  extends Promise<StudentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentEdge>>() => T;
  aggregate: <T = AggregateStudentPromise>() => T;
}

export interface StudentConnectionSubscription
  extends Promise<AsyncIterator<StudentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentSubscription>() => T;
}

export interface CoursePreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  name: String;
  description?: String;
  startDate?: DateTimeOutput;
  startTime?: String;
  day?: CourseDay;
  duration?: Int;
  studentLimit?: Int;
}

export interface CoursePreviousValuesPromise
  extends Promise<CoursePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  startTime: () => Promise<String>;
  day: () => Promise<CourseDay>;
  duration: () => Promise<Int>;
  studentLimit: () => Promise<Int>;
}

export interface CoursePreviousValuesSubscription
  extends Promise<AsyncIterator<CoursePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  startTime: () => Promise<AsyncIterator<String>>;
  day: () => Promise<AsyncIterator<CourseDay>>;
  duration: () => Promise<AsyncIterator<Int>>;
  studentLimit: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateRoom {
  count: Int;
}

export interface AggregateRoomPromise
  extends Promise<AggregateRoom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoomSubscription
  extends Promise<AsyncIterator<AggregateRoom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoomConnection {
  pageInfo: PageInfo;
  edges: RoomEdge[];
}

export interface RoomConnectionPromise
  extends Promise<RoomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoomEdge>>() => T;
  aggregate: <T = AggregateRoomPromise>() => T;
}

export interface RoomConnectionSubscription
  extends Promise<AsyncIterator<RoomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoomSubscription>() => T;
}

export interface CardEdge {
  node: Card;
  cursor: String;
}

export interface CardEdgePromise extends Promise<CardEdge>, Fragmentable {
  node: <T = CardPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CardEdgeSubscription
  extends Promise<AsyncIterator<CardEdge>>,
    Fragmentable {
  node: <T = CardSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaymentEdge {
  node: Payment;
  cursor: String;
}

export interface PaymentEdgePromise extends Promise<PaymentEdge>, Fragmentable {
  node: <T = PaymentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdge>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CourseAbsenceSubscriptionPayload {
  mutation: MutationType;
  node: CourseAbsence;
  updatedFields: String[];
  previousValues: CourseAbsencePreviousValues;
}

export interface CourseAbsenceSubscriptionPayloadPromise
  extends Promise<CourseAbsenceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CourseAbsencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CourseAbsencePreviousValuesPromise>() => T;
}

export interface CourseAbsenceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CourseAbsenceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CourseAbsenceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CourseAbsencePreviousValuesSubscription>() => T;
}

export interface AggregateParticipant {
  count: Int;
}

export interface AggregateParticipantPromise
  extends Promise<AggregateParticipant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParticipantSubscription
  extends Promise<AsyncIterator<AggregateParticipant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CourseAbsencePreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  date: DateTimeOutput;
}

export interface CourseAbsencePreviousValuesPromise
  extends Promise<CourseAbsencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  date: () => Promise<DateTimeOutput>;
}

export interface CourseAbsencePreviousValuesSubscription
  extends Promise<AsyncIterator<CourseAbsencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ParticipantConnection {
  pageInfo: PageInfo;
  edges: ParticipantEdge[];
}

export interface ParticipantConnectionPromise
  extends Promise<ParticipantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParticipantEdge>>() => T;
  aggregate: <T = AggregateParticipantPromise>() => T;
}

export interface ParticipantConnectionSubscription
  extends Promise<AsyncIterator<ParticipantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParticipantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParticipantSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface MembershipEdge {
  node: Membership;
  cursor: String;
}

export interface MembershipEdgePromise
  extends Promise<MembershipEdge>,
    Fragmentable {
  node: <T = MembershipPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MembershipEdgeSubscription
  extends Promise<AsyncIterator<MembershipEdge>>,
    Fragmentable {
  node: <T = MembershipSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CourseInstanceSubscriptionPayload {
  mutation: MutationType;
  node: CourseInstance;
  updatedFields: String[];
  previousValues: CourseInstancePreviousValues;
}

export interface CourseInstanceSubscriptionPayloadPromise
  extends Promise<CourseInstanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CourseInstancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CourseInstancePreviousValuesPromise>() => T;
}

export interface CourseInstanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CourseInstanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CourseInstanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CourseInstancePreviousValuesSubscription>() => T;
}

export interface AggregateMailgunEmailPayload {
  count: Int;
}

export interface AggregateMailgunEmailPayloadPromise
  extends Promise<AggregateMailgunEmailPayload>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMailgunEmailPayloadSubscription
  extends Promise<AsyncIterator<AggregateMailgunEmailPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CourseInstancePreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  date: DateTimeOutput;
  topic?: String;
  notes?: String;
  recapUrl?: String;
  isCancelled: Boolean;
}

export interface CourseInstancePreviousValuesPromise
  extends Promise<CourseInstancePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  date: () => Promise<DateTimeOutput>;
  topic: () => Promise<String>;
  notes: () => Promise<String>;
  recapUrl: () => Promise<String>;
  isCancelled: () => Promise<Boolean>;
}

export interface CourseInstancePreviousValuesSubscription
  extends Promise<AsyncIterator<CourseInstancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  topic: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
  recapUrl: () => Promise<AsyncIterator<String>>;
  isCancelled: () => Promise<AsyncIterator<Boolean>>;
}

export interface MailgunEmailPayloadConnection {
  pageInfo: PageInfo;
  edges: MailgunEmailPayloadEdge[];
}

export interface MailgunEmailPayloadConnectionPromise
  extends Promise<MailgunEmailPayloadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MailgunEmailPayloadEdge>>() => T;
  aggregate: <T = AggregateMailgunEmailPayloadPromise>() => T;
}

export interface MailgunEmailPayloadConnectionSubscription
  extends Promise<AsyncIterator<MailgunEmailPayloadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<MailgunEmailPayloadEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateMailgunEmailPayloadSubscription>() => T;
}

export interface CardConnection {
  pageInfo: PageInfo;
  edges: CardEdge[];
}

export interface CardConnectionPromise
  extends Promise<CardConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CardEdge>>() => T;
  aggregate: <T = AggregateCardPromise>() => T;
}

export interface CardConnectionSubscription
  extends Promise<AsyncIterator<CardConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CardEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCardSubscription>() => T;
}

export interface AggregateLoginResponse {
  count: Int;
}

export interface AggregateLoginResponsePromise
  extends Promise<AggregateLoginResponse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLoginResponseSubscription
  extends Promise<AsyncIterator<AggregateLoginResponse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExpenseSubscriptionPayload {
  mutation: MutationType;
  node: Expense;
  updatedFields: String[];
  previousValues: ExpensePreviousValues;
}

export interface ExpenseSubscriptionPayloadPromise
  extends Promise<ExpenseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExpensePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExpensePreviousValuesPromise>() => T;
}

export interface ExpenseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExpenseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExpenseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExpensePreviousValuesSubscription>() => T;
}

export interface LoginResponseConnection {
  pageInfo: PageInfo;
  edges: LoginResponseEdge[];
}

export interface LoginResponseConnectionPromise
  extends Promise<LoginResponseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LoginResponseEdge>>() => T;
  aggregate: <T = AggregateLoginResponsePromise>() => T;
}

export interface LoginResponseConnectionSubscription
  extends Promise<AsyncIterator<LoginResponseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LoginResponseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLoginResponseSubscription>() => T;
}

export interface ExpensePreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  type: ExpenseType;
  date: DateTimeOutput;
  amount: Int;
  note?: String;
}

export interface ExpensePreviousValuesPromise
  extends Promise<ExpensePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<ExpenseType>;
  date: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  note: () => Promise<String>;
}

export interface ExpensePreviousValuesSubscription
  extends Promise<AsyncIterator<ExpensePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<ExpenseType>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  note: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExpense {
  count: Int;
}

export interface AggregateExpensePromise
  extends Promise<AggregateExpense>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExpenseSubscription
  extends Promise<AsyncIterator<AggregateExpense>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Payment {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  type: PaymentType;
  date: DateTimeOutput;
  amount: Int;
}

export interface PaymentPromise extends Promise<Payment>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PaymentType>;
  date: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  student: <T = StudentPromise>() => T;
  card: <T = CardPromise>() => T;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<Payment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<PaymentType>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  student: <T = StudentSubscription>() => T;
  card: <T = CardSubscription>() => T;
}

export interface PaymentNullablePromise
  extends Promise<Payment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PaymentType>;
  date: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  student: <T = StudentPromise>() => T;
  card: <T = CardPromise>() => T;
}

export interface ExpenseConnection {
  pageInfo: PageInfo;
  edges: ExpenseEdge[];
}

export interface ExpenseConnectionPromise
  extends Promise<ExpenseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExpenseEdge>>() => T;
  aggregate: <T = AggregateExpensePromise>() => T;
}

export interface ExpenseConnectionSubscription
  extends Promise<AsyncIterator<ExpenseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExpenseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExpenseSubscription>() => T;
}

export interface LoginResponseSubscriptionPayload {
  mutation: MutationType;
  node: LoginResponse;
  updatedFields: String[];
  previousValues: LoginResponsePreviousValues;
}

export interface LoginResponseSubscriptionPayloadPromise
  extends Promise<LoginResponseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LoginResponsePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LoginResponsePreviousValuesPromise>() => T;
}

export interface LoginResponseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LoginResponseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LoginResponseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LoginResponsePreviousValuesSubscription>() => T;
}

export interface AggregateCourseInstance {
  count: Int;
}

export interface AggregateCourseInstancePromise
  extends Promise<AggregateCourseInstance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCourseInstanceSubscription
  extends Promise<AsyncIterator<AggregateCourseInstance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LoginResponsePreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  token?: String;
}

export interface LoginResponsePreviousValuesPromise
  extends Promise<LoginResponsePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  token: () => Promise<String>;
}

export interface LoginResponsePreviousValuesSubscription
  extends Promise<AsyncIterator<LoginResponsePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  token: () => Promise<AsyncIterator<String>>;
}

export interface CourseInstanceConnection {
  pageInfo: PageInfo;
  edges: CourseInstanceEdge[];
}

export interface CourseInstanceConnectionPromise
  extends Promise<CourseInstanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CourseInstanceEdge>>() => T;
  aggregate: <T = AggregateCourseInstancePromise>() => T;
}

export interface CourseInstanceConnectionSubscription
  extends Promise<AsyncIterator<CourseInstanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CourseInstanceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCourseInstanceSubscription>() => T;
}

export interface TeacherPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  name: String;
  email: String;
  mobile?: String;
}

export interface TeacherPreviousValuesPromise
  extends Promise<TeacherPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  mobile: () => Promise<String>;
}

export interface TeacherPreviousValuesSubscription
  extends Promise<AsyncIterator<TeacherPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
}

export interface CourseAbsenceEdge {
  node: CourseAbsence;
  cursor: String;
}

export interface CourseAbsenceEdgePromise
  extends Promise<CourseAbsenceEdge>,
    Fragmentable {
  node: <T = CourseAbsencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CourseAbsenceEdgeSubscription
  extends Promise<AsyncIterator<CourseAbsenceEdge>>,
    Fragmentable {
  node: <T = CourseAbsenceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MailgunEmailPayloadSubscriptionPayload {
  mutation: MutationType;
  node: MailgunEmailPayload;
  updatedFields: String[];
  previousValues: MailgunEmailPayloadPreviousValues;
}

export interface MailgunEmailPayloadSubscriptionPayloadPromise
  extends Promise<MailgunEmailPayloadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MailgunEmailPayloadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MailgunEmailPayloadPreviousValuesPromise>() => T;
}

export interface MailgunEmailPayloadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MailgunEmailPayloadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MailgunEmailPayloadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MailgunEmailPayloadPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface MailgunEmailPayloadPreviousValues {
  id: ID_Output;
  success: Boolean;
}

export interface MailgunEmailPayloadPreviousValuesPromise
  extends Promise<MailgunEmailPayloadPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  success: () => Promise<Boolean>;
}

export interface MailgunEmailPayloadPreviousValuesSubscription
  extends Promise<AsyncIterator<MailgunEmailPayloadPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  success: () => Promise<AsyncIterator<Boolean>>;
}

export interface Teacher {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  name: String;
  email: String;
  mobile?: String;
}

export interface TeacherPromise extends Promise<Teacher>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  mobile: () => Promise<String>;
  courses: <T = FragmentableArray<Course>>(args?: {
    where?: CourseWhereInput;
    orderBy?: CourseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserPromise>() => T;
}

export interface TeacherSubscription
  extends Promise<AsyncIterator<Teacher>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  courses: <T = Promise<AsyncIterator<CourseSubscription>>>(args?: {
    where?: CourseWhereInput;
    orderBy?: CourseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserSubscription>() => T;
}

export interface TeacherNullablePromise
  extends Promise<Teacher | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  mobile: () => Promise<String>;
  courses: <T = FragmentableArray<Course>>(args?: {
    where?: CourseWhereInput;
    orderBy?: CourseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserPromise>() => T;
}

export interface TeacherSubscriptionPayload {
  mutation: MutationType;
  node: Teacher;
  updatedFields: String[];
  previousValues: TeacherPreviousValues;
}

export interface TeacherSubscriptionPayloadPromise
  extends Promise<TeacherSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TeacherPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeacherPreviousValuesPromise>() => T;
}

export interface TeacherSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeacherSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeacherSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeacherPreviousValuesSubscription>() => T;
}

export interface AggregateStudio {
  count: Int;
}

export interface AggregateStudioPromise
  extends Promise<AggregateStudio>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudioSubscription
  extends Promise<AsyncIterator<AggregateStudio>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MembershipSubscriptionPayload {
  mutation: MutationType;
  node: Membership;
  updatedFields: String[];
  previousValues: MembershipPreviousValues;
}

export interface MembershipSubscriptionPayloadPromise
  extends Promise<MembershipSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MembershipPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MembershipPreviousValuesPromise>() => T;
}

export interface MembershipSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MembershipSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MembershipSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MembershipPreviousValuesSubscription>() => T;
}

export interface RoomEdge {
  node: Room;
  cursor: String;
}

export interface RoomEdgePromise extends Promise<RoomEdge>, Fragmentable {
  node: <T = RoomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoomEdgeSubscription
  extends Promise<AsyncIterator<RoomEdge>>,
    Fragmentable {
  node: <T = RoomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MembershipPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  role: DanceRole;
  status?: MembershipStatus;
  waitlistDate?: DateTimeOutput;
}

export interface MembershipPreviousValuesPromise
  extends Promise<MembershipPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  role: () => Promise<DanceRole>;
  status: () => Promise<MembershipStatus>;
  waitlistDate: () => Promise<DateTimeOutput>;
}

export interface MembershipPreviousValuesSubscription
  extends Promise<AsyncIterator<MembershipPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  role: () => Promise<AsyncIterator<DanceRole>>;
  status: () => Promise<AsyncIterator<MembershipStatus>>;
  waitlistDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PaymentConnection {
  pageInfo: PageInfo;
  edges: PaymentEdge[];
}

export interface PaymentConnectionPromise
  extends Promise<PaymentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentEdge>>() => T;
  aggregate: <T = AggregatePaymentPromise>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export interface CourseAbsence {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  date: DateTimeOutput;
}

export interface CourseAbsencePromise
  extends Promise<CourseAbsence>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  date: () => Promise<DateTimeOutput>;
  student: <T = StudentPromise>() => T;
  course: <T = CoursePromise>() => T;
}

export interface CourseAbsenceSubscription
  extends Promise<AsyncIterator<CourseAbsence>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  student: <T = StudentSubscription>() => T;
  course: <T = CourseSubscription>() => T;
}

export interface CourseAbsenceNullablePromise
  extends Promise<CourseAbsence | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  date: () => Promise<DateTimeOutput>;
  student: <T = StudentPromise>() => T;
  course: <T = CoursePromise>() => T;
}

export interface AggregateMembership {
  count: Int;
}

export interface AggregateMembershipPromise
  extends Promise<AggregateMembership>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMembershipSubscription
  extends Promise<AsyncIterator<AggregateMembership>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ParticipantSubscriptionPayload {
  mutation: MutationType;
  node: Participant;
  updatedFields: String[];
  previousValues: ParticipantPreviousValues;
}

export interface ParticipantSubscriptionPayloadPromise
  extends Promise<ParticipantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParticipantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParticipantPreviousValuesPromise>() => T;
}

export interface ParticipantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParticipantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParticipantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParticipantPreviousValuesSubscription>() => T;
}

export interface MailgunEmailPayloadEdge {
  node: MailgunEmailPayload;
  cursor: String;
}

export interface MailgunEmailPayloadEdgePromise
  extends Promise<MailgunEmailPayloadEdge>,
    Fragmentable {
  node: <T = MailgunEmailPayloadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MailgunEmailPayloadEdgeSubscription
  extends Promise<AsyncIterator<MailgunEmailPayloadEdge>>,
    Fragmentable {
  node: <T = MailgunEmailPayloadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ParticipantPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  status?: ParticipantStatus;
}

export interface ParticipantPreviousValuesPromise
  extends Promise<ParticipantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  status: () => Promise<ParticipantStatus>;
}

export interface ParticipantPreviousValuesSubscription
  extends Promise<AsyncIterator<ParticipantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<ParticipantStatus>>;
}

export interface LoginResponseEdge {
  node: LoginResponse;
  cursor: String;
}

export interface LoginResponseEdgePromise
  extends Promise<LoginResponseEdge>,
    Fragmentable {
  node: <T = LoginResponsePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LoginResponseEdgeSubscription
  extends Promise<AsyncIterator<LoginResponseEdge>>,
    Fragmentable {
  node: <T = LoginResponseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Studio {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  name?: String;
  address?: String;
}

export interface StudioPromise extends Promise<Studio>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  rooms: <T = FragmentableArray<Room>>(args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  address: () => Promise<String>;
}

export interface StudioSubscription
  extends Promise<AsyncIterator<Studio>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  rooms: <T = Promise<AsyncIterator<RoomSubscription>>>(args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  address: () => Promise<AsyncIterator<String>>;
}

export interface StudioNullablePromise
  extends Promise<Studio | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  rooms: <T = FragmentableArray<Room>>(args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  address: () => Promise<String>;
}

export interface ExpenseEdge {
  node: Expense;
  cursor: String;
}

export interface ExpenseEdgePromise extends Promise<ExpenseEdge>, Fragmentable {
  node: <T = ExpensePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExpenseEdgeSubscription
  extends Promise<AsyncIterator<ExpenseEdge>>,
    Fragmentable {
  node: <T = ExpenseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaymentSubscriptionPayload {
  mutation: MutationType;
  node: Payment;
  updatedFields: String[];
  previousValues: PaymentPreviousValues;
}

export interface PaymentSubscriptionPayloadPromise
  extends Promise<PaymentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValuesPromise>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface CourseInstanceEdge {
  node: CourseInstance;
  cursor: String;
}

export interface CourseInstanceEdgePromise
  extends Promise<CourseInstanceEdge>,
    Fragmentable {
  node: <T = CourseInstancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CourseInstanceEdgeSubscription
  extends Promise<AsyncIterator<CourseInstanceEdge>>,
    Fragmentable {
  node: <T = CourseInstanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaymentPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  type: PaymentType;
  date: DateTimeOutput;
  amount: Int;
}

export interface PaymentPreviousValuesPromise
  extends Promise<PaymentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PaymentType>;
  date: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<PaymentType>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Room {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  name?: String;
  capacity?: Int;
}

export interface RoomPromise extends Promise<Room>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  capacity: () => Promise<Int>;
  studio: <T = StudioPromise>() => T;
}

export interface RoomSubscription
  extends Promise<AsyncIterator<Room>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  capacity: () => Promise<AsyncIterator<Int>>;
  studio: <T = StudioSubscription>() => T;
}

export interface RoomNullablePromise
  extends Promise<Room | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  capacity: () => Promise<Int>;
  studio: <T = StudioPromise>() => T;
}

export interface TeacherEdge {
  node: Teacher;
  cursor: String;
}

export interface TeacherEdgePromise extends Promise<TeacherEdge>, Fragmentable {
  node: <T = TeacherPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TeacherEdgeSubscription
  extends Promise<AsyncIterator<TeacherEdge>>,
    Fragmentable {
  node: <T = TeacherSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RoomSubscriptionPayload {
  mutation: MutationType;
  node: Room;
  updatedFields: String[];
  previousValues: RoomPreviousValues;
}

export interface RoomSubscriptionPayloadPromise
  extends Promise<RoomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoomPreviousValuesPromise>() => T;
}

export interface RoomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoomPreviousValuesSubscription>() => T;
}

export interface AggregatePayment {
  count: Int;
}

export interface AggregatePaymentPromise
  extends Promise<AggregatePayment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePayment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoomPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  name?: String;
  capacity?: Int;
}

export interface RoomPreviousValuesPromise
  extends Promise<RoomPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  capacity: () => Promise<Int>;
}

export interface RoomPreviousValuesSubscription
  extends Promise<AsyncIterator<RoomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  capacity: () => Promise<AsyncIterator<Int>>;
}

export interface MembershipConnection {
  pageInfo: PageInfo;
  edges: MembershipEdge[];
}

export interface MembershipConnectionPromise
  extends Promise<MembershipConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MembershipEdge>>() => T;
  aggregate: <T = AggregateMembershipPromise>() => T;
}

export interface MembershipConnectionSubscription
  extends Promise<AsyncIterator<MembershipConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MembershipEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMembershipSubscription>() => T;
}

export interface Participant {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  status?: ParticipantStatus;
}

export interface ParticipantPromise extends Promise<Participant>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  membership: <T = MembershipPromise>() => T;
  courseInstance: <T = CourseInstancePromise>() => T;
  status: () => Promise<ParticipantStatus>;
}

export interface ParticipantSubscription
  extends Promise<AsyncIterator<Participant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  membership: <T = MembershipSubscription>() => T;
  courseInstance: <T = CourseInstanceSubscription>() => T;
  status: () => Promise<AsyncIterator<ParticipantStatus>>;
}

export interface ParticipantNullablePromise
  extends Promise<Participant | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  membership: <T = MembershipPromise>() => T;
  courseInstance: <T = CourseInstancePromise>() => T;
  status: () => Promise<ParticipantStatus>;
}

export interface LoginResponse {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  token?: String;
}

export interface LoginResponsePromise
  extends Promise<LoginResponse>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  token: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface LoginResponseSubscription
  extends Promise<AsyncIterator<LoginResponse>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  token: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface LoginResponseNullablePromise
  extends Promise<LoginResponse | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  token: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface StudentSubscriptionPayload {
  mutation: MutationType;
  node: Student;
  updatedFields: String[];
  previousValues: StudentPreviousValues;
}

export interface StudentSubscriptionPayloadPromise
  extends Promise<StudentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentPreviousValuesPromise>() => T;
}

export interface StudentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentPreviousValuesSubscription>() => T;
}

export interface AggregateCourseAbsence {
  count: Int;
}

export interface AggregateCourseAbsencePromise
  extends Promise<AggregateCourseAbsence>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCourseAbsenceSubscription
  extends Promise<AsyncIterator<AggregateCourseAbsence>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudioConnection {
  pageInfo: PageInfo;
  edges: StudioEdge[];
}

export interface StudioConnectionPromise
  extends Promise<StudioConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudioEdge>>() => T;
  aggregate: <T = AggregateStudioPromise>() => T;
}

export interface StudioConnectionSubscription
  extends Promise<AsyncIterator<StudioConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudioEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudioSubscription>() => T;
}

export interface StudioPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  name?: String;
  address?: String;
}

export interface StudioPreviousValuesPromise
  extends Promise<StudioPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  address: () => Promise<String>;
}

export interface StudioPreviousValuesSubscription
  extends Promise<AsyncIterator<StudioPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
}

export interface StudioSubscriptionPayload {
  mutation: MutationType;
  node: Studio;
  updatedFields: String[];
  previousValues: StudioPreviousValues;
}

export interface StudioSubscriptionPayloadPromise
  extends Promise<StudioSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudioPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudioPreviousValuesPromise>() => T;
}

export interface StudioSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudioSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudioSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudioPreviousValuesSubscription>() => T;
}

export interface CourseInstance {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  date: DateTimeOutput;
  topic?: String;
  notes?: String;
  recapUrl?: String;
  isCancelled: Boolean;
}

export interface CourseInstancePromise
  extends Promise<CourseInstance>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  course: <T = CoursePromise>() => T;
  date: () => Promise<DateTimeOutput>;
  topic: () => Promise<String>;
  notes: () => Promise<String>;
  participants: <T = FragmentableArray<Participant>>(args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  recapUrl: () => Promise<String>;
  isCancelled: () => Promise<Boolean>;
}

export interface CourseInstanceSubscription
  extends Promise<AsyncIterator<CourseInstance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  course: <T = CourseSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  topic: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
  participants: <T = Promise<AsyncIterator<ParticipantSubscription>>>(args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  recapUrl: () => Promise<AsyncIterator<String>>;
  isCancelled: () => Promise<AsyncIterator<Boolean>>;
}

export interface CourseInstanceNullablePromise
  extends Promise<CourseInstance | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  course: <T = CoursePromise>() => T;
  date: () => Promise<DateTimeOutput>;
  topic: () => Promise<String>;
  notes: () => Promise<String>;
  participants: <T = FragmentableArray<Participant>>(args?: {
    where?: ParticipantWhereInput;
    orderBy?: ParticipantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  recapUrl: () => Promise<String>;
  isCancelled: () => Promise<Boolean>;
}

export interface StudentPreviousValues {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  name: String;
  email: String;
  mobile?: String;
  hasReferralBonus: Boolean;
}

export interface StudentPreviousValuesPromise
  extends Promise<StudentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  mobile: () => Promise<String>;
  hasReferralBonus: () => Promise<Boolean>;
}

export interface StudentPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  hasReferralBonus: () => Promise<AsyncIterator<Boolean>>;
}

export interface ParticipantEdge {
  node: Participant;
  cursor: String;
}

export interface ParticipantEdgePromise
  extends Promise<ParticipantEdge>,
    Fragmentable {
  node: <T = ParticipantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParticipantEdgeSubscription
  extends Promise<AsyncIterator<ParticipantEdge>>,
    Fragmentable {
  node: <T = ParticipantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Expense {
  id: ID_Output;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  type: ExpenseType;
  date: DateTimeOutput;
  amount: Int;
  note?: String;
}

export interface ExpensePromise extends Promise<Expense>, Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<ExpenseType>;
  date: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  note: () => Promise<String>;
}

export interface ExpenseSubscription
  extends Promise<AsyncIterator<Expense>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<ExpenseType>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  note: () => Promise<AsyncIterator<String>>;
}

export interface ExpenseNullablePromise
  extends Promise<Expense | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<ExpenseType>;
  date: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  note: () => Promise<String>;
}

export interface MailgunEmailPayload {
  id: ID_Output;
  success: Boolean;
}

export interface MailgunEmailPayloadPromise
  extends Promise<MailgunEmailPayload>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  success: () => Promise<Boolean>;
}

export interface MailgunEmailPayloadSubscription
  extends Promise<AsyncIterator<MailgunEmailPayload>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  success: () => Promise<AsyncIterator<Boolean>>;
}

export interface MailgunEmailPayloadNullablePromise
  extends Promise<MailgunEmailPayload | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  success: () => Promise<Boolean>;
}

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "LoginResponse",
    embedded: false
  },
  {
    name: "Student",
    embedded: false
  },
  {
    name: "CourseDay",
    embedded: false
  },
  {
    name: "Course",
    embedded: false
  },
  {
    name: "CourseAbsence",
    embedded: false
  },
  {
    name: "ParticipantStatus",
    embedded: false
  },
  {
    name: "Participant",
    embedded: false
  },
  {
    name: "DanceRole",
    embedded: false
  },
  {
    name: "MembershipStatus",
    embedded: false
  },
  {
    name: "Membership",
    embedded: false
  },
  {
    name: "Teacher",
    embedded: false
  },
  {
    name: "CourseInstance",
    embedded: false
  },
  {
    name: "Card",
    embedded: false
  },
  {
    name: "PaymentType",
    embedded: false
  },
  {
    name: "Payment",
    embedded: false
  },
  {
    name: "ExpenseType",
    embedded: false
  },
  {
    name: "Expense",
    embedded: false
  },
  {
    name: "Studio",
    embedded: false
  },
  {
    name: "Room",
    embedded: false
  },
  {
    name: "MailgunEmailPayload",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
