// Code generated by Prisma (prisma@1.30.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  card: (where?: CardWhereInput) => Promise<boolean>;
  course: (where?: CourseWhereInput) => Promise<boolean>;
  courseInstance: (where?: CourseInstanceWhereInput) => Promise<boolean>;
  courseStudent: (where?: CourseStudentWhereInput) => Promise<boolean>;
  participant: (where?: ParticipantWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  room: (where?: RoomWhereInput) => Promise<boolean>;
  student: (where?: StudentWhereInput) => Promise<boolean>;
  studio: (where?: StudioWhereInput) => Promise<boolean>;
  teacher: (where?: TeacherWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  card: (where: CardWhereUniqueInput) => CardPromise;
  cards: (
    args?: {
      where?: CardWhereInput;
      orderBy?: CardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Card>;
  cardsConnection: (
    args?: {
      where?: CardWhereInput;
      orderBy?: CardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CardConnectionPromise;
  course: (where: CourseWhereUniqueInput) => CoursePromise;
  courses: (
    args?: {
      where?: CourseWhereInput;
      orderBy?: CourseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Course>;
  coursesConnection: (
    args?: {
      where?: CourseWhereInput;
      orderBy?: CourseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CourseConnectionPromise;
  courseInstance: (
    where: CourseInstanceWhereUniqueInput
  ) => CourseInstancePromise;
  courseInstances: (
    args?: {
      where?: CourseInstanceWhereInput;
      orderBy?: CourseInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CourseInstance>;
  courseInstancesConnection: (
    args?: {
      where?: CourseInstanceWhereInput;
      orderBy?: CourseInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CourseInstanceConnectionPromise;
  courseStudent: (where: CourseStudentWhereUniqueInput) => CourseStudentPromise;
  courseStudents: (
    args?: {
      where?: CourseStudentWhereInput;
      orderBy?: CourseStudentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CourseStudent>;
  courseStudentsConnection: (
    args?: {
      where?: CourseStudentWhereInput;
      orderBy?: CourseStudentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CourseStudentConnectionPromise;
  participant: (where: ParticipantWhereUniqueInput) => ParticipantPromise;
  participants: (
    args?: {
      where?: ParticipantWhereInput;
      orderBy?: ParticipantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Participant>;
  participantsConnection: (
    args?: {
      where?: ParticipantWhereInput;
      orderBy?: ParticipantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ParticipantConnectionPromise;
  payment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  payments: (
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Payment>;
  paymentsConnection: (
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PaymentConnectionPromise;
  room: (where: RoomWhereUniqueInput) => RoomPromise;
  rooms: (
    args?: {
      where?: RoomWhereInput;
      orderBy?: RoomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Room>;
  roomsConnection: (
    args?: {
      where?: RoomWhereInput;
      orderBy?: RoomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RoomConnectionPromise;
  student: (where: StudentWhereUniqueInput) => StudentPromise;
  students: (
    args?: {
      where?: StudentWhereInput;
      orderBy?: StudentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Student>;
  studentsConnection: (
    args?: {
      where?: StudentWhereInput;
      orderBy?: StudentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StudentConnectionPromise;
  studio: (where: StudioWhereUniqueInput) => StudioPromise;
  studios: (
    args?: {
      where?: StudioWhereInput;
      orderBy?: StudioOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Studio>;
  studiosConnection: (
    args?: {
      where?: StudioWhereInput;
      orderBy?: StudioOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StudioConnectionPromise;
  teacher: (where: TeacherWhereUniqueInput) => TeacherPromise;
  teachers: (
    args?: {
      where?: TeacherWhereInput;
      orderBy?: TeacherOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Teacher>;
  teachersConnection: (
    args?: {
      where?: TeacherWhereInput;
      orderBy?: TeacherOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TeacherConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCard: (data: CardCreateInput) => CardPromise;
  updateCard: (
    args: { data: CardUpdateInput; where: CardWhereUniqueInput }
  ) => CardPromise;
  updateManyCards: (
    args: { data: CardUpdateManyMutationInput; where?: CardWhereInput }
  ) => BatchPayloadPromise;
  upsertCard: (
    args: {
      where: CardWhereUniqueInput;
      create: CardCreateInput;
      update: CardUpdateInput;
    }
  ) => CardPromise;
  deleteCard: (where: CardWhereUniqueInput) => CardPromise;
  deleteManyCards: (where?: CardWhereInput) => BatchPayloadPromise;
  createCourse: (data: CourseCreateInput) => CoursePromise;
  updateCourse: (
    args: { data: CourseUpdateInput; where: CourseWhereUniqueInput }
  ) => CoursePromise;
  updateManyCourses: (
    args: { data: CourseUpdateManyMutationInput; where?: CourseWhereInput }
  ) => BatchPayloadPromise;
  upsertCourse: (
    args: {
      where: CourseWhereUniqueInput;
      create: CourseCreateInput;
      update: CourseUpdateInput;
    }
  ) => CoursePromise;
  deleteCourse: (where: CourseWhereUniqueInput) => CoursePromise;
  deleteManyCourses: (where?: CourseWhereInput) => BatchPayloadPromise;
  createCourseInstance: (
    data: CourseInstanceCreateInput
  ) => CourseInstancePromise;
  updateCourseInstance: (
    args: {
      data: CourseInstanceUpdateInput;
      where: CourseInstanceWhereUniqueInput;
    }
  ) => CourseInstancePromise;
  updateManyCourseInstances: (
    args: {
      data: CourseInstanceUpdateManyMutationInput;
      where?: CourseInstanceWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCourseInstance: (
    args: {
      where: CourseInstanceWhereUniqueInput;
      create: CourseInstanceCreateInput;
      update: CourseInstanceUpdateInput;
    }
  ) => CourseInstancePromise;
  deleteCourseInstance: (
    where: CourseInstanceWhereUniqueInput
  ) => CourseInstancePromise;
  deleteManyCourseInstances: (
    where?: CourseInstanceWhereInput
  ) => BatchPayloadPromise;
  createCourseStudent: (data: CourseStudentCreateInput) => CourseStudentPromise;
  updateCourseStudent: (
    args: {
      data: CourseStudentUpdateInput;
      where: CourseStudentWhereUniqueInput;
    }
  ) => CourseStudentPromise;
  updateManyCourseStudents: (
    args: {
      data: CourseStudentUpdateManyMutationInput;
      where?: CourseStudentWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCourseStudent: (
    args: {
      where: CourseStudentWhereUniqueInput;
      create: CourseStudentCreateInput;
      update: CourseStudentUpdateInput;
    }
  ) => CourseStudentPromise;
  deleteCourseStudent: (
    where: CourseStudentWhereUniqueInput
  ) => CourseStudentPromise;
  deleteManyCourseStudents: (
    where?: CourseStudentWhereInput
  ) => BatchPayloadPromise;
  createParticipant: (data: ParticipantCreateInput) => ParticipantPromise;
  updateParticipant: (
    args: { data: ParticipantUpdateInput; where: ParticipantWhereUniqueInput }
  ) => ParticipantPromise;
  updateManyParticipants: (
    args: {
      data: ParticipantUpdateManyMutationInput;
      where?: ParticipantWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertParticipant: (
    args: {
      where: ParticipantWhereUniqueInput;
      create: ParticipantCreateInput;
      update: ParticipantUpdateInput;
    }
  ) => ParticipantPromise;
  deleteParticipant: (where: ParticipantWhereUniqueInput) => ParticipantPromise;
  deleteManyParticipants: (
    where?: ParticipantWhereInput
  ) => BatchPayloadPromise;
  createPayment: (data: PaymentCreateInput) => PaymentPromise;
  updatePayment: (
    args: { data: PaymentUpdateInput; where: PaymentWhereUniqueInput }
  ) => PaymentPromise;
  updateManyPayments: (
    args: { data: PaymentUpdateManyMutationInput; where?: PaymentWhereInput }
  ) => BatchPayloadPromise;
  upsertPayment: (
    args: {
      where: PaymentWhereUniqueInput;
      create: PaymentCreateInput;
      update: PaymentUpdateInput;
    }
  ) => PaymentPromise;
  deletePayment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayloadPromise;
  createRoom: (data: RoomCreateInput) => RoomPromise;
  updateRoom: (
    args: { data: RoomUpdateInput; where: RoomWhereUniqueInput }
  ) => RoomPromise;
  updateManyRooms: (
    args: { data: RoomUpdateManyMutationInput; where?: RoomWhereInput }
  ) => BatchPayloadPromise;
  upsertRoom: (
    args: {
      where: RoomWhereUniqueInput;
      create: RoomCreateInput;
      update: RoomUpdateInput;
    }
  ) => RoomPromise;
  deleteRoom: (where: RoomWhereUniqueInput) => RoomPromise;
  deleteManyRooms: (where?: RoomWhereInput) => BatchPayloadPromise;
  createStudent: (data: StudentCreateInput) => StudentPromise;
  updateStudent: (
    args: { data: StudentUpdateInput; where: StudentWhereUniqueInput }
  ) => StudentPromise;
  updateManyStudents: (
    args: { data: StudentUpdateManyMutationInput; where?: StudentWhereInput }
  ) => BatchPayloadPromise;
  upsertStudent: (
    args: {
      where: StudentWhereUniqueInput;
      create: StudentCreateInput;
      update: StudentUpdateInput;
    }
  ) => StudentPromise;
  deleteStudent: (where: StudentWhereUniqueInput) => StudentPromise;
  deleteManyStudents: (where?: StudentWhereInput) => BatchPayloadPromise;
  createStudio: (data: StudioCreateInput) => StudioPromise;
  updateStudio: (
    args: { data: StudioUpdateInput; where: StudioWhereUniqueInput }
  ) => StudioPromise;
  updateManyStudios: (
    args: { data: StudioUpdateManyMutationInput; where?: StudioWhereInput }
  ) => BatchPayloadPromise;
  upsertStudio: (
    args: {
      where: StudioWhereUniqueInput;
      create: StudioCreateInput;
      update: StudioUpdateInput;
    }
  ) => StudioPromise;
  deleteStudio: (where: StudioWhereUniqueInput) => StudioPromise;
  deleteManyStudios: (where?: StudioWhereInput) => BatchPayloadPromise;
  createTeacher: (data: TeacherCreateInput) => TeacherPromise;
  updateTeacher: (
    args: { data: TeacherUpdateInput; where: TeacherWhereUniqueInput }
  ) => TeacherPromise;
  updateManyTeachers: (
    args: { data: TeacherUpdateManyMutationInput; where?: TeacherWhereInput }
  ) => BatchPayloadPromise;
  upsertTeacher: (
    args: {
      where: TeacherWhereUniqueInput;
      create: TeacherCreateInput;
      update: TeacherUpdateInput;
    }
  ) => TeacherPromise;
  deleteTeacher: (where: TeacherWhereUniqueInput) => TeacherPromise;
  deleteManyTeachers: (where?: TeacherWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  card: (
    where?: CardSubscriptionWhereInput
  ) => CardSubscriptionPayloadSubscription;
  course: (
    where?: CourseSubscriptionWhereInput
  ) => CourseSubscriptionPayloadSubscription;
  courseInstance: (
    where?: CourseInstanceSubscriptionWhereInput
  ) => CourseInstanceSubscriptionPayloadSubscription;
  courseStudent: (
    where?: CourseStudentSubscriptionWhereInput
  ) => CourseStudentSubscriptionPayloadSubscription;
  participant: (
    where?: ParticipantSubscriptionWhereInput
  ) => ParticipantSubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
  room: (
    where?: RoomSubscriptionWhereInput
  ) => RoomSubscriptionPayloadSubscription;
  student: (
    where?: StudentSubscriptionWhereInput
  ) => StudentSubscriptionPayloadSubscription;
  studio: (
    where?: StudioSubscriptionWhereInput
  ) => StudioSubscriptionPayloadSubscription;
  teacher: (
    where?: TeacherSubscriptionWhereInput
  ) => TeacherSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PaymentType = "CARD" | "PRIVATE" | "DROP_IN";

export type ParticipantStatus = "PRESENT" | "ABSENT";

export type ParticipantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "admin_ASC"
  | "admin_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CourseInstanceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "topic_ASC"
  | "topic_DESC"
  | "notes_ASC"
  | "notes_DESC"
  | "recapUrl_ASC"
  | "recapUrl_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StudentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "mobile_ASC"
  | "mobile_DESC"
  | "hasReferralBonus_ASC"
  | "hasReferralBonus_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DanceRole = "LEADER" | "FOLLOWER" | "SOLO";

export type CourseStudentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "role_ASC"
  | "role_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TeacherOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "mobile_ASC"
  | "mobile_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CourseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "studentLimit_ASC"
  | "studentLimit_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "date_ASC"
  | "date_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StudioOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type RoomOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "capacity_ASC"
  | "capacity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CardOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "expirationDate_ASC"
  | "expirationDate_DESC"
  | "active_ASC"
  | "active_DESC"
  | "validCount_ASC"
  | "validCount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface CourseStudentUpdateDataInput {
  student?: StudentUpdateOneRequiredWithoutCoursesInput;
  course?: CourseUpdateOneRequiredWithoutCourseStudentsInput;
  role?: DanceRole;
}

export type CardWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface StudentUpdateOneWithoutPaymentsInput {
  create?: StudentCreateWithoutPaymentsInput;
  update?: StudentUpdateWithoutPaymentsDataInput;
  upsert?: StudentUpsertWithoutPaymentsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: StudentWhereUniqueInput;
}

export interface StudioWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  rooms_every?: RoomWhereInput;
  rooms_some?: RoomWhereInput;
  rooms_none?: RoomWhereInput;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  AND?: StudioWhereInput[] | StudioWhereInput;
  OR?: StudioWhereInput[] | StudioWhereInput;
  NOT?: StudioWhereInput[] | StudioWhereInput;
}

export interface StudentUpdateWithoutPaymentsDataInput {
  name?: String;
  email?: String;
  mobile?: String;
  courses?: CourseStudentUpdateManyWithoutStudentInput;
  cards?: CardUpdateManyWithoutStudentInput;
  hasReferralBonus?: Boolean;
}

export interface RoomWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  capacity?: Int;
  capacity_not?: Int;
  capacity_in?: Int[] | Int;
  capacity_not_in?: Int[] | Int;
  capacity_lt?: Int;
  capacity_lte?: Int;
  capacity_gt?: Int;
  capacity_gte?: Int;
  studio?: StudioWhereInput;
  AND?: RoomWhereInput[] | RoomWhereInput;
  OR?: RoomWhereInput[] | RoomWhereInput;
  NOT?: RoomWhereInput[] | RoomWhereInput;
}

export interface StudentUpsertWithoutPaymentsInput {
  update: StudentUpdateWithoutPaymentsDataInput;
  create: StudentCreateWithoutPaymentsInput;
}

export interface CourseWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  startTime?: String;
  startTime_not?: String;
  startTime_in?: String[] | String;
  startTime_not_in?: String[] | String;
  startTime_lt?: String;
  startTime_lte?: String;
  startTime_gt?: String;
  startTime_gte?: String;
  startTime_contains?: String;
  startTime_not_contains?: String;
  startTime_starts_with?: String;
  startTime_not_starts_with?: String;
  startTime_ends_with?: String;
  startTime_not_ends_with?: String;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  teachers_every?: TeacherWhereInput;
  teachers_some?: TeacherWhereInput;
  teachers_none?: TeacherWhereInput;
  courseStudents_every?: CourseStudentWhereInput;
  courseStudents_some?: CourseStudentWhereInput;
  courseStudents_none?: CourseStudentWhereInput;
  instances_every?: CourseInstanceWhereInput;
  instances_some?: CourseInstanceWhereInput;
  instances_none?: CourseInstanceWhereInput;
  studentLimit?: Int;
  studentLimit_not?: Int;
  studentLimit_in?: Int[] | Int;
  studentLimit_not_in?: Int[] | Int;
  studentLimit_lt?: Int;
  studentLimit_lte?: Int;
  studentLimit_gt?: Int;
  studentLimit_gte?: Int;
  room?: RoomWhereInput;
  AND?: CourseWhereInput[] | CourseWhereInput;
  OR?: CourseWhereInput[] | CourseWhereInput;
  NOT?: CourseWhereInput[] | CourseWhereInput;
}

export interface PaymentCreateWithoutStudentInput {
  type: PaymentType;
  date: DateTimeInput;
  amount: Int;
  card?: CardCreateOneWithoutPaymentInput;
}

export interface ParticipantUpdateInput {
  courseStudent?: CourseStudentUpdateOneRequiredInput;
  courseInstance?: CourseInstanceUpdateOneRequiredWithoutParticipantsInput;
  status?: ParticipantStatus;
}

export interface CardCreateOneWithoutPaymentInput {
  create?: CardCreateWithoutPaymentInput;
  connect?: CardWhereUniqueInput;
}

export interface PaymentUpsertWithoutCardInput {
  update: PaymentUpdateWithoutCardDataInput;
  create: PaymentCreateWithoutCardInput;
}

export interface CardCreateWithoutPaymentInput {
  student: StudentCreateOneWithoutCardsInput;
  expirationDate?: DateTimeInput;
  active?: Boolean;
  validCount: Int;
  useHistory?: CourseInstanceCreateManyInput;
}

export interface TeacherSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TeacherWhereInput;
  AND?: TeacherSubscriptionWhereInput[] | TeacherSubscriptionWhereInput;
  OR?: TeacherSubscriptionWhereInput[] | TeacherSubscriptionWhereInput;
  NOT?: TeacherSubscriptionWhereInput[] | TeacherSubscriptionWhereInput;
}

export interface CardUpdateInput {
  student?: StudentUpdateOneRequiredWithoutCardsInput;
  payment?: PaymentUpdateOneWithoutCardInput;
  expirationDate?: DateTimeInput;
  active?: Boolean;
  validCount?: Int;
  useHistory?: CourseInstanceUpdateManyInput;
}

export interface StudentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StudentWhereInput;
  AND?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  OR?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  NOT?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
}

export interface StudentUpdateOneRequiredWithoutCardsInput {
  create?: StudentCreateWithoutCardsInput;
  update?: StudentUpdateWithoutCardsDataInput;
  upsert?: StudentUpsertWithoutCardsInput;
  connect?: StudentWhereUniqueInput;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaymentWhereInput;
  AND?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  OR?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  NOT?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
}

export interface StudentUpdateWithoutCardsDataInput {
  name?: String;
  email?: String;
  mobile?: String;
  courses?: CourseStudentUpdateManyWithoutStudentInput;
  hasReferralBonus?: Boolean;
  payments?: PaymentUpdateManyWithoutStudentInput;
}

export interface CourseStudentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CourseStudentWhereInput;
  AND?:
    | CourseStudentSubscriptionWhereInput[]
    | CourseStudentSubscriptionWhereInput;
  OR?:
    | CourseStudentSubscriptionWhereInput[]
    | CourseStudentSubscriptionWhereInput;
  NOT?:
    | CourseStudentSubscriptionWhereInput[]
    | CourseStudentSubscriptionWhereInput;
}

export interface CourseStudentUpdateManyWithoutStudentInput {
  create?:
    | CourseStudentCreateWithoutStudentInput[]
    | CourseStudentCreateWithoutStudentInput;
  delete?: CourseStudentWhereUniqueInput[] | CourseStudentWhereUniqueInput;
  connect?: CourseStudentWhereUniqueInput[] | CourseStudentWhereUniqueInput;
  set?: CourseStudentWhereUniqueInput[] | CourseStudentWhereUniqueInput;
  disconnect?: CourseStudentWhereUniqueInput[] | CourseStudentWhereUniqueInput;
  update?:
    | CourseStudentUpdateWithWhereUniqueWithoutStudentInput[]
    | CourseStudentUpdateWithWhereUniqueWithoutStudentInput;
  upsert?:
    | CourseStudentUpsertWithWhereUniqueWithoutStudentInput[]
    | CourseStudentUpsertWithWhereUniqueWithoutStudentInput;
  deleteMany?: CourseStudentScalarWhereInput[] | CourseStudentScalarWhereInput;
  updateMany?:
    | CourseStudentUpdateManyWithWhereNestedInput[]
    | CourseStudentUpdateManyWithWhereNestedInput;
}

export interface CardWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  student?: StudentWhereInput;
  payment?: PaymentWhereInput;
  expirationDate?: DateTimeInput;
  expirationDate_not?: DateTimeInput;
  expirationDate_in?: DateTimeInput[] | DateTimeInput;
  expirationDate_not_in?: DateTimeInput[] | DateTimeInput;
  expirationDate_lt?: DateTimeInput;
  expirationDate_lte?: DateTimeInput;
  expirationDate_gt?: DateTimeInput;
  expirationDate_gte?: DateTimeInput;
  active?: Boolean;
  active_not?: Boolean;
  validCount?: Int;
  validCount_not?: Int;
  validCount_in?: Int[] | Int;
  validCount_not_in?: Int[] | Int;
  validCount_lt?: Int;
  validCount_lte?: Int;
  validCount_gt?: Int;
  validCount_gte?: Int;
  useHistory_every?: CourseInstanceWhereInput;
  useHistory_some?: CourseInstanceWhereInput;
  useHistory_none?: CourseInstanceWhereInput;
  AND?: CardWhereInput[] | CardWhereInput;
  OR?: CardWhereInput[] | CardWhereInput;
  NOT?: CardWhereInput[] | CardWhereInput;
}

export interface CourseStudentUpdateWithWhereUniqueWithoutStudentInput {
  where: CourseStudentWhereUniqueInput;
  data: CourseStudentUpdateWithoutStudentDataInput;
}

export interface CourseInstanceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CourseInstanceWhereInput;
  AND?:
    | CourseInstanceSubscriptionWhereInput[]
    | CourseInstanceSubscriptionWhereInput;
  OR?:
    | CourseInstanceSubscriptionWhereInput[]
    | CourseInstanceSubscriptionWhereInput;
  NOT?:
    | CourseInstanceSubscriptionWhereInput[]
    | CourseInstanceSubscriptionWhereInput;
}

export interface CourseStudentUpdateWithoutStudentDataInput {
  course?: CourseUpdateOneRequiredWithoutCourseStudentsInput;
  role?: DanceRole;
}

export interface CardSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CardWhereInput;
  AND?: CardSubscriptionWhereInput[] | CardSubscriptionWhereInput;
  OR?: CardSubscriptionWhereInput[] | CardSubscriptionWhereInput;
  NOT?: CardSubscriptionWhereInput[] | CardSubscriptionWhereInput;
}

export interface CourseUpdateOneRequiredWithoutCourseStudentsInput {
  create?: CourseCreateWithoutCourseStudentsInput;
  update?: CourseUpdateWithoutCourseStudentsDataInput;
  upsert?: CourseUpsertWithoutCourseStudentsInput;
  connect?: CourseWhereUniqueInput;
}

export interface UserUpdateInput {
  email?: String;
  password?: String;
  name?: String;
  admin?: Boolean;
}

export interface CourseUpdateWithoutCourseStudentsDataInput {
  name?: String;
  description?: String;
  startDate?: DateTimeInput;
  startTime?: String;
  duration?: Int;
  teachers?: TeacherUpdateManyWithoutCoursesInput;
  instances?: CourseInstanceUpdateManyWithoutCourseInput;
  studentLimit?: Int;
  room?: RoomUpdateOneInput;
}

export interface UserCreateInput {
  email?: String;
  password: String;
  name: String;
  admin?: Boolean;
}

export interface TeacherUpdateManyWithoutCoursesInput {
  create?:
    | TeacherCreateWithoutCoursesInput[]
    | TeacherCreateWithoutCoursesInput;
  delete?: TeacherWhereUniqueInput[] | TeacherWhereUniqueInput;
  connect?: TeacherWhereUniqueInput[] | TeacherWhereUniqueInput;
  set?: TeacherWhereUniqueInput[] | TeacherWhereUniqueInput;
  disconnect?: TeacherWhereUniqueInput[] | TeacherWhereUniqueInput;
  update?:
    | TeacherUpdateWithWhereUniqueWithoutCoursesInput[]
    | TeacherUpdateWithWhereUniqueWithoutCoursesInput;
  upsert?:
    | TeacherUpsertWithWhereUniqueWithoutCoursesInput[]
    | TeacherUpsertWithWhereUniqueWithoutCoursesInput;
  deleteMany?: TeacherScalarWhereInput[] | TeacherScalarWhereInput;
  updateMany?:
    | TeacherUpdateManyWithWhereNestedInput[]
    | TeacherUpdateManyWithWhereNestedInput;
}

export interface CourseUpdateManyDataInput {
  name?: String;
  description?: String;
  startDate?: DateTimeInput;
  startTime?: String;
  duration?: Int;
  studentLimit?: Int;
}

export interface TeacherUpdateWithWhereUniqueWithoutCoursesInput {
  where: TeacherWhereUniqueInput;
  data: TeacherUpdateWithoutCoursesDataInput;
}

export interface CourseUpdateManyWithWhereNestedInput {
  where: CourseScalarWhereInput;
  data: CourseUpdateManyDataInput;
}

export interface TeacherUpdateWithoutCoursesDataInput {
  name?: String;
  email?: String;
  mobile?: String;
}

export interface CourseUpsertWithWhereUniqueWithoutTeachersInput {
  where: CourseWhereUniqueInput;
  update: CourseUpdateWithoutTeachersDataInput;
  create: CourseCreateWithoutTeachersInput;
}

export interface TeacherUpsertWithWhereUniqueWithoutCoursesInput {
  where: TeacherWhereUniqueInput;
  update: TeacherUpdateWithoutCoursesDataInput;
  create: TeacherCreateWithoutCoursesInput;
}

export interface CourseUpdateWithoutTeachersDataInput {
  name?: String;
  description?: String;
  startDate?: DateTimeInput;
  startTime?: String;
  duration?: Int;
  courseStudents?: CourseStudentUpdateManyWithoutCourseInput;
  instances?: CourseInstanceUpdateManyWithoutCourseInput;
  studentLimit?: Int;
  room?: RoomUpdateOneInput;
}

export interface TeacherScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  mobile?: String;
  mobile_not?: String;
  mobile_in?: String[] | String;
  mobile_not_in?: String[] | String;
  mobile_lt?: String;
  mobile_lte?: String;
  mobile_gt?: String;
  mobile_gte?: String;
  mobile_contains?: String;
  mobile_not_contains?: String;
  mobile_starts_with?: String;
  mobile_not_starts_with?: String;
  mobile_ends_with?: String;
  mobile_not_ends_with?: String;
  AND?: TeacherScalarWhereInput[] | TeacherScalarWhereInput;
  OR?: TeacherScalarWhereInput[] | TeacherScalarWhereInput;
  NOT?: TeacherScalarWhereInput[] | TeacherScalarWhereInput;
}

export interface CourseUpdateManyWithoutTeachersInput {
  create?:
    | CourseCreateWithoutTeachersInput[]
    | CourseCreateWithoutTeachersInput;
  delete?: CourseWhereUniqueInput[] | CourseWhereUniqueInput;
  connect?: CourseWhereUniqueInput[] | CourseWhereUniqueInput;
  set?: CourseWhereUniqueInput[] | CourseWhereUniqueInput;
  disconnect?: CourseWhereUniqueInput[] | CourseWhereUniqueInput;
  update?:
    | CourseUpdateWithWhereUniqueWithoutTeachersInput[]
    | CourseUpdateWithWhereUniqueWithoutTeachersInput;
  upsert?:
    | CourseUpsertWithWhereUniqueWithoutTeachersInput[]
    | CourseUpsertWithWhereUniqueWithoutTeachersInput;
  deleteMany?: CourseScalarWhereInput[] | CourseScalarWhereInput;
  updateMany?:
    | CourseUpdateManyWithWhereNestedInput[]
    | CourseUpdateManyWithWhereNestedInput;
}

export interface TeacherUpdateManyWithWhereNestedInput {
  where: TeacherScalarWhereInput;
  data: TeacherUpdateManyDataInput;
}

export interface TeacherUpdateInput {
  name?: String;
  email?: String;
  mobile?: String;
  courses?: CourseUpdateManyWithoutTeachersInput;
}

export interface TeacherUpdateManyDataInput {
  name?: String;
  email?: String;
  mobile?: String;
}

export interface CourseCreateManyWithoutTeachersInput {
  create?:
    | CourseCreateWithoutTeachersInput[]
    | CourseCreateWithoutTeachersInput;
  connect?: CourseWhereUniqueInput[] | CourseWhereUniqueInput;
}

export interface CourseInstanceUpdateManyWithoutCourseInput {
  create?:
    | CourseInstanceCreateWithoutCourseInput[]
    | CourseInstanceCreateWithoutCourseInput;
  delete?: CourseInstanceWhereUniqueInput[] | CourseInstanceWhereUniqueInput;
  connect?: CourseInstanceWhereUniqueInput[] | CourseInstanceWhereUniqueInput;
  set?: CourseInstanceWhereUniqueInput[] | CourseInstanceWhereUniqueInput;
  disconnect?:
    | CourseInstanceWhereUniqueInput[]
    | CourseInstanceWhereUniqueInput;
  update?:
    | CourseInstanceUpdateWithWhereUniqueWithoutCourseInput[]
    | CourseInstanceUpdateWithWhereUniqueWithoutCourseInput;
  upsert?:
    | CourseInstanceUpsertWithWhereUniqueWithoutCourseInput[]
    | CourseInstanceUpsertWithWhereUniqueWithoutCourseInput;
  deleteMany?:
    | CourseInstanceScalarWhereInput[]
    | CourseInstanceScalarWhereInput;
  updateMany?:
    | CourseInstanceUpdateManyWithWhereNestedInput[]
    | CourseInstanceUpdateManyWithWhereNestedInput;
}

export interface TeacherCreateInput {
  name: String;
  email: String;
  mobile?: String;
  courses?: CourseCreateManyWithoutTeachersInput;
}

export interface CourseInstanceUpdateWithWhereUniqueWithoutCourseInput {
  where: CourseInstanceWhereUniqueInput;
  data: CourseInstanceUpdateWithoutCourseDataInput;
}

export interface RoomUpdateManyDataInput {
  name?: String;
  capacity?: Int;
}

export interface CourseInstanceUpdateWithoutCourseDataInput {
  date?: DateTimeInput;
  topic?: String;
  notes?: String;
  participants?: ParticipantUpdateManyWithoutCourseInstanceInput;
  recapUrl?: String;
}

export interface RoomUpdateManyWithWhereNestedInput {
  where: RoomScalarWhereInput;
  data: RoomUpdateManyDataInput;
}

export interface ParticipantUpdateManyWithoutCourseInstanceInput {
  create?:
    | ParticipantCreateWithoutCourseInstanceInput[]
    | ParticipantCreateWithoutCourseInstanceInput;
  delete?: ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput;
  connect?: ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput;
  set?: ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput;
  disconnect?: ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput;
  update?:
    | ParticipantUpdateWithWhereUniqueWithoutCourseInstanceInput[]
    | ParticipantUpdateWithWhereUniqueWithoutCourseInstanceInput;
  upsert?:
    | ParticipantUpsertWithWhereUniqueWithoutCourseInstanceInput[]
    | ParticipantUpsertWithWhereUniqueWithoutCourseInstanceInput;
  deleteMany?: ParticipantScalarWhereInput[] | ParticipantScalarWhereInput;
  updateMany?:
    | ParticipantUpdateManyWithWhereNestedInput[]
    | ParticipantUpdateManyWithWhereNestedInput;
}

export interface RoomUpsertWithWhereUniqueWithoutStudioInput {
  where: RoomWhereUniqueInput;
  update: RoomUpdateWithoutStudioDataInput;
  create: RoomCreateWithoutStudioInput;
}

export interface ParticipantUpdateWithWhereUniqueWithoutCourseInstanceInput {
  where: ParticipantWhereUniqueInput;
  data: ParticipantUpdateWithoutCourseInstanceDataInput;
}

export interface CourseStudentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  student?: StudentWhereInput;
  course?: CourseWhereInput;
  role?: DanceRole;
  role_not?: DanceRole;
  role_in?: DanceRole[] | DanceRole;
  role_not_in?: DanceRole[] | DanceRole;
  AND?: CourseStudentWhereInput[] | CourseStudentWhereInput;
  OR?: CourseStudentWhereInput[] | CourseStudentWhereInput;
  NOT?: CourseStudentWhereInput[] | CourseStudentWhereInput;
}

export interface ParticipantUpdateWithoutCourseInstanceDataInput {
  courseStudent?: CourseStudentUpdateOneRequiredInput;
  status?: ParticipantStatus;
}

export interface RoomUpdateWithWhereUniqueWithoutStudioInput {
  where: RoomWhereUniqueInput;
  data: RoomUpdateWithoutStudioDataInput;
}

export interface CourseStudentUpdateOneRequiredInput {
  create?: CourseStudentCreateInput;
  update?: CourseStudentUpdateDataInput;
  upsert?: CourseStudentUpsertNestedInput;
  connect?: CourseStudentWhereUniqueInput;
}

export type StudioWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface ParticipantUpdateManyMutationInput {
  status?: ParticipantStatus;
}

export interface RoomCreateWithoutStudioInput {
  name?: String;
  capacity?: Int;
}

export interface StudentUpdateOneRequiredWithoutCoursesInput {
  create?: StudentCreateWithoutCoursesInput;
  update?: StudentUpdateWithoutCoursesDataInput;
  upsert?: StudentUpsertWithoutCoursesInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudioCreateInput {
  name?: String;
  rooms?: RoomCreateManyWithoutStudioInput;
  address?: String;
}

export interface StudentUpdateWithoutCoursesDataInput {
  name?: String;
  email?: String;
  mobile?: String;
  cards?: CardUpdateManyWithoutStudentInput;
  hasReferralBonus?: Boolean;
  payments?: PaymentUpdateManyWithoutStudentInput;
}

export interface StudentUpdateManyMutationInput {
  name?: String;
  email?: String;
  mobile?: String;
  hasReferralBonus?: Boolean;
}

export interface CardUpdateManyWithoutStudentInput {
  create?: CardCreateWithoutStudentInput[] | CardCreateWithoutStudentInput;
  delete?: CardWhereUniqueInput[] | CardWhereUniqueInput;
  connect?: CardWhereUniqueInput[] | CardWhereUniqueInput;
  set?: CardWhereUniqueInput[] | CardWhereUniqueInput;
  disconnect?: CardWhereUniqueInput[] | CardWhereUniqueInput;
  update?:
    | CardUpdateWithWhereUniqueWithoutStudentInput[]
    | CardUpdateWithWhereUniqueWithoutStudentInput;
  upsert?:
    | CardUpsertWithWhereUniqueWithoutStudentInput[]
    | CardUpsertWithWhereUniqueWithoutStudentInput;
  deleteMany?: CardScalarWhereInput[] | CardScalarWhereInput;
  updateMany?:
    | CardUpdateManyWithWhereNestedInput[]
    | CardUpdateManyWithWhereNestedInput;
}

export interface StudentCreateInput {
  name: String;
  email: String;
  mobile?: String;
  courses?: CourseStudentCreateManyWithoutStudentInput;
  cards?: CardCreateManyWithoutStudentInput;
  hasReferralBonus?: Boolean;
  payments?: PaymentCreateManyWithoutStudentInput;
}

export interface CardUpdateWithWhereUniqueWithoutStudentInput {
  where: CardWhereUniqueInput;
  data: CardUpdateWithoutStudentDataInput;
}

export interface RoomUpdateManyMutationInput {
  name?: String;
  capacity?: Int;
}

export interface CardUpdateWithoutStudentDataInput {
  payment?: PaymentUpdateOneWithoutCardInput;
  expirationDate?: DateTimeInput;
  active?: Boolean;
  validCount?: Int;
  useHistory?: CourseInstanceUpdateManyInput;
}

export interface RoomUpdateInput {
  name?: String;
  capacity?: Int;
  studio?: StudioUpdateOneRequiredWithoutRoomsInput;
}

export interface PaymentUpdateOneWithoutCardInput {
  create?: PaymentCreateWithoutCardInput;
  update?: PaymentUpdateWithoutCardDataInput;
  upsert?: PaymentUpsertWithoutCardInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PaymentWhereUniqueInput;
}

export interface PaymentUpdateInput {
  type?: PaymentType;
  date?: DateTimeInput;
  amount?: Int;
  student?: StudentUpdateOneWithoutPaymentsInput;
  card?: CardUpdateOneWithoutPaymentInput;
}

export interface PaymentUpdateWithoutCardDataInput {
  type?: PaymentType;
  date?: DateTimeInput;
  amount?: Int;
  student?: StudentUpdateOneWithoutPaymentsInput;
}

export interface StudentCreateOneWithoutCardsInput {
  create?: StudentCreateWithoutCardsInput;
  connect?: StudentWhereUniqueInput;
}

export interface ParticipantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  courseStudent?: CourseStudentWhereInput;
  courseInstance?: CourseInstanceWhereInput;
  status?: ParticipantStatus;
  status_not?: ParticipantStatus;
  status_in?: ParticipantStatus[] | ParticipantStatus;
  status_not_in?: ParticipantStatus[] | ParticipantStatus;
  AND?: ParticipantWhereInput[] | ParticipantWhereInput;
  OR?: ParticipantWhereInput[] | ParticipantWhereInput;
  NOT?: ParticipantWhereInput[] | ParticipantWhereInput;
}

export interface CourseStudentCreateManyWithoutStudentInput {
  create?:
    | CourseStudentCreateWithoutStudentInput[]
    | CourseStudentCreateWithoutStudentInput;
  connect?: CourseStudentWhereUniqueInput[] | CourseStudentWhereUniqueInput;
}

export interface TeacherWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  mobile?: String;
  mobile_not?: String;
  mobile_in?: String[] | String;
  mobile_not_in?: String[] | String;
  mobile_lt?: String;
  mobile_lte?: String;
  mobile_gt?: String;
  mobile_gte?: String;
  mobile_contains?: String;
  mobile_not_contains?: String;
  mobile_starts_with?: String;
  mobile_not_starts_with?: String;
  mobile_ends_with?: String;
  mobile_not_ends_with?: String;
  courses_every?: CourseWhereInput;
  courses_some?: CourseWhereInput;
  courses_none?: CourseWhereInput;
  AND?: TeacherWhereInput[] | TeacherWhereInput;
  OR?: TeacherWhereInput[] | TeacherWhereInput;
  NOT?: TeacherWhereInput[] | TeacherWhereInput;
}

export interface CourseCreateOneWithoutCourseStudentsInput {
  create?: CourseCreateWithoutCourseStudentsInput;
  connect?: CourseWhereUniqueInput;
}

export interface CourseInstanceUpsertWithoutParticipantsInput {
  update: CourseInstanceUpdateWithoutParticipantsDataInput;
  create: CourseInstanceCreateWithoutParticipantsInput;
}

export interface TeacherCreateManyWithoutCoursesInput {
  create?:
    | TeacherCreateWithoutCoursesInput[]
    | TeacherCreateWithoutCoursesInput;
  connect?: TeacherWhereUniqueInput[] | TeacherWhereUniqueInput;
}

export interface CourseInstanceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  course?: CourseWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  topic?: String;
  topic_not?: String;
  topic_in?: String[] | String;
  topic_not_in?: String[] | String;
  topic_lt?: String;
  topic_lte?: String;
  topic_gt?: String;
  topic_gte?: String;
  topic_contains?: String;
  topic_not_contains?: String;
  topic_starts_with?: String;
  topic_not_starts_with?: String;
  topic_ends_with?: String;
  topic_not_ends_with?: String;
  notes?: String;
  notes_not?: String;
  notes_in?: String[] | String;
  notes_not_in?: String[] | String;
  notes_lt?: String;
  notes_lte?: String;
  notes_gt?: String;
  notes_gte?: String;
  notes_contains?: String;
  notes_not_contains?: String;
  notes_starts_with?: String;
  notes_not_starts_with?: String;
  notes_ends_with?: String;
  notes_not_ends_with?: String;
  participants_every?: ParticipantWhereInput;
  participants_some?: ParticipantWhereInput;
  participants_none?: ParticipantWhereInput;
  recapUrl?: String;
  recapUrl_not?: String;
  recapUrl_in?: String[] | String;
  recapUrl_not_in?: String[] | String;
  recapUrl_lt?: String;
  recapUrl_lte?: String;
  recapUrl_gt?: String;
  recapUrl_gte?: String;
  recapUrl_contains?: String;
  recapUrl_not_contains?: String;
  recapUrl_starts_with?: String;
  recapUrl_not_starts_with?: String;
  recapUrl_ends_with?: String;
  recapUrl_not_ends_with?: String;
  AND?: CourseInstanceWhereInput[] | CourseInstanceWhereInput;
  OR?: CourseInstanceWhereInput[] | CourseInstanceWhereInput;
  NOT?: CourseInstanceWhereInput[] | CourseInstanceWhereInput;
}

export interface CourseInstanceCreateManyWithoutCourseInput {
  create?:
    | CourseInstanceCreateWithoutCourseInput[]
    | CourseInstanceCreateWithoutCourseInput;
  connect?: CourseInstanceWhereUniqueInput[] | CourseInstanceWhereUniqueInput;
}

export interface CourseInstanceUpdateManyInput {
  create?: CourseInstanceCreateInput[] | CourseInstanceCreateInput;
  update?:
    | CourseInstanceUpdateWithWhereUniqueNestedInput[]
    | CourseInstanceUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CourseInstanceUpsertWithWhereUniqueNestedInput[]
    | CourseInstanceUpsertWithWhereUniqueNestedInput;
  delete?: CourseInstanceWhereUniqueInput[] | CourseInstanceWhereUniqueInput;
  connect?: CourseInstanceWhereUniqueInput[] | CourseInstanceWhereUniqueInput;
  set?: CourseInstanceWhereUniqueInput[] | CourseInstanceWhereUniqueInput;
  disconnect?:
    | CourseInstanceWhereUniqueInput[]
    | CourseInstanceWhereUniqueInput;
  deleteMany?:
    | CourseInstanceScalarWhereInput[]
    | CourseInstanceScalarWhereInput;
  updateMany?:
    | CourseInstanceUpdateManyWithWhereNestedInput[]
    | CourseInstanceUpdateManyWithWhereNestedInput;
}

export interface ParticipantCreateManyWithoutCourseInstanceInput {
  create?:
    | ParticipantCreateWithoutCourseInstanceInput[]
    | ParticipantCreateWithoutCourseInstanceInput;
  connect?: ParticipantWhereUniqueInput[] | ParticipantWhereUniqueInput;
}

export interface CourseInstanceUpdateWithWhereUniqueNestedInput {
  where: CourseInstanceWhereUniqueInput;
  data: CourseInstanceUpdateDataInput;
}

export interface CourseStudentCreateOneInput {
  create?: CourseStudentCreateInput;
  connect?: CourseStudentWhereUniqueInput;
}

export interface CourseInstanceUpdateDataInput {
  course?: CourseUpdateOneWithoutInstancesInput;
  date?: DateTimeInput;
  topic?: String;
  notes?: String;
  participants?: ParticipantUpdateManyWithoutCourseInstanceInput;
  recapUrl?: String;
}

export interface StudentCreateOneWithoutCoursesInput {
  create?: StudentCreateWithoutCoursesInput;
  connect?: StudentWhereUniqueInput;
}

export interface CourseUpdateOneWithoutInstancesInput {
  create?: CourseCreateWithoutInstancesInput;
  update?: CourseUpdateWithoutInstancesDataInput;
  upsert?: CourseUpsertWithoutInstancesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CourseWhereUniqueInput;
}

export interface CardCreateManyWithoutStudentInput {
  create?: CardCreateWithoutStudentInput[] | CardCreateWithoutStudentInput;
  connect?: CardWhereUniqueInput[] | CardWhereUniqueInput;
}

export interface CourseUpdateWithoutInstancesDataInput {
  name?: String;
  description?: String;
  startDate?: DateTimeInput;
  startTime?: String;
  duration?: Int;
  teachers?: TeacherUpdateManyWithoutCoursesInput;
  courseStudents?: CourseStudentUpdateManyWithoutCourseInput;
  studentLimit?: Int;
  room?: RoomUpdateOneInput;
}

export interface PaymentCreateOneWithoutCardInput {
  create?: PaymentCreateWithoutCardInput;
  connect?: PaymentWhereUniqueInput;
}

export interface CourseStudentUpdateManyWithoutCourseInput {
  create?:
    | CourseStudentCreateWithoutCourseInput[]
    | CourseStudentCreateWithoutCourseInput;
  delete?: CourseStudentWhereUniqueInput[] | CourseStudentWhereUniqueInput;
  connect?: CourseStudentWhereUniqueInput[] | CourseStudentWhereUniqueInput;
  set?: CourseStudentWhereUniqueInput[] | CourseStudentWhereUniqueInput;
  disconnect?: CourseStudentWhereUniqueInput[] | CourseStudentWhereUniqueInput;
  update?:
    | CourseStudentUpdateWithWhereUniqueWithoutCourseInput[]
    | CourseStudentUpdateWithWhereUniqueWithoutCourseInput;
  upsert?:
    | CourseStudentUpsertWithWhereUniqueWithoutCourseInput[]
    | CourseStudentUpsertWithWhereUniqueWithoutCourseInput;
  deleteMany?: CourseStudentScalarWhereInput[] | CourseStudentScalarWhereInput;
  updateMany?:
    | CourseStudentUpdateManyWithWhereNestedInput[]
    | CourseStudentUpdateManyWithWhereNestedInput;
}

export interface StudentCreateOneWithoutPaymentsInput {
  create?: StudentCreateWithoutPaymentsInput;
  connect?: StudentWhereUniqueInput;
}

export interface CourseStudentUpdateWithWhereUniqueWithoutCourseInput {
  where: CourseStudentWhereUniqueInput;
  data: CourseStudentUpdateWithoutCourseDataInput;
}

export interface CourseInstanceCreateManyInput {
  create?: CourseInstanceCreateInput[] | CourseInstanceCreateInput;
  connect?: CourseInstanceWhereUniqueInput[] | CourseInstanceWhereUniqueInput;
}

export interface CourseStudentUpdateWithoutCourseDataInput {
  student?: StudentUpdateOneRequiredWithoutCoursesInput;
  role?: DanceRole;
}

export interface CourseCreateOneWithoutInstancesInput {
  create?: CourseCreateWithoutInstancesInput;
  connect?: CourseWhereUniqueInput;
}

export interface CourseStudentUpsertWithWhereUniqueWithoutCourseInput {
  where: CourseStudentWhereUniqueInput;
  update: CourseStudentUpdateWithoutCourseDataInput;
  create: CourseStudentCreateWithoutCourseInput;
}

export interface CourseStudentCreateManyWithoutCourseInput {
  create?:
    | CourseStudentCreateWithoutCourseInput[]
    | CourseStudentCreateWithoutCourseInput;
  connect?: CourseStudentWhereUniqueInput[] | CourseStudentWhereUniqueInput;
}

export interface CourseStudentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  role?: DanceRole;
  role_not?: DanceRole;
  role_in?: DanceRole[] | DanceRole;
  role_not_in?: DanceRole[] | DanceRole;
  AND?: CourseStudentScalarWhereInput[] | CourseStudentScalarWhereInput;
  OR?: CourseStudentScalarWhereInput[] | CourseStudentScalarWhereInput;
  NOT?: CourseStudentScalarWhereInput[] | CourseStudentScalarWhereInput;
}

export interface RoomCreateOneInput {
  create?: RoomCreateInput;
  connect?: RoomWhereUniqueInput;
}

export interface CourseStudentUpdateManyWithWhereNestedInput {
  where: CourseStudentScalarWhereInput;
  data: CourseStudentUpdateManyDataInput;
}

export interface StudioCreateOneWithoutRoomsInput {
  create?: StudioCreateWithoutRoomsInput;
  connect?: StudioWhereUniqueInput;
}

export interface CourseStudentUpdateManyDataInput {
  role?: DanceRole;
}

export interface PaymentCreateManyWithoutStudentInput {
  create?:
    | PaymentCreateWithoutStudentInput[]
    | PaymentCreateWithoutStudentInput;
  connect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
}

export interface RoomUpdateOneInput {
  create?: RoomCreateInput;
  update?: RoomUpdateDataInput;
  upsert?: RoomUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: RoomWhereUniqueInput;
}

export interface StudioSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StudioWhereInput;
  AND?: StudioSubscriptionWhereInput[] | StudioSubscriptionWhereInput;
  OR?: StudioSubscriptionWhereInput[] | StudioSubscriptionWhereInput;
  NOT?: StudioSubscriptionWhereInput[] | StudioSubscriptionWhereInput;
}

export interface RoomUpdateDataInput {
  name?: String;
  capacity?: Int;
  studio?: StudioUpdateOneRequiredWithoutRoomsInput;
}

export interface ParticipantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ParticipantWhereInput;
  AND?: ParticipantSubscriptionWhereInput[] | ParticipantSubscriptionWhereInput;
  OR?: ParticipantSubscriptionWhereInput[] | ParticipantSubscriptionWhereInput;
  NOT?: ParticipantSubscriptionWhereInput[] | ParticipantSubscriptionWhereInput;
}

export interface StudioUpdateOneRequiredWithoutRoomsInput {
  create?: StudioCreateWithoutRoomsInput;
  update?: StudioUpdateWithoutRoomsDataInput;
  upsert?: StudioUpsertWithoutRoomsInput;
  connect?: StudioWhereUniqueInput;
}

export interface StudentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  mobile?: String;
  mobile_not?: String;
  mobile_in?: String[] | String;
  mobile_not_in?: String[] | String;
  mobile_lt?: String;
  mobile_lte?: String;
  mobile_gt?: String;
  mobile_gte?: String;
  mobile_contains?: String;
  mobile_not_contains?: String;
  mobile_starts_with?: String;
  mobile_not_starts_with?: String;
  mobile_ends_with?: String;
  mobile_not_ends_with?: String;
  courses_every?: CourseStudentWhereInput;
  courses_some?: CourseStudentWhereInput;
  courses_none?: CourseStudentWhereInput;
  cards_every?: CardWhereInput;
  cards_some?: CardWhereInput;
  cards_none?: CardWhereInput;
  hasReferralBonus?: Boolean;
  hasReferralBonus_not?: Boolean;
  payments_every?: PaymentWhereInput;
  payments_some?: PaymentWhereInput;
  payments_none?: PaymentWhereInput;
  AND?: StudentWhereInput[] | StudentWhereInput;
  OR?: StudentWhereInput[] | StudentWhereInput;
  NOT?: StudentWhereInput[] | StudentWhereInput;
}

export interface StudioUpdateWithoutRoomsDataInput {
  name?: String;
  address?: String;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  password?: String;
  name?: String;
  admin?: Boolean;
}

export interface StudioUpsertWithoutRoomsInput {
  update: StudioUpdateWithoutRoomsDataInput;
  create: StudioCreateWithoutRoomsInput;
}

export interface TeacherUpdateManyMutationInput {
  name?: String;
  email?: String;
  mobile?: String;
}

export interface RoomUpsertNestedInput {
  update: RoomUpdateDataInput;
  create: RoomCreateInput;
}

export interface CourseScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  startTime?: String;
  startTime_not?: String;
  startTime_in?: String[] | String;
  startTime_not_in?: String[] | String;
  startTime_lt?: String;
  startTime_lte?: String;
  startTime_gt?: String;
  startTime_gte?: String;
  startTime_contains?: String;
  startTime_not_contains?: String;
  startTime_starts_with?: String;
  startTime_not_starts_with?: String;
  startTime_ends_with?: String;
  startTime_not_ends_with?: String;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  studentLimit?: Int;
  studentLimit_not?: Int;
  studentLimit_in?: Int[] | Int;
  studentLimit_not_in?: Int[] | Int;
  studentLimit_lt?: Int;
  studentLimit_lte?: Int;
  studentLimit_gt?: Int;
  studentLimit_gte?: Int;
  AND?: CourseScalarWhereInput[] | CourseScalarWhereInput;
  OR?: CourseScalarWhereInput[] | CourseScalarWhereInput;
  NOT?: CourseScalarWhereInput[] | CourseScalarWhereInput;
}

export interface CourseUpsertWithoutInstancesInput {
  update: CourseUpdateWithoutInstancesDataInput;
  create: CourseCreateWithoutInstancesInput;
}

export interface CourseUpdateWithWhereUniqueWithoutTeachersInput {
  where: CourseWhereUniqueInput;
  data: CourseUpdateWithoutTeachersDataInput;
}

export interface CourseInstanceUpsertWithWhereUniqueNestedInput {
  where: CourseInstanceWhereUniqueInput;
  update: CourseInstanceUpdateDataInput;
  create: CourseInstanceCreateInput;
}

export interface CourseCreateWithoutTeachersInput {
  name: String;
  description?: String;
  startDate?: DateTimeInput;
  startTime?: String;
  duration?: Int;
  courseStudents?: CourseStudentCreateManyWithoutCourseInput;
  instances?: CourseInstanceCreateManyWithoutCourseInput;
  studentLimit?: Int;
  room?: RoomCreateOneInput;
}

export interface CourseInstanceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  topic?: String;
  topic_not?: String;
  topic_in?: String[] | String;
  topic_not_in?: String[] | String;
  topic_lt?: String;
  topic_lte?: String;
  topic_gt?: String;
  topic_gte?: String;
  topic_contains?: String;
  topic_not_contains?: String;
  topic_starts_with?: String;
  topic_not_starts_with?: String;
  topic_ends_with?: String;
  topic_not_ends_with?: String;
  notes?: String;
  notes_not?: String;
  notes_in?: String[] | String;
  notes_not_in?: String[] | String;
  notes_lt?: String;
  notes_lte?: String;
  notes_gt?: String;
  notes_gte?: String;
  notes_contains?: String;
  notes_not_contains?: String;
  notes_starts_with?: String;
  notes_not_starts_with?: String;
  notes_ends_with?: String;
  notes_not_ends_with?: String;
  recapUrl?: String;
  recapUrl_not?: String;
  recapUrl_in?: String[] | String;
  recapUrl_not_in?: String[] | String;
  recapUrl_lt?: String;
  recapUrl_lte?: String;
  recapUrl_gt?: String;
  recapUrl_gte?: String;
  recapUrl_contains?: String;
  recapUrl_not_contains?: String;
  recapUrl_starts_with?: String;
  recapUrl_not_starts_with?: String;
  recapUrl_ends_with?: String;
  recapUrl_not_ends_with?: String;
  AND?: CourseInstanceScalarWhereInput[] | CourseInstanceScalarWhereInput;
  OR?: CourseInstanceScalarWhereInput[] | CourseInstanceScalarWhereInput;
  NOT?: CourseInstanceScalarWhereInput[] | CourseInstanceScalarWhereInput;
}

export interface StudioUpdateManyMutationInput {
  name?: String;
  address?: String;
}

export interface CourseInstanceUpdateManyWithWhereNestedInput {
  where: CourseInstanceScalarWhereInput;
  data: CourseInstanceUpdateManyDataInput;
}

export interface RoomScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  capacity?: Int;
  capacity_not?: Int;
  capacity_in?: Int[] | Int;
  capacity_not_in?: Int[] | Int;
  capacity_lt?: Int;
  capacity_lte?: Int;
  capacity_gt?: Int;
  capacity_gte?: Int;
  AND?: RoomScalarWhereInput[] | RoomScalarWhereInput;
  OR?: RoomScalarWhereInput[] | RoomScalarWhereInput;
  NOT?: RoomScalarWhereInput[] | RoomScalarWhereInput;
}

export interface CourseInstanceUpdateManyDataInput {
  date?: DateTimeInput;
  topic?: String;
  notes?: String;
  recapUrl?: String;
}

export interface RoomUpdateWithoutStudioDataInput {
  name?: String;
  capacity?: Int;
}

export interface CardUpsertWithWhereUniqueWithoutStudentInput {
  where: CardWhereUniqueInput;
  update: CardUpdateWithoutStudentDataInput;
  create: CardCreateWithoutStudentInput;
}

export interface StudioUpdateInput {
  name?: String;
  rooms?: RoomUpdateManyWithoutStudioInput;
  address?: String;
}

export interface CardScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  expirationDate?: DateTimeInput;
  expirationDate_not?: DateTimeInput;
  expirationDate_in?: DateTimeInput[] | DateTimeInput;
  expirationDate_not_in?: DateTimeInput[] | DateTimeInput;
  expirationDate_lt?: DateTimeInput;
  expirationDate_lte?: DateTimeInput;
  expirationDate_gt?: DateTimeInput;
  expirationDate_gte?: DateTimeInput;
  active?: Boolean;
  active_not?: Boolean;
  validCount?: Int;
  validCount_not?: Int;
  validCount_in?: Int[] | Int;
  validCount_not_in?: Int[] | Int;
  validCount_lt?: Int;
  validCount_lte?: Int;
  validCount_gt?: Int;
  validCount_gte?: Int;
  AND?: CardScalarWhereInput[] | CardScalarWhereInput;
  OR?: CardScalarWhereInput[] | CardScalarWhereInput;
  NOT?: CardScalarWhereInput[] | CardScalarWhereInput;
}

export type TeacherWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CardUpdateManyWithWhereNestedInput {
  where: CardScalarWhereInput;
  data: CardUpdateManyDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface CardUpdateManyDataInput {
  expirationDate?: DateTimeInput;
  active?: Boolean;
  validCount?: Int;
}

export interface PaymentUpdateManyMutationInput {
  type?: PaymentType;
  date?: DateTimeInput;
  amount?: Int;
}

export interface PaymentUpdateManyWithoutStudentInput {
  create?:
    | PaymentCreateWithoutStudentInput[]
    | PaymentCreateWithoutStudentInput;
  delete?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  connect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  set?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  disconnect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  update?:
    | PaymentUpdateWithWhereUniqueWithoutStudentInput[]
    | PaymentUpdateWithWhereUniqueWithoutStudentInput;
  upsert?:
    | PaymentUpsertWithWhereUniqueWithoutStudentInput[]
    | PaymentUpsertWithWhereUniqueWithoutStudentInput;
  deleteMany?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
  updateMany?:
    | PaymentUpdateManyWithWhereNestedInput[]
    | PaymentUpdateManyWithWhereNestedInput;
}

export interface CardCreateInput {
  student: StudentCreateOneWithoutCardsInput;
  payment?: PaymentCreateOneWithoutCardInput;
  expirationDate?: DateTimeInput;
  active?: Boolean;
  validCount: Int;
  useHistory?: CourseInstanceCreateManyInput;
}

export interface PaymentUpdateWithWhereUniqueWithoutStudentInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutStudentDataInput;
}

export interface CourseStudentCreateWithoutStudentInput {
  course: CourseCreateOneWithoutCourseStudentsInput;
  role: DanceRole;
}

export interface PaymentUpdateWithoutStudentDataInput {
  type?: PaymentType;
  date?: DateTimeInput;
  amount?: Int;
  card?: CardUpdateOneWithoutPaymentInput;
}

export interface TeacherCreateWithoutCoursesInput {
  name: String;
  email: String;
  mobile?: String;
}

export interface CardUpdateOneWithoutPaymentInput {
  create?: CardCreateWithoutPaymentInput;
  update?: CardUpdateWithoutPaymentDataInput;
  upsert?: CardUpsertWithoutPaymentInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CardWhereUniqueInput;
}

export interface ParticipantCreateWithoutCourseInstanceInput {
  courseStudent: CourseStudentCreateOneInput;
  status: ParticipantStatus;
}

export interface CardUpdateWithoutPaymentDataInput {
  student?: StudentUpdateOneRequiredWithoutCardsInput;
  expirationDate?: DateTimeInput;
  active?: Boolean;
  validCount?: Int;
  useHistory?: CourseInstanceUpdateManyInput;
}

export interface StudentCreateWithoutCoursesInput {
  name: String;
  email: String;
  mobile?: String;
  cards?: CardCreateManyWithoutStudentInput;
  hasReferralBonus?: Boolean;
  payments?: PaymentCreateManyWithoutStudentInput;
}

export interface CardUpsertWithoutPaymentInput {
  update: CardUpdateWithoutPaymentDataInput;
  create: CardCreateWithoutPaymentInput;
}

export interface PaymentCreateWithoutCardInput {
  type: PaymentType;
  date: DateTimeInput;
  amount: Int;
  student?: StudentCreateOneWithoutPaymentsInput;
}

export interface PaymentUpsertWithWhereUniqueWithoutStudentInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutStudentDataInput;
  create: PaymentCreateWithoutStudentInput;
}

export interface CourseInstanceCreateInput {
  course?: CourseCreateOneWithoutInstancesInput;
  date?: DateTimeInput;
  topic?: String;
  notes?: String;
  participants?: ParticipantCreateManyWithoutCourseInstanceInput;
  recapUrl?: String;
}

export interface PaymentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: PaymentType;
  type_not?: PaymentType;
  type_in?: PaymentType[] | PaymentType;
  type_not_in?: PaymentType[] | PaymentType;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  AND?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
  OR?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
  NOT?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
}

export interface CourseStudentCreateWithoutCourseInput {
  student: StudentCreateOneWithoutCoursesInput;
  role: DanceRole;
}

export interface PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput;
  data: PaymentUpdateManyDataInput;
}

export interface StudioCreateWithoutRoomsInput {
  name?: String;
  address?: String;
}

export interface PaymentUpdateManyDataInput {
  type?: PaymentType;
  date?: DateTimeInput;
  amount?: Int;
}

export interface RoomSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RoomWhereInput;
  AND?: RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput;
  OR?: RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput;
  NOT?: RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput;
}

export interface StudentUpsertWithoutCoursesInput {
  update: StudentUpdateWithoutCoursesDataInput;
  create: StudentCreateWithoutCoursesInput;
}

export interface CourseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CourseWhereInput;
  AND?: CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput;
  OR?: CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput;
  NOT?: CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput;
}

export interface CourseStudentUpsertNestedInput {
  update: CourseStudentUpdateDataInput;
  create: CourseStudentCreateInput;
}

export type CourseInstanceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ParticipantUpsertWithWhereUniqueWithoutCourseInstanceInput {
  where: ParticipantWhereUniqueInput;
  update: ParticipantUpdateWithoutCourseInstanceDataInput;
  create: ParticipantCreateWithoutCourseInstanceInput;
}

export type ParticipantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ParticipantScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: ParticipantStatus;
  status_not?: ParticipantStatus;
  status_in?: ParticipantStatus[] | ParticipantStatus;
  status_not_in?: ParticipantStatus[] | ParticipantStatus;
  AND?: ParticipantScalarWhereInput[] | ParticipantScalarWhereInput;
  OR?: ParticipantScalarWhereInput[] | ParticipantScalarWhereInput;
  NOT?: ParticipantScalarWhereInput[] | ParticipantScalarWhereInput;
}

export type RoomWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ParticipantUpdateManyWithWhereNestedInput {
  where: ParticipantScalarWhereInput;
  data: ParticipantUpdateManyDataInput;
}

export interface RoomUpdateManyWithoutStudioInput {
  create?: RoomCreateWithoutStudioInput[] | RoomCreateWithoutStudioInput;
  delete?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
  connect?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
  set?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
  disconnect?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
  update?:
    | RoomUpdateWithWhereUniqueWithoutStudioInput[]
    | RoomUpdateWithWhereUniqueWithoutStudioInput;
  upsert?:
    | RoomUpsertWithWhereUniqueWithoutStudioInput[]
    | RoomUpsertWithWhereUniqueWithoutStudioInput;
  deleteMany?: RoomScalarWhereInput[] | RoomScalarWhereInput;
  updateMany?:
    | RoomUpdateManyWithWhereNestedInput[]
    | RoomUpdateManyWithWhereNestedInput;
}

export interface ParticipantUpdateManyDataInput {
  status?: ParticipantStatus;
}

export interface StudentUpdateInput {
  name?: String;
  email?: String;
  mobile?: String;
  courses?: CourseStudentUpdateManyWithoutStudentInput;
  cards?: CardUpdateManyWithoutStudentInput;
  hasReferralBonus?: Boolean;
  payments?: PaymentUpdateManyWithoutStudentInput;
}

export interface CourseInstanceUpsertWithWhereUniqueWithoutCourseInput {
  where: CourseInstanceWhereUniqueInput;
  update: CourseInstanceUpdateWithoutCourseDataInput;
  create: CourseInstanceCreateWithoutCourseInput;
}

export interface PaymentCreateInput {
  type: PaymentType;
  date: DateTimeInput;
  amount: Int;
  student?: StudentCreateOneWithoutPaymentsInput;
  card?: CardCreateOneWithoutPaymentInput;
}

export interface CourseUpsertWithoutCourseStudentsInput {
  update: CourseUpdateWithoutCourseStudentsDataInput;
  create: CourseCreateWithoutCourseStudentsInput;
}

export interface CourseCreateWithoutCourseStudentsInput {
  name: String;
  description?: String;
  startDate?: DateTimeInput;
  startTime?: String;
  duration?: Int;
  teachers?: TeacherCreateManyWithoutCoursesInput;
  instances?: CourseInstanceCreateManyWithoutCourseInput;
  studentLimit?: Int;
  room?: RoomCreateOneInput;
}

export interface CourseStudentUpsertWithWhereUniqueWithoutStudentInput {
  where: CourseStudentWhereUniqueInput;
  update: CourseStudentUpdateWithoutStudentDataInput;
  create: CourseStudentCreateWithoutStudentInput;
}

export interface CourseStudentCreateInput {
  student: StudentCreateOneWithoutCoursesInput;
  course: CourseCreateOneWithoutCourseStudentsInput;
  role: DanceRole;
}

export interface StudentUpsertWithoutCardsInput {
  update: StudentUpdateWithoutCardsDataInput;
  create: StudentCreateWithoutCardsInput;
}

export interface StudentCreateWithoutPaymentsInput {
  name: String;
  email: String;
  mobile?: String;
  courses?: CourseStudentCreateManyWithoutStudentInput;
  cards?: CardCreateManyWithoutStudentInput;
  hasReferralBonus?: Boolean;
}

export interface CardUpdateManyMutationInput {
  expirationDate?: DateTimeInput;
  active?: Boolean;
  validCount?: Int;
}

export interface RoomCreateInput {
  name?: String;
  capacity?: Int;
  studio: StudioCreateOneWithoutRoomsInput;
}

export interface CourseInstanceUpdateWithoutParticipantsDataInput {
  course?: CourseUpdateOneWithoutInstancesInput;
  date?: DateTimeInput;
  topic?: String;
  notes?: String;
  recapUrl?: String;
}

export interface PaymentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: PaymentType;
  type_not?: PaymentType;
  type_in?: PaymentType[] | PaymentType;
  type_not_in?: PaymentType[] | PaymentType;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  student?: StudentWhereInput;
  card?: CardWhereInput;
  AND?: PaymentWhereInput[] | PaymentWhereInput;
  OR?: PaymentWhereInput[] | PaymentWhereInput;
  NOT?: PaymentWhereInput[] | PaymentWhereInput;
}

export interface CourseInstanceUpdateOneRequiredWithoutParticipantsInput {
  create?: CourseInstanceCreateWithoutParticipantsInput;
  update?: CourseInstanceUpdateWithoutParticipantsDataInput;
  upsert?: CourseInstanceUpsertWithoutParticipantsInput;
  connect?: CourseInstanceWhereUniqueInput;
}

export type CourseStudentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CourseCreateInput {
  name: String;
  description?: String;
  startDate?: DateTimeInput;
  startTime?: String;
  duration?: Int;
  teachers?: TeacherCreateManyWithoutCoursesInput;
  courseStudents?: CourseStudentCreateManyWithoutCourseInput;
  instances?: CourseInstanceCreateManyWithoutCourseInput;
  studentLimit?: Int;
  room?: RoomCreateOneInput;
}

export type StudentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
  email?: String;
}>;

export interface CourseUpdateInput {
  name?: String;
  description?: String;
  startDate?: DateTimeInput;
  startTime?: String;
  duration?: Int;
  teachers?: TeacherUpdateManyWithoutCoursesInput;
  courseStudents?: CourseStudentUpdateManyWithoutCourseInput;
  instances?: CourseInstanceUpdateManyWithoutCourseInput;
  studentLimit?: Int;
  room?: RoomUpdateOneInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  admin?: Boolean;
  admin_not?: Boolean;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface CourseUpdateManyMutationInput {
  name?: String;
  description?: String;
  startDate?: DateTimeInput;
  startTime?: String;
  duration?: Int;
  studentLimit?: Int;
}

export interface CourseInstanceCreateWithoutCourseInput {
  date?: DateTimeInput;
  topic?: String;
  notes?: String;
  participants?: ParticipantCreateManyWithoutCourseInstanceInput;
  recapUrl?: String;
}

export interface CourseInstanceUpdateInput {
  course?: CourseUpdateOneWithoutInstancesInput;
  date?: DateTimeInput;
  topic?: String;
  notes?: String;
  participants?: ParticipantUpdateManyWithoutCourseInstanceInput;
  recapUrl?: String;
}

export interface CourseCreateWithoutInstancesInput {
  name: String;
  description?: String;
  startDate?: DateTimeInput;
  startTime?: String;
  duration?: Int;
  teachers?: TeacherCreateManyWithoutCoursesInput;
  courseStudents?: CourseStudentCreateManyWithoutCourseInput;
  studentLimit?: Int;
  room?: RoomCreateOneInput;
}

export interface CourseInstanceUpdateManyMutationInput {
  date?: DateTimeInput;
  topic?: String;
  notes?: String;
  recapUrl?: String;
}

export type CourseWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CourseStudentUpdateInput {
  student?: StudentUpdateOneRequiredWithoutCoursesInput;
  course?: CourseUpdateOneRequiredWithoutCourseStudentsInput;
  role?: DanceRole;
}

export interface RoomCreateManyWithoutStudioInput {
  create?: RoomCreateWithoutStudioInput[] | RoomCreateWithoutStudioInput;
  connect?: RoomWhereUniqueInput[] | RoomWhereUniqueInput;
}

export interface CourseInstanceCreateWithoutParticipantsInput {
  course?: CourseCreateOneWithoutInstancesInput;
  date?: DateTimeInput;
  topic?: String;
  notes?: String;
  recapUrl?: String;
}

export interface CourseInstanceCreateOneWithoutParticipantsInput {
  create?: CourseInstanceCreateWithoutParticipantsInput;
  connect?: CourseInstanceWhereUniqueInput;
}

export interface ParticipantCreateInput {
  courseStudent: CourseStudentCreateOneInput;
  courseInstance: CourseInstanceCreateOneWithoutParticipantsInput;
  status: ParticipantStatus;
}

export interface CourseStudentUpdateManyMutationInput {
  role?: DanceRole;
}

export interface StudentCreateWithoutCardsInput {
  name: String;
  email: String;
  mobile?: String;
  courses?: CourseStudentCreateManyWithoutStudentInput;
  hasReferralBonus?: Boolean;
  payments?: PaymentCreateManyWithoutStudentInput;
}

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface CardCreateWithoutStudentInput {
  payment?: PaymentCreateOneWithoutCardInput;
  expirationDate?: DateTimeInput;
  active?: Boolean;
  validCount: Int;
  useHistory?: CourseInstanceCreateManyInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  email?: String;
  password: String;
  name: String;
  admin: Boolean;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  admin: () => Promise<Boolean>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  admin: () => Promise<AsyncIterator<Boolean>>;
}

export interface CourseConnection {
  pageInfo: PageInfo;
  edges: CourseEdge[];
}

export interface CourseConnectionPromise
  extends Promise<CourseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CourseEdge>>() => T;
  aggregate: <T = AggregateCoursePromise>() => T;
}

export interface CourseConnectionSubscription
  extends Promise<AsyncIterator<CourseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CourseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCourseSubscription>() => T;
}

export interface Course {
  id: ID_Output;
  name: String;
  description?: String;
  startDate?: DateTimeOutput;
  startTime?: String;
  duration?: Int;
  studentLimit?: Int;
}

export interface CoursePromise extends Promise<Course>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  startTime: () => Promise<String>;
  duration: () => Promise<Int>;
  teachers: <T = FragmentableArray<Teacher>>(
    args?: {
      where?: TeacherWhereInput;
      orderBy?: TeacherOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  courseStudents: <T = FragmentableArray<CourseStudent>>(
    args?: {
      where?: CourseStudentWhereInput;
      orderBy?: CourseStudentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  instances: <T = FragmentableArray<CourseInstance>>(
    args?: {
      where?: CourseInstanceWhereInput;
      orderBy?: CourseInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  studentLimit: () => Promise<Int>;
  room: <T = RoomPromise>() => T;
}

export interface CourseSubscription
  extends Promise<AsyncIterator<Course>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  startTime: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  teachers: <T = Promise<AsyncIterator<TeacherSubscription>>>(
    args?: {
      where?: TeacherWhereInput;
      orderBy?: TeacherOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  courseStudents: <T = Promise<AsyncIterator<CourseStudentSubscription>>>(
    args?: {
      where?: CourseStudentWhereInput;
      orderBy?: CourseStudentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  instances: <T = Promise<AsyncIterator<CourseInstanceSubscription>>>(
    args?: {
      where?: CourseInstanceWhereInput;
      orderBy?: CourseInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  studentLimit: () => Promise<AsyncIterator<Int>>;
  room: <T = RoomSubscription>() => T;
}

export interface AggregateCard {
  count: Int;
}

export interface AggregateCardPromise
  extends Promise<AggregateCard>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCardSubscription
  extends Promise<AsyncIterator<AggregateCard>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CourseStudent {
  id: ID_Output;
  role: DanceRole;
}

export interface CourseStudentPromise
  extends Promise<CourseStudent>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  student: <T = StudentPromise>() => T;
  course: <T = CoursePromise>() => T;
  role: () => Promise<DanceRole>;
}

export interface CourseStudentSubscription
  extends Promise<AsyncIterator<CourseStudent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  student: <T = StudentSubscription>() => T;
  course: <T = CourseSubscription>() => T;
  role: () => Promise<AsyncIterator<DanceRole>>;
}

export interface CardEdge {
  node: Card;
  cursor: String;
}

export interface CardEdgePromise extends Promise<CardEdge>, Fragmentable {
  node: <T = CardPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CardEdgeSubscription
  extends Promise<AsyncIterator<CardEdge>>,
    Fragmentable {
  node: <T = CardSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Card {
  id: ID_Output;
  expirationDate?: DateTimeOutput;
  active: Boolean;
  validCount: Int;
}

export interface CardPromise extends Promise<Card>, Fragmentable {
  id: () => Promise<ID_Output>;
  student: <T = StudentPromise>() => T;
  payment: <T = PaymentPromise>() => T;
  expirationDate: () => Promise<DateTimeOutput>;
  active: () => Promise<Boolean>;
  validCount: () => Promise<Int>;
  useHistory: <T = FragmentableArray<CourseInstance>>(
    args?: {
      where?: CourseInstanceWhereInput;
      orderBy?: CourseInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CardSubscription
  extends Promise<AsyncIterator<Card>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  student: <T = StudentSubscription>() => T;
  payment: <T = PaymentSubscription>() => T;
  expirationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  validCount: () => Promise<AsyncIterator<Int>>;
  useHistory: <T = Promise<AsyncIterator<CourseInstanceSubscription>>>(
    args?: {
      where?: CourseInstanceWhereInput;
      orderBy?: CourseInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface User {
  id: ID_Output;
  email?: String;
  password: String;
  name: String;
  admin: Boolean;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  admin: () => Promise<Boolean>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  admin: () => Promise<AsyncIterator<Boolean>>;
}

export interface CardSubscriptionPayload {
  mutation: MutationType;
  node: Card;
  updatedFields: String[];
  previousValues: CardPreviousValues;
}

export interface CardSubscriptionPayloadPromise
  extends Promise<CardSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CardPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CardPreviousValuesPromise>() => T;
}

export interface CardSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CardSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CardSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CardPreviousValuesSubscription>() => T;
}

export interface TeacherEdge {
  node: Teacher;
  cursor: String;
}

export interface TeacherEdgePromise extends Promise<TeacherEdge>, Fragmentable {
  node: <T = TeacherPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TeacherEdgeSubscription
  extends Promise<AsyncIterator<TeacherEdge>>,
    Fragmentable {
  node: <T = TeacherSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CardPreviousValues {
  id: ID_Output;
  expirationDate?: DateTimeOutput;
  active: Boolean;
  validCount: Int;
}

export interface CardPreviousValuesPromise
  extends Promise<CardPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  expirationDate: () => Promise<DateTimeOutput>;
  active: () => Promise<Boolean>;
  validCount: () => Promise<Int>;
}

export interface CardPreviousValuesSubscription
  extends Promise<AsyncIterator<CardPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  expirationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  validCount: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateStudio {
  count: Int;
}

export interface AggregateStudioPromise
  extends Promise<AggregateStudio>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudioSubscription
  extends Promise<AsyncIterator<AggregateStudio>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CardConnection {
  pageInfo: PageInfo;
  edges: CardEdge[];
}

export interface CardConnectionPromise
  extends Promise<CardConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CardEdge>>() => T;
  aggregate: <T = AggregateCardPromise>() => T;
}

export interface CardConnectionSubscription
  extends Promise<AsyncIterator<CardConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CardEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCardSubscription>() => T;
}

export interface StudioConnection {
  pageInfo: PageInfo;
  edges: StudioEdge[];
}

export interface StudioConnectionPromise
  extends Promise<StudioConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudioEdge>>() => T;
  aggregate: <T = AggregateStudioPromise>() => T;
}

export interface StudioConnectionSubscription
  extends Promise<AsyncIterator<StudioConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudioEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudioSubscription>() => T;
}

export interface CourseSubscriptionPayload {
  mutation: MutationType;
  node: Course;
  updatedFields: String[];
  previousValues: CoursePreviousValues;
}

export interface CourseSubscriptionPayloadPromise
  extends Promise<CourseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CoursePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CoursePreviousValuesPromise>() => T;
}

export interface CourseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CourseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CourseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CoursePreviousValuesSubscription>() => T;
}

export interface AggregateStudent {
  count: Int;
}

export interface AggregateStudentPromise
  extends Promise<AggregateStudent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentSubscription
  extends Promise<AsyncIterator<AggregateStudent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CoursePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  startDate?: DateTimeOutput;
  startTime?: String;
  duration?: Int;
  studentLimit?: Int;
}

export interface CoursePreviousValuesPromise
  extends Promise<CoursePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  startTime: () => Promise<String>;
  duration: () => Promise<Int>;
  studentLimit: () => Promise<Int>;
}

export interface CoursePreviousValuesSubscription
  extends Promise<AsyncIterator<CoursePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  startTime: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  studentLimit: () => Promise<AsyncIterator<Int>>;
}

export interface StudentConnection {
  pageInfo: PageInfo;
  edges: StudentEdge[];
}

export interface StudentConnectionPromise
  extends Promise<StudentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentEdge>>() => T;
  aggregate: <T = AggregateStudentPromise>() => T;
}

export interface StudentConnectionSubscription
  extends Promise<AsyncIterator<StudentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentSubscription>() => T;
}

export interface Payment {
  id: ID_Output;
  type: PaymentType;
  date: DateTimeOutput;
  amount: Int;
}

export interface PaymentPromise extends Promise<Payment>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<PaymentType>;
  date: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  student: <T = StudentPromise>() => T;
  card: <T = CardPromise>() => T;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<Payment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<PaymentType>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  student: <T = StudentSubscription>() => T;
  card: <T = CardSubscription>() => T;
}

export interface RoomEdge {
  node: Room;
  cursor: String;
}

export interface RoomEdgePromise extends Promise<RoomEdge>, Fragmentable {
  node: <T = RoomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoomEdgeSubscription
  extends Promise<AsyncIterator<RoomEdge>>,
    Fragmentable {
  node: <T = RoomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CourseInstanceSubscriptionPayload {
  mutation: MutationType;
  node: CourseInstance;
  updatedFields: String[];
  previousValues: CourseInstancePreviousValues;
}

export interface CourseInstanceSubscriptionPayloadPromise
  extends Promise<CourseInstanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CourseInstancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CourseInstancePreviousValuesPromise>() => T;
}

export interface CourseInstanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CourseInstanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CourseInstanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CourseInstancePreviousValuesSubscription>() => T;
}

export interface AggregatePayment {
  count: Int;
}

export interface AggregatePaymentPromise
  extends Promise<AggregatePayment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePayment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CourseInstancePreviousValues {
  id: ID_Output;
  date?: DateTimeOutput;
  topic?: String;
  notes?: String;
  recapUrl?: String;
}

export interface CourseInstancePreviousValuesPromise
  extends Promise<CourseInstancePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  topic: () => Promise<String>;
  notes: () => Promise<String>;
  recapUrl: () => Promise<String>;
}

export interface CourseInstancePreviousValuesSubscription
  extends Promise<AsyncIterator<CourseInstancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  topic: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
  recapUrl: () => Promise<AsyncIterator<String>>;
}

export interface PaymentConnection {
  pageInfo: PageInfo;
  edges: PaymentEdge[];
}

export interface PaymentConnectionPromise
  extends Promise<PaymentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentEdge>>() => T;
  aggregate: <T = AggregatePaymentPromise>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export interface Studio {
  id: ID_Output;
  name?: String;
  address?: String;
}

export interface StudioPromise extends Promise<Studio>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  rooms: <T = FragmentableArray<Room>>(
    args?: {
      where?: RoomWhereInput;
      orderBy?: RoomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  address: () => Promise<String>;
}

export interface StudioSubscription
  extends Promise<AsyncIterator<Studio>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  rooms: <T = Promise<AsyncIterator<RoomSubscription>>>(
    args?: {
      where?: RoomWhereInput;
      orderBy?: RoomOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  address: () => Promise<AsyncIterator<String>>;
}

export interface ParticipantEdge {
  node: Participant;
  cursor: String;
}

export interface ParticipantEdgePromise
  extends Promise<ParticipantEdge>,
    Fragmentable {
  node: <T = ParticipantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParticipantEdgeSubscription
  extends Promise<AsyncIterator<ParticipantEdge>>,
    Fragmentable {
  node: <T = ParticipantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CourseStudentSubscriptionPayload {
  mutation: MutationType;
  node: CourseStudent;
  updatedFields: String[];
  previousValues: CourseStudentPreviousValues;
}

export interface CourseStudentSubscriptionPayloadPromise
  extends Promise<CourseStudentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CourseStudentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CourseStudentPreviousValuesPromise>() => T;
}

export interface CourseStudentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CourseStudentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CourseStudentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CourseStudentPreviousValuesSubscription>() => T;
}

export interface AggregateCourseStudent {
  count: Int;
}

export interface AggregateCourseStudentPromise
  extends Promise<AggregateCourseStudent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCourseStudentSubscription
  extends Promise<AsyncIterator<AggregateCourseStudent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CourseStudentPreviousValues {
  id: ID_Output;
  role: DanceRole;
}

export interface CourseStudentPreviousValuesPromise
  extends Promise<CourseStudentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  role: () => Promise<DanceRole>;
}

export interface CourseStudentPreviousValuesSubscription
  extends Promise<AsyncIterator<CourseStudentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  role: () => Promise<AsyncIterator<DanceRole>>;
}

export interface CourseStudentConnection {
  pageInfo: PageInfo;
  edges: CourseStudentEdge[];
}

export interface CourseStudentConnectionPromise
  extends Promise<CourseStudentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CourseStudentEdge>>() => T;
  aggregate: <T = AggregateCourseStudentPromise>() => T;
}

export interface CourseStudentConnectionSubscription
  extends Promise<AsyncIterator<CourseStudentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CourseStudentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCourseStudentSubscription>() => T;
}

export interface Room {
  id: ID_Output;
  name?: String;
  capacity?: Int;
}

export interface RoomPromise extends Promise<Room>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  capacity: () => Promise<Int>;
  studio: <T = StudioPromise>() => T;
}

export interface RoomSubscription
  extends Promise<AsyncIterator<Room>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  capacity: () => Promise<AsyncIterator<Int>>;
  studio: <T = StudioSubscription>() => T;
}

export interface CourseInstanceEdge {
  node: CourseInstance;
  cursor: String;
}

export interface CourseInstanceEdgePromise
  extends Promise<CourseInstanceEdge>,
    Fragmentable {
  node: <T = CourseInstancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CourseInstanceEdgeSubscription
  extends Promise<AsyncIterator<CourseInstanceEdge>>,
    Fragmentable {
  node: <T = CourseInstanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ParticipantSubscriptionPayload {
  mutation: MutationType;
  node: Participant;
  updatedFields: String[];
  previousValues: ParticipantPreviousValues;
}

export interface ParticipantSubscriptionPayloadPromise
  extends Promise<ParticipantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParticipantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParticipantPreviousValuesPromise>() => T;
}

export interface ParticipantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParticipantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParticipantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParticipantPreviousValuesSubscription>() => T;
}

export interface AggregateCourse {
  count: Int;
}

export interface AggregateCoursePromise
  extends Promise<AggregateCourse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCourseSubscription
  extends Promise<AsyncIterator<AggregateCourse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ParticipantPreviousValues {
  id: ID_Output;
  status: ParticipantStatus;
}

export interface ParticipantPreviousValuesPromise
  extends Promise<ParticipantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<ParticipantStatus>;
}

export interface ParticipantPreviousValuesSubscription
  extends Promise<AsyncIterator<ParticipantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<ParticipantStatus>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Participant {
  id: ID_Output;
  status: ParticipantStatus;
}

export interface ParticipantPromise extends Promise<Participant>, Fragmentable {
  id: () => Promise<ID_Output>;
  courseStudent: <T = CourseStudentPromise>() => T;
  courseInstance: <T = CourseInstancePromise>() => T;
  status: () => Promise<ParticipantStatus>;
}

export interface ParticipantSubscription
  extends Promise<AsyncIterator<Participant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  courseStudent: <T = CourseStudentSubscription>() => T;
  courseInstance: <T = CourseInstanceSubscription>() => T;
  status: () => Promise<AsyncIterator<ParticipantStatus>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaymentSubscriptionPayload {
  mutation: MutationType;
  node: Payment;
  updatedFields: String[];
  previousValues: PaymentPreviousValues;
}

export interface PaymentSubscriptionPayloadPromise
  extends Promise<PaymentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValuesPromise>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface AggregateTeacher {
  count: Int;
}

export interface AggregateTeacherPromise
  extends Promise<AggregateTeacher>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTeacherSubscription
  extends Promise<AsyncIterator<AggregateTeacher>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentPreviousValues {
  id: ID_Output;
  type: PaymentType;
  date: DateTimeOutput;
  amount: Int;
}

export interface PaymentPreviousValuesPromise
  extends Promise<PaymentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<PaymentType>;
  date: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<PaymentType>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface StudioEdge {
  node: Studio;
  cursor: String;
}

export interface StudioEdgePromise extends Promise<StudioEdge>, Fragmentable {
  node: <T = StudioPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudioEdgeSubscription
  extends Promise<AsyncIterator<StudioEdge>>,
    Fragmentable {
  node: <T = StudioSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TeacherConnection {
  pageInfo: PageInfo;
  edges: TeacherEdge[];
}

export interface TeacherConnectionPromise
  extends Promise<TeacherConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TeacherEdge>>() => T;
  aggregate: <T = AggregateTeacherPromise>() => T;
}

export interface TeacherConnectionSubscription
  extends Promise<AsyncIterator<TeacherConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TeacherEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTeacherSubscription>() => T;
}

export interface TeacherSubscriptionPayload {
  mutation: MutationType;
  node: Teacher;
  updatedFields: String[];
  previousValues: TeacherPreviousValues;
}

export interface TeacherSubscriptionPayloadPromise
  extends Promise<TeacherSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TeacherPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeacherPreviousValuesPromise>() => T;
}

export interface TeacherSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeacherSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeacherSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeacherPreviousValuesSubscription>() => T;
}

export interface Teacher {
  id: ID_Output;
  name: String;
  email: String;
  mobile?: String;
}

export interface TeacherPromise extends Promise<Teacher>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  mobile: () => Promise<String>;
  courses: <T = FragmentableArray<Course>>(
    args?: {
      where?: CourseWhereInput;
      orderBy?: CourseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TeacherSubscription
  extends Promise<AsyncIterator<Teacher>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  courses: <T = Promise<AsyncIterator<CourseSubscription>>>(
    args?: {
      where?: CourseWhereInput;
      orderBy?: CourseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StudentEdge {
  node: Student;
  cursor: String;
}

export interface StudentEdgePromise extends Promise<StudentEdge>, Fragmentable {
  node: <T = StudentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentEdgeSubscription
  extends Promise<AsyncIterator<StudentEdge>>,
    Fragmentable {
  node: <T = StudentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRoom {
  count: Int;
}

export interface AggregateRoomPromise
  extends Promise<AggregateRoom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoomSubscription
  extends Promise<AsyncIterator<AggregateRoom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentEdge {
  node: Payment;
  cursor: String;
}

export interface PaymentEdgePromise extends Promise<PaymentEdge>, Fragmentable {
  node: <T = PaymentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdge>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RoomSubscriptionPayload {
  mutation: MutationType;
  node: Room;
  updatedFields: String[];
  previousValues: RoomPreviousValues;
}

export interface RoomSubscriptionPayloadPromise
  extends Promise<RoomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoomPreviousValuesPromise>() => T;
}

export interface RoomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoomPreviousValuesSubscription>() => T;
}

export interface ParticipantConnection {
  pageInfo: PageInfo;
  edges: ParticipantEdge[];
}

export interface ParticipantConnectionPromise
  extends Promise<ParticipantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParticipantEdge>>() => T;
  aggregate: <T = AggregateParticipantPromise>() => T;
}

export interface ParticipantConnectionSubscription
  extends Promise<AsyncIterator<ParticipantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParticipantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParticipantSubscription>() => T;
}

export interface RoomPreviousValues {
  id: ID_Output;
  name?: String;
  capacity?: Int;
}

export interface RoomPreviousValuesPromise
  extends Promise<RoomPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  capacity: () => Promise<Int>;
}

export interface RoomPreviousValuesSubscription
  extends Promise<AsyncIterator<RoomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  capacity: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateCourseInstance {
  count: Int;
}

export interface AggregateCourseInstancePromise
  extends Promise<AggregateCourseInstance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCourseInstanceSubscription
  extends Promise<AsyncIterator<AggregateCourseInstance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CourseInstance {
  id: ID_Output;
  date?: DateTimeOutput;
  topic?: String;
  notes?: String;
  recapUrl?: String;
}

export interface CourseInstancePromise
  extends Promise<CourseInstance>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  course: <T = CoursePromise>() => T;
  date: () => Promise<DateTimeOutput>;
  topic: () => Promise<String>;
  notes: () => Promise<String>;
  participants: <T = FragmentableArray<Participant>>(
    args?: {
      where?: ParticipantWhereInput;
      orderBy?: ParticipantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  recapUrl: () => Promise<String>;
}

export interface CourseInstanceSubscription
  extends Promise<AsyncIterator<CourseInstance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  course: <T = CourseSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  topic: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
  participants: <T = Promise<AsyncIterator<ParticipantSubscription>>>(
    args?: {
      where?: ParticipantWhereInput;
      orderBy?: ParticipantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  recapUrl: () => Promise<AsyncIterator<String>>;
}

export interface CourseEdge {
  node: Course;
  cursor: String;
}

export interface CourseEdgePromise extends Promise<CourseEdge>, Fragmentable {
  node: <T = CoursePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CourseEdgeSubscription
  extends Promise<AsyncIterator<CourseEdge>>,
    Fragmentable {
  node: <T = CourseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StudentSubscriptionPayload {
  mutation: MutationType;
  node: Student;
  updatedFields: String[];
  previousValues: StudentPreviousValues;
}

export interface StudentSubscriptionPayloadPromise
  extends Promise<StudentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentPreviousValuesPromise>() => T;
}

export interface StudentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentPreviousValuesSubscription>() => T;
}

export interface Student {
  id: ID_Output;
  name: String;
  email: String;
  mobile?: String;
  hasReferralBonus: Boolean;
}

export interface StudentPromise extends Promise<Student>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  mobile: () => Promise<String>;
  courses: <T = FragmentableArray<CourseStudent>>(
    args?: {
      where?: CourseStudentWhereInput;
      orderBy?: CourseStudentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cards: <T = FragmentableArray<Card>>(
    args?: {
      where?: CardWhereInput;
      orderBy?: CardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hasReferralBonus: () => Promise<Boolean>;
  payments: <T = FragmentableArray<Payment>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StudentSubscription
  extends Promise<AsyncIterator<Student>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  courses: <T = Promise<AsyncIterator<CourseStudentSubscription>>>(
    args?: {
      where?: CourseStudentWhereInput;
      orderBy?: CourseStudentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cards: <T = Promise<AsyncIterator<CardSubscription>>>(
    args?: {
      where?: CardWhereInput;
      orderBy?: CardOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hasReferralBonus: () => Promise<AsyncIterator<Boolean>>;
  payments: <T = Promise<AsyncIterator<PaymentSubscription>>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateParticipant {
  count: Int;
}

export interface AggregateParticipantPromise
  extends Promise<AggregateParticipant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParticipantSubscription
  extends Promise<AsyncIterator<AggregateParticipant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudioPreviousValues {
  id: ID_Output;
  name?: String;
  address?: String;
}

export interface StudioPreviousValuesPromise
  extends Promise<StudioPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
}

export interface StudioPreviousValuesSubscription
  extends Promise<AsyncIterator<StudioPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
}

export interface StudioSubscriptionPayload {
  mutation: MutationType;
  node: Studio;
  updatedFields: String[];
  previousValues: StudioPreviousValues;
}

export interface StudioSubscriptionPayloadPromise
  extends Promise<StudioSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudioPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudioPreviousValuesPromise>() => T;
}

export interface StudioSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudioSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudioSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudioPreviousValuesSubscription>() => T;
}

export interface TeacherPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  mobile?: String;
}

export interface TeacherPreviousValuesPromise
  extends Promise<TeacherPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  mobile: () => Promise<String>;
}

export interface TeacherPreviousValuesSubscription
  extends Promise<AsyncIterator<TeacherPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
}

export interface StudentPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  mobile?: String;
  hasReferralBonus: Boolean;
}

export interface StudentPreviousValuesPromise
  extends Promise<StudentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  mobile: () => Promise<String>;
  hasReferralBonus: () => Promise<Boolean>;
}

export interface StudentPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  hasReferralBonus: () => Promise<AsyncIterator<Boolean>>;
}

export interface CourseStudentEdge {
  node: CourseStudent;
  cursor: String;
}

export interface CourseStudentEdgePromise
  extends Promise<CourseStudentEdge>,
    Fragmentable {
  node: <T = CourseStudentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CourseStudentEdgeSubscription
  extends Promise<AsyncIterator<CourseStudentEdge>>,
    Fragmentable {
  node: <T = CourseStudentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RoomConnection {
  pageInfo: PageInfo;
  edges: RoomEdge[];
}

export interface RoomConnectionPromise
  extends Promise<RoomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoomEdge>>() => T;
  aggregate: <T = AggregateRoomPromise>() => T;
}

export interface RoomConnectionSubscription
  extends Promise<AsyncIterator<RoomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoomSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface CourseInstanceConnection {
  pageInfo: PageInfo;
  edges: CourseInstanceEdge[];
}

export interface CourseInstanceConnectionPromise
  extends Promise<CourseInstanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CourseInstanceEdge>>() => T;
  aggregate: <T = AggregateCourseInstancePromise>() => T;
}

export interface CourseInstanceConnectionSubscription
  extends Promise<AsyncIterator<CourseInstanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CourseInstanceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCourseInstanceSubscription>() => T;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Student",
    embedded: false
  },
  {
    name: "Course",
    embedded: false
  },
  {
    name: "ParticipantStatus",
    embedded: false
  },
  {
    name: "Participant",
    embedded: false
  },
  {
    name: "DanceRole",
    embedded: false
  },
  {
    name: "CourseStudent",
    embedded: false
  },
  {
    name: "Teacher",
    embedded: false
  },
  {
    name: "CourseInstance",
    embedded: false
  },
  {
    name: "Card",
    embedded: false
  },
  {
    name: "PaymentType",
    embedded: false
  },
  {
    name: "Payment",
    embedded: false
  },
  {
    name: "Studio",
    embedded: false
  },
  {
    name: "Room",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
