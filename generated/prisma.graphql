type Absentee {
  id: ID!
  student: Student!
  courseInstance: CourseInstance!
}

type AbsenteeConnection {
  pageInfo: PageInfo!
  edges: [AbsenteeEdge]!
  aggregate: AggregateAbsentee!
}

input AbsenteeCreateInput {
  student: StudentCreateOneInput!
  courseInstance: CourseInstanceCreateOneWithoutAbsenteesInput!
}

input AbsenteeCreateManyWithoutCourseInstanceInput {
  create: [AbsenteeCreateWithoutCourseInstanceInput!]
  connect: [AbsenteeWhereUniqueInput!]
}

input AbsenteeCreateWithoutCourseInstanceInput {
  student: StudentCreateOneInput!
}

type AbsenteeEdge {
  node: Absentee!
  cursor: String!
}

enum AbsenteeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AbsenteePreviousValues {
  id: ID!
}

input AbsenteeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [AbsenteeScalarWhereInput!]
  OR: [AbsenteeScalarWhereInput!]
  NOT: [AbsenteeScalarWhereInput!]
}

type AbsenteeSubscriptionPayload {
  mutation: MutationType!
  node: Absentee
  updatedFields: [String!]
  previousValues: AbsenteePreviousValues
}

input AbsenteeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AbsenteeWhereInput
  AND: [AbsenteeSubscriptionWhereInput!]
  OR: [AbsenteeSubscriptionWhereInput!]
  NOT: [AbsenteeSubscriptionWhereInput!]
}

input AbsenteeUpdateInput {
  student: StudentUpdateOneRequiredInput
  courseInstance: CourseInstanceUpdateOneRequiredWithoutAbsenteesInput
}

input AbsenteeUpdateManyWithoutCourseInstanceInput {
  create: [AbsenteeCreateWithoutCourseInstanceInput!]
  delete: [AbsenteeWhereUniqueInput!]
  connect: [AbsenteeWhereUniqueInput!]
  set: [AbsenteeWhereUniqueInput!]
  disconnect: [AbsenteeWhereUniqueInput!]
  update: [AbsenteeUpdateWithWhereUniqueWithoutCourseInstanceInput!]
  upsert: [AbsenteeUpsertWithWhereUniqueWithoutCourseInstanceInput!]
  deleteMany: [AbsenteeScalarWhereInput!]
}

input AbsenteeUpdateWithoutCourseInstanceDataInput {
  student: StudentUpdateOneRequiredInput
}

input AbsenteeUpdateWithWhereUniqueWithoutCourseInstanceInput {
  where: AbsenteeWhereUniqueInput!
  data: AbsenteeUpdateWithoutCourseInstanceDataInput!
}

input AbsenteeUpsertWithWhereUniqueWithoutCourseInstanceInput {
  where: AbsenteeWhereUniqueInput!
  update: AbsenteeUpdateWithoutCourseInstanceDataInput!
  create: AbsenteeCreateWithoutCourseInstanceInput!
}

input AbsenteeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  student: StudentWhereInput
  courseInstance: CourseInstanceWhereInput
  AND: [AbsenteeWhereInput!]
  OR: [AbsenteeWhereInput!]
  NOT: [AbsenteeWhereInput!]
}

input AbsenteeWhereUniqueInput {
  id: ID
}

type AggregateAbsentee {
  count: Int!
}

type AggregateAttendee {
  count: Int!
}

type AggregateCard {
  count: Int!
}

type AggregateCourse {
  count: Int!
}

type AggregateCourseInstance {
  count: Int!
}

type AggregateCourseStudent {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateStudent {
  count: Int!
}

type AggregateStudio {
  count: Int!
}

type AggregateTeacher {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Attendee {
  id: ID!
  student: Student!
  courseInstance: CourseInstance!
}

type AttendeeConnection {
  pageInfo: PageInfo!
  edges: [AttendeeEdge]!
  aggregate: AggregateAttendee!
}

input AttendeeCreateInput {
  student: StudentCreateOneInput!
  courseInstance: CourseInstanceCreateOneWithoutAttendeesInput!
}

input AttendeeCreateManyWithoutCourseInstanceInput {
  create: [AttendeeCreateWithoutCourseInstanceInput!]
  connect: [AttendeeWhereUniqueInput!]
}

input AttendeeCreateWithoutCourseInstanceInput {
  student: StudentCreateOneInput!
}

type AttendeeEdge {
  node: Attendee!
  cursor: String!
}

enum AttendeeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AttendeePreviousValues {
  id: ID!
}

input AttendeeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [AttendeeScalarWhereInput!]
  OR: [AttendeeScalarWhereInput!]
  NOT: [AttendeeScalarWhereInput!]
}

type AttendeeSubscriptionPayload {
  mutation: MutationType!
  node: Attendee
  updatedFields: [String!]
  previousValues: AttendeePreviousValues
}

input AttendeeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AttendeeWhereInput
  AND: [AttendeeSubscriptionWhereInput!]
  OR: [AttendeeSubscriptionWhereInput!]
  NOT: [AttendeeSubscriptionWhereInput!]
}

input AttendeeUpdateInput {
  student: StudentUpdateOneRequiredInput
  courseInstance: CourseInstanceUpdateOneRequiredWithoutAttendeesInput
}

input AttendeeUpdateManyWithoutCourseInstanceInput {
  create: [AttendeeCreateWithoutCourseInstanceInput!]
  delete: [AttendeeWhereUniqueInput!]
  connect: [AttendeeWhereUniqueInput!]
  set: [AttendeeWhereUniqueInput!]
  disconnect: [AttendeeWhereUniqueInput!]
  update: [AttendeeUpdateWithWhereUniqueWithoutCourseInstanceInput!]
  upsert: [AttendeeUpsertWithWhereUniqueWithoutCourseInstanceInput!]
  deleteMany: [AttendeeScalarWhereInput!]
}

input AttendeeUpdateWithoutCourseInstanceDataInput {
  student: StudentUpdateOneRequiredInput
}

input AttendeeUpdateWithWhereUniqueWithoutCourseInstanceInput {
  where: AttendeeWhereUniqueInput!
  data: AttendeeUpdateWithoutCourseInstanceDataInput!
}

input AttendeeUpsertWithWhereUniqueWithoutCourseInstanceInput {
  where: AttendeeWhereUniqueInput!
  update: AttendeeUpdateWithoutCourseInstanceDataInput!
  create: AttendeeCreateWithoutCourseInstanceInput!
}

input AttendeeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  student: StudentWhereInput
  courseInstance: CourseInstanceWhereInput
  AND: [AttendeeWhereInput!]
  OR: [AttendeeWhereInput!]
  NOT: [AttendeeWhereInput!]
}

input AttendeeWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Card {
  id: ID!
  student: Student!
  payment: Payment
  expirationDate: DateTime
  active: Boolean!
  validCount: Int!
  useHistory(where: CourseInstanceWhereInput, orderBy: CourseInstanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseInstance!]
}

type CardConnection {
  pageInfo: PageInfo!
  edges: [CardEdge]!
  aggregate: AggregateCard!
}

input CardCreateInput {
  student: StudentCreateOneWithoutCardsInput!
  payment: PaymentCreateOneWithoutCardInput
  expirationDate: DateTime
  active: Boolean
  validCount: Int!
  useHistory: CourseInstanceCreateManyInput
}

input CardCreateManyWithoutStudentInput {
  create: [CardCreateWithoutStudentInput!]
  connect: [CardWhereUniqueInput!]
}

input CardCreateOneWithoutPaymentInput {
  create: CardCreateWithoutPaymentInput
  connect: CardWhereUniqueInput
}

input CardCreateWithoutPaymentInput {
  student: StudentCreateOneWithoutCardsInput!
  expirationDate: DateTime
  active: Boolean
  validCount: Int!
  useHistory: CourseInstanceCreateManyInput
}

input CardCreateWithoutStudentInput {
  payment: PaymentCreateOneWithoutCardInput
  expirationDate: DateTime
  active: Boolean
  validCount: Int!
  useHistory: CourseInstanceCreateManyInput
}

type CardEdge {
  node: Card!
  cursor: String!
}

enum CardOrderByInput {
  id_ASC
  id_DESC
  expirationDate_ASC
  expirationDate_DESC
  active_ASC
  active_DESC
  validCount_ASC
  validCount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CardPreviousValues {
  id: ID!
  expirationDate: DateTime
  active: Boolean!
  validCount: Int!
}

input CardScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  expirationDate: DateTime
  expirationDate_not: DateTime
  expirationDate_in: [DateTime!]
  expirationDate_not_in: [DateTime!]
  expirationDate_lt: DateTime
  expirationDate_lte: DateTime
  expirationDate_gt: DateTime
  expirationDate_gte: DateTime
  active: Boolean
  active_not: Boolean
  validCount: Int
  validCount_not: Int
  validCount_in: [Int!]
  validCount_not_in: [Int!]
  validCount_lt: Int
  validCount_lte: Int
  validCount_gt: Int
  validCount_gte: Int
  AND: [CardScalarWhereInput!]
  OR: [CardScalarWhereInput!]
  NOT: [CardScalarWhereInput!]
}

type CardSubscriptionPayload {
  mutation: MutationType!
  node: Card
  updatedFields: [String!]
  previousValues: CardPreviousValues
}

input CardSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CardWhereInput
  AND: [CardSubscriptionWhereInput!]
  OR: [CardSubscriptionWhereInput!]
  NOT: [CardSubscriptionWhereInput!]
}

input CardUpdateInput {
  student: StudentUpdateOneRequiredWithoutCardsInput
  payment: PaymentUpdateOneWithoutCardInput
  expirationDate: DateTime
  active: Boolean
  validCount: Int
  useHistory: CourseInstanceUpdateManyInput
}

input CardUpdateManyDataInput {
  expirationDate: DateTime
  active: Boolean
  validCount: Int
}

input CardUpdateManyMutationInput {
  expirationDate: DateTime
  active: Boolean
  validCount: Int
}

input CardUpdateManyWithoutStudentInput {
  create: [CardCreateWithoutStudentInput!]
  delete: [CardWhereUniqueInput!]
  connect: [CardWhereUniqueInput!]
  set: [CardWhereUniqueInput!]
  disconnect: [CardWhereUniqueInput!]
  update: [CardUpdateWithWhereUniqueWithoutStudentInput!]
  upsert: [CardUpsertWithWhereUniqueWithoutStudentInput!]
  deleteMany: [CardScalarWhereInput!]
  updateMany: [CardUpdateManyWithWhereNestedInput!]
}

input CardUpdateManyWithWhereNestedInput {
  where: CardScalarWhereInput!
  data: CardUpdateManyDataInput!
}

input CardUpdateOneWithoutPaymentInput {
  create: CardCreateWithoutPaymentInput
  update: CardUpdateWithoutPaymentDataInput
  upsert: CardUpsertWithoutPaymentInput
  delete: Boolean
  disconnect: Boolean
  connect: CardWhereUniqueInput
}

input CardUpdateWithoutPaymentDataInput {
  student: StudentUpdateOneRequiredWithoutCardsInput
  expirationDate: DateTime
  active: Boolean
  validCount: Int
  useHistory: CourseInstanceUpdateManyInput
}

input CardUpdateWithoutStudentDataInput {
  payment: PaymentUpdateOneWithoutCardInput
  expirationDate: DateTime
  active: Boolean
  validCount: Int
  useHistory: CourseInstanceUpdateManyInput
}

input CardUpdateWithWhereUniqueWithoutStudentInput {
  where: CardWhereUniqueInput!
  data: CardUpdateWithoutStudentDataInput!
}

input CardUpsertWithoutPaymentInput {
  update: CardUpdateWithoutPaymentDataInput!
  create: CardCreateWithoutPaymentInput!
}

input CardUpsertWithWhereUniqueWithoutStudentInput {
  where: CardWhereUniqueInput!
  update: CardUpdateWithoutStudentDataInput!
  create: CardCreateWithoutStudentInput!
}

input CardWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  student: StudentWhereInput
  payment: PaymentWhereInput
  expirationDate: DateTime
  expirationDate_not: DateTime
  expirationDate_in: [DateTime!]
  expirationDate_not_in: [DateTime!]
  expirationDate_lt: DateTime
  expirationDate_lte: DateTime
  expirationDate_gt: DateTime
  expirationDate_gte: DateTime
  active: Boolean
  active_not: Boolean
  validCount: Int
  validCount_not: Int
  validCount_in: [Int!]
  validCount_not_in: [Int!]
  validCount_lt: Int
  validCount_lte: Int
  validCount_gt: Int
  validCount_gte: Int
  useHistory_every: CourseInstanceWhereInput
  useHistory_some: CourseInstanceWhereInput
  useHistory_none: CourseInstanceWhereInput
  AND: [CardWhereInput!]
  OR: [CardWhereInput!]
  NOT: [CardWhereInput!]
}

input CardWhereUniqueInput {
  id: ID
}

type Course {
  id: ID!
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  duration: Int
  teachers(where: TeacherWhereInput, orderBy: TeacherOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Teacher!]
  courseStudents(where: CourseStudentWhereInput, orderBy: CourseStudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseStudent!]
  courseHistory(where: CourseInstanceWhereInput, orderBy: CourseInstanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseInstance!]
  studentLimit: Int
  room: Room
}

type CourseConnection {
  pageInfo: PageInfo!
  edges: [CourseEdge]!
  aggregate: AggregateCourse!
}

input CourseCreateInput {
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  duration: Int
  teachers: TeacherCreateManyWithoutCoursesInput
  courseStudents: CourseStudentCreateManyWithoutCourseInput
  courseHistory: CourseInstanceCreateManyWithoutParentInput
  studentLimit: Int
  room: RoomCreateOneInput
}

input CourseCreateManyWithoutTeachersInput {
  create: [CourseCreateWithoutTeachersInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateOneWithoutCourseHistoryInput {
  create: CourseCreateWithoutCourseHistoryInput
  connect: CourseWhereUniqueInput
}

input CourseCreateOneWithoutCourseStudentsInput {
  create: CourseCreateWithoutCourseStudentsInput
  connect: CourseWhereUniqueInput
}

input CourseCreateWithoutCourseHistoryInput {
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  duration: Int
  teachers: TeacherCreateManyWithoutCoursesInput
  courseStudents: CourseStudentCreateManyWithoutCourseInput
  studentLimit: Int
  room: RoomCreateOneInput
}

input CourseCreateWithoutCourseStudentsInput {
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  duration: Int
  teachers: TeacherCreateManyWithoutCoursesInput
  courseHistory: CourseInstanceCreateManyWithoutParentInput
  studentLimit: Int
  room: RoomCreateOneInput
}

input CourseCreateWithoutTeachersInput {
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  duration: Int
  courseStudents: CourseStudentCreateManyWithoutCourseInput
  courseHistory: CourseInstanceCreateManyWithoutParentInput
  studentLimit: Int
  room: RoomCreateOneInput
}

type CourseEdge {
  node: Course!
  cursor: String!
}

type CourseInstance {
  id: ID!
  parent: Course
  date: DateTime
  topic: String
  notes: String
  attendees(where: AttendeeWhereInput, orderBy: AttendeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attendee!]
  absentees(where: AbsenteeWhereInput, orderBy: AbsenteeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Absentee!]
}

type CourseInstanceConnection {
  pageInfo: PageInfo!
  edges: [CourseInstanceEdge]!
  aggregate: AggregateCourseInstance!
}

input CourseInstanceCreateInput {
  parent: CourseCreateOneWithoutCourseHistoryInput
  date: DateTime
  topic: String
  notes: String
  attendees: AttendeeCreateManyWithoutCourseInstanceInput
  absentees: AbsenteeCreateManyWithoutCourseInstanceInput
}

input CourseInstanceCreateManyInput {
  create: [CourseInstanceCreateInput!]
  connect: [CourseInstanceWhereUniqueInput!]
}

input CourseInstanceCreateManyWithoutParentInput {
  create: [CourseInstanceCreateWithoutParentInput!]
  connect: [CourseInstanceWhereUniqueInput!]
}

input CourseInstanceCreateOneWithoutAbsenteesInput {
  create: CourseInstanceCreateWithoutAbsenteesInput
  connect: CourseInstanceWhereUniqueInput
}

input CourseInstanceCreateOneWithoutAttendeesInput {
  create: CourseInstanceCreateWithoutAttendeesInput
  connect: CourseInstanceWhereUniqueInput
}

input CourseInstanceCreateWithoutAbsenteesInput {
  parent: CourseCreateOneWithoutCourseHistoryInput
  date: DateTime
  topic: String
  notes: String
  attendees: AttendeeCreateManyWithoutCourseInstanceInput
}

input CourseInstanceCreateWithoutAttendeesInput {
  parent: CourseCreateOneWithoutCourseHistoryInput
  date: DateTime
  topic: String
  notes: String
  absentees: AbsenteeCreateManyWithoutCourseInstanceInput
}

input CourseInstanceCreateWithoutParentInput {
  date: DateTime
  topic: String
  notes: String
  attendees: AttendeeCreateManyWithoutCourseInstanceInput
  absentees: AbsenteeCreateManyWithoutCourseInstanceInput
}

type CourseInstanceEdge {
  node: CourseInstance!
  cursor: String!
}

enum CourseInstanceOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  topic_ASC
  topic_DESC
  notes_ASC
  notes_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CourseInstancePreviousValues {
  id: ID!
  date: DateTime
  topic: String
  notes: String
}

input CourseInstanceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  topic: String
  topic_not: String
  topic_in: [String!]
  topic_not_in: [String!]
  topic_lt: String
  topic_lte: String
  topic_gt: String
  topic_gte: String
  topic_contains: String
  topic_not_contains: String
  topic_starts_with: String
  topic_not_starts_with: String
  topic_ends_with: String
  topic_not_ends_with: String
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  AND: [CourseInstanceScalarWhereInput!]
  OR: [CourseInstanceScalarWhereInput!]
  NOT: [CourseInstanceScalarWhereInput!]
}

type CourseInstanceSubscriptionPayload {
  mutation: MutationType!
  node: CourseInstance
  updatedFields: [String!]
  previousValues: CourseInstancePreviousValues
}

input CourseInstanceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseInstanceWhereInput
  AND: [CourseInstanceSubscriptionWhereInput!]
  OR: [CourseInstanceSubscriptionWhereInput!]
  NOT: [CourseInstanceSubscriptionWhereInput!]
}

input CourseInstanceUpdateDataInput {
  parent: CourseUpdateOneWithoutCourseHistoryInput
  date: DateTime
  topic: String
  notes: String
  attendees: AttendeeUpdateManyWithoutCourseInstanceInput
  absentees: AbsenteeUpdateManyWithoutCourseInstanceInput
}

input CourseInstanceUpdateInput {
  parent: CourseUpdateOneWithoutCourseHistoryInput
  date: DateTime
  topic: String
  notes: String
  attendees: AttendeeUpdateManyWithoutCourseInstanceInput
  absentees: AbsenteeUpdateManyWithoutCourseInstanceInput
}

input CourseInstanceUpdateManyDataInput {
  date: DateTime
  topic: String
  notes: String
}

input CourseInstanceUpdateManyInput {
  create: [CourseInstanceCreateInput!]
  update: [CourseInstanceUpdateWithWhereUniqueNestedInput!]
  upsert: [CourseInstanceUpsertWithWhereUniqueNestedInput!]
  delete: [CourseInstanceWhereUniqueInput!]
  connect: [CourseInstanceWhereUniqueInput!]
  set: [CourseInstanceWhereUniqueInput!]
  disconnect: [CourseInstanceWhereUniqueInput!]
  deleteMany: [CourseInstanceScalarWhereInput!]
  updateMany: [CourseInstanceUpdateManyWithWhereNestedInput!]
}

input CourseInstanceUpdateManyMutationInput {
  date: DateTime
  topic: String
  notes: String
}

input CourseInstanceUpdateManyWithoutParentInput {
  create: [CourseInstanceCreateWithoutParentInput!]
  delete: [CourseInstanceWhereUniqueInput!]
  connect: [CourseInstanceWhereUniqueInput!]
  set: [CourseInstanceWhereUniqueInput!]
  disconnect: [CourseInstanceWhereUniqueInput!]
  update: [CourseInstanceUpdateWithWhereUniqueWithoutParentInput!]
  upsert: [CourseInstanceUpsertWithWhereUniqueWithoutParentInput!]
  deleteMany: [CourseInstanceScalarWhereInput!]
  updateMany: [CourseInstanceUpdateManyWithWhereNestedInput!]
}

input CourseInstanceUpdateManyWithWhereNestedInput {
  where: CourseInstanceScalarWhereInput!
  data: CourseInstanceUpdateManyDataInput!
}

input CourseInstanceUpdateOneRequiredWithoutAbsenteesInput {
  create: CourseInstanceCreateWithoutAbsenteesInput
  update: CourseInstanceUpdateWithoutAbsenteesDataInput
  upsert: CourseInstanceUpsertWithoutAbsenteesInput
  connect: CourseInstanceWhereUniqueInput
}

input CourseInstanceUpdateOneRequiredWithoutAttendeesInput {
  create: CourseInstanceCreateWithoutAttendeesInput
  update: CourseInstanceUpdateWithoutAttendeesDataInput
  upsert: CourseInstanceUpsertWithoutAttendeesInput
  connect: CourseInstanceWhereUniqueInput
}

input CourseInstanceUpdateWithoutAbsenteesDataInput {
  parent: CourseUpdateOneWithoutCourseHistoryInput
  date: DateTime
  topic: String
  notes: String
  attendees: AttendeeUpdateManyWithoutCourseInstanceInput
}

input CourseInstanceUpdateWithoutAttendeesDataInput {
  parent: CourseUpdateOneWithoutCourseHistoryInput
  date: DateTime
  topic: String
  notes: String
  absentees: AbsenteeUpdateManyWithoutCourseInstanceInput
}

input CourseInstanceUpdateWithoutParentDataInput {
  date: DateTime
  topic: String
  notes: String
  attendees: AttendeeUpdateManyWithoutCourseInstanceInput
  absentees: AbsenteeUpdateManyWithoutCourseInstanceInput
}

input CourseInstanceUpdateWithWhereUniqueNestedInput {
  where: CourseInstanceWhereUniqueInput!
  data: CourseInstanceUpdateDataInput!
}

input CourseInstanceUpdateWithWhereUniqueWithoutParentInput {
  where: CourseInstanceWhereUniqueInput!
  data: CourseInstanceUpdateWithoutParentDataInput!
}

input CourseInstanceUpsertWithoutAbsenteesInput {
  update: CourseInstanceUpdateWithoutAbsenteesDataInput!
  create: CourseInstanceCreateWithoutAbsenteesInput!
}

input CourseInstanceUpsertWithoutAttendeesInput {
  update: CourseInstanceUpdateWithoutAttendeesDataInput!
  create: CourseInstanceCreateWithoutAttendeesInput!
}

input CourseInstanceUpsertWithWhereUniqueNestedInput {
  where: CourseInstanceWhereUniqueInput!
  update: CourseInstanceUpdateDataInput!
  create: CourseInstanceCreateInput!
}

input CourseInstanceUpsertWithWhereUniqueWithoutParentInput {
  where: CourseInstanceWhereUniqueInput!
  update: CourseInstanceUpdateWithoutParentDataInput!
  create: CourseInstanceCreateWithoutParentInput!
}

input CourseInstanceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  parent: CourseWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  topic: String
  topic_not: String
  topic_in: [String!]
  topic_not_in: [String!]
  topic_lt: String
  topic_lte: String
  topic_gt: String
  topic_gte: String
  topic_contains: String
  topic_not_contains: String
  topic_starts_with: String
  topic_not_starts_with: String
  topic_ends_with: String
  topic_not_ends_with: String
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
  attendees_every: AttendeeWhereInput
  attendees_some: AttendeeWhereInput
  attendees_none: AttendeeWhereInput
  absentees_every: AbsenteeWhereInput
  absentees_some: AbsenteeWhereInput
  absentees_none: AbsenteeWhereInput
  AND: [CourseInstanceWhereInput!]
  OR: [CourseInstanceWhereInput!]
  NOT: [CourseInstanceWhereInput!]
}

input CourseInstanceWhereUniqueInput {
  id: ID
}

enum CourseOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  startDate_ASC
  startDate_DESC
  startTime_ASC
  startTime_DESC
  duration_ASC
  duration_DESC
  studentLimit_ASC
  studentLimit_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CoursePreviousValues {
  id: ID!
  name: String!
  description: String
  startDate: DateTime
  startTime: String
  duration: Int
  studentLimit: Int
}

input CourseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  duration: Int
  duration_not: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_gt: Int
  duration_gte: Int
  studentLimit: Int
  studentLimit_not: Int
  studentLimit_in: [Int!]
  studentLimit_not_in: [Int!]
  studentLimit_lt: Int
  studentLimit_lte: Int
  studentLimit_gt: Int
  studentLimit_gte: Int
  AND: [CourseScalarWhereInput!]
  OR: [CourseScalarWhereInput!]
  NOT: [CourseScalarWhereInput!]
}

type CourseStudent {
  id: ID!
  student: Student!
  course: Course!
  role: DanceRole!
}

type CourseStudentConnection {
  pageInfo: PageInfo!
  edges: [CourseStudentEdge]!
  aggregate: AggregateCourseStudent!
}

input CourseStudentCreateInput {
  student: StudentCreateOneWithoutCoursesInput!
  course: CourseCreateOneWithoutCourseStudentsInput!
  role: DanceRole!
}

input CourseStudentCreateManyWithoutCourseInput {
  create: [CourseStudentCreateWithoutCourseInput!]
  connect: [CourseStudentWhereUniqueInput!]
}

input CourseStudentCreateManyWithoutStudentInput {
  create: [CourseStudentCreateWithoutStudentInput!]
  connect: [CourseStudentWhereUniqueInput!]
}

input CourseStudentCreateWithoutCourseInput {
  student: StudentCreateOneWithoutCoursesInput!
  role: DanceRole!
}

input CourseStudentCreateWithoutStudentInput {
  course: CourseCreateOneWithoutCourseStudentsInput!
  role: DanceRole!
}

type CourseStudentEdge {
  node: CourseStudent!
  cursor: String!
}

enum CourseStudentOrderByInput {
  id_ASC
  id_DESC
  role_ASC
  role_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CourseStudentPreviousValues {
  id: ID!
  role: DanceRole!
}

input CourseStudentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  role: DanceRole
  role_not: DanceRole
  role_in: [DanceRole!]
  role_not_in: [DanceRole!]
  AND: [CourseStudentScalarWhereInput!]
  OR: [CourseStudentScalarWhereInput!]
  NOT: [CourseStudentScalarWhereInput!]
}

type CourseStudentSubscriptionPayload {
  mutation: MutationType!
  node: CourseStudent
  updatedFields: [String!]
  previousValues: CourseStudentPreviousValues
}

input CourseStudentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseStudentWhereInput
  AND: [CourseStudentSubscriptionWhereInput!]
  OR: [CourseStudentSubscriptionWhereInput!]
  NOT: [CourseStudentSubscriptionWhereInput!]
}

input CourseStudentUpdateInput {
  student: StudentUpdateOneRequiredWithoutCoursesInput
  course: CourseUpdateOneRequiredWithoutCourseStudentsInput
  role: DanceRole
}

input CourseStudentUpdateManyDataInput {
  role: DanceRole
}

input CourseStudentUpdateManyMutationInput {
  role: DanceRole
}

input CourseStudentUpdateManyWithoutCourseInput {
  create: [CourseStudentCreateWithoutCourseInput!]
  delete: [CourseStudentWhereUniqueInput!]
  connect: [CourseStudentWhereUniqueInput!]
  set: [CourseStudentWhereUniqueInput!]
  disconnect: [CourseStudentWhereUniqueInput!]
  update: [CourseStudentUpdateWithWhereUniqueWithoutCourseInput!]
  upsert: [CourseStudentUpsertWithWhereUniqueWithoutCourseInput!]
  deleteMany: [CourseStudentScalarWhereInput!]
  updateMany: [CourseStudentUpdateManyWithWhereNestedInput!]
}

input CourseStudentUpdateManyWithoutStudentInput {
  create: [CourseStudentCreateWithoutStudentInput!]
  delete: [CourseStudentWhereUniqueInput!]
  connect: [CourseStudentWhereUniqueInput!]
  set: [CourseStudentWhereUniqueInput!]
  disconnect: [CourseStudentWhereUniqueInput!]
  update: [CourseStudentUpdateWithWhereUniqueWithoutStudentInput!]
  upsert: [CourseStudentUpsertWithWhereUniqueWithoutStudentInput!]
  deleteMany: [CourseStudentScalarWhereInput!]
  updateMany: [CourseStudentUpdateManyWithWhereNestedInput!]
}

input CourseStudentUpdateManyWithWhereNestedInput {
  where: CourseStudentScalarWhereInput!
  data: CourseStudentUpdateManyDataInput!
}

input CourseStudentUpdateWithoutCourseDataInput {
  student: StudentUpdateOneRequiredWithoutCoursesInput
  role: DanceRole
}

input CourseStudentUpdateWithoutStudentDataInput {
  course: CourseUpdateOneRequiredWithoutCourseStudentsInput
  role: DanceRole
}

input CourseStudentUpdateWithWhereUniqueWithoutCourseInput {
  where: CourseStudentWhereUniqueInput!
  data: CourseStudentUpdateWithoutCourseDataInput!
}

input CourseStudentUpdateWithWhereUniqueWithoutStudentInput {
  where: CourseStudentWhereUniqueInput!
  data: CourseStudentUpdateWithoutStudentDataInput!
}

input CourseStudentUpsertWithWhereUniqueWithoutCourseInput {
  where: CourseStudentWhereUniqueInput!
  update: CourseStudentUpdateWithoutCourseDataInput!
  create: CourseStudentCreateWithoutCourseInput!
}

input CourseStudentUpsertWithWhereUniqueWithoutStudentInput {
  where: CourseStudentWhereUniqueInput!
  update: CourseStudentUpdateWithoutStudentDataInput!
  create: CourseStudentCreateWithoutStudentInput!
}

input CourseStudentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  student: StudentWhereInput
  course: CourseWhereInput
  role: DanceRole
  role_not: DanceRole
  role_in: [DanceRole!]
  role_not_in: [DanceRole!]
  AND: [CourseStudentWhereInput!]
  OR: [CourseStudentWhereInput!]
  NOT: [CourseStudentWhereInput!]
}

input CourseStudentWhereUniqueInput {
  id: ID
}

type CourseSubscriptionPayload {
  mutation: MutationType!
  node: Course
  updatedFields: [String!]
  previousValues: CoursePreviousValues
}

input CourseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseWhereInput
  AND: [CourseSubscriptionWhereInput!]
  OR: [CourseSubscriptionWhereInput!]
  NOT: [CourseSubscriptionWhereInput!]
}

input CourseUpdateInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  duration: Int
  teachers: TeacherUpdateManyWithoutCoursesInput
  courseStudents: CourseStudentUpdateManyWithoutCourseInput
  courseHistory: CourseInstanceUpdateManyWithoutParentInput
  studentLimit: Int
  room: RoomUpdateOneInput
}

input CourseUpdateManyDataInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  duration: Int
  studentLimit: Int
}

input CourseUpdateManyMutationInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  duration: Int
  studentLimit: Int
}

input CourseUpdateManyWithoutTeachersInput {
  create: [CourseCreateWithoutTeachersInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutTeachersInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutTeachersInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithWhereNestedInput {
  where: CourseScalarWhereInput!
  data: CourseUpdateManyDataInput!
}

input CourseUpdateOneRequiredWithoutCourseStudentsInput {
  create: CourseCreateWithoutCourseStudentsInput
  update: CourseUpdateWithoutCourseStudentsDataInput
  upsert: CourseUpsertWithoutCourseStudentsInput
  connect: CourseWhereUniqueInput
}

input CourseUpdateOneWithoutCourseHistoryInput {
  create: CourseCreateWithoutCourseHistoryInput
  update: CourseUpdateWithoutCourseHistoryDataInput
  upsert: CourseUpsertWithoutCourseHistoryInput
  delete: Boolean
  disconnect: Boolean
  connect: CourseWhereUniqueInput
}

input CourseUpdateWithoutCourseHistoryDataInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  duration: Int
  teachers: TeacherUpdateManyWithoutCoursesInput
  courseStudents: CourseStudentUpdateManyWithoutCourseInput
  studentLimit: Int
  room: RoomUpdateOneInput
}

input CourseUpdateWithoutCourseStudentsDataInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  duration: Int
  teachers: TeacherUpdateManyWithoutCoursesInput
  courseHistory: CourseInstanceUpdateManyWithoutParentInput
  studentLimit: Int
  room: RoomUpdateOneInput
}

input CourseUpdateWithoutTeachersDataInput {
  name: String
  description: String
  startDate: DateTime
  startTime: String
  duration: Int
  courseStudents: CourseStudentUpdateManyWithoutCourseInput
  courseHistory: CourseInstanceUpdateManyWithoutParentInput
  studentLimit: Int
  room: RoomUpdateOneInput
}

input CourseUpdateWithWhereUniqueWithoutTeachersInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutTeachersDataInput!
}

input CourseUpsertWithoutCourseHistoryInput {
  update: CourseUpdateWithoutCourseHistoryDataInput!
  create: CourseCreateWithoutCourseHistoryInput!
}

input CourseUpsertWithoutCourseStudentsInput {
  update: CourseUpdateWithoutCourseStudentsDataInput!
  create: CourseCreateWithoutCourseStudentsInput!
}

input CourseUpsertWithWhereUniqueWithoutTeachersInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutTeachersDataInput!
  create: CourseCreateWithoutTeachersInput!
}

input CourseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  duration: Int
  duration_not: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  duration_lt: Int
  duration_lte: Int
  duration_gt: Int
  duration_gte: Int
  teachers_every: TeacherWhereInput
  teachers_some: TeacherWhereInput
  teachers_none: TeacherWhereInput
  courseStudents_every: CourseStudentWhereInput
  courseStudents_some: CourseStudentWhereInput
  courseStudents_none: CourseStudentWhereInput
  courseHistory_every: CourseInstanceWhereInput
  courseHistory_some: CourseInstanceWhereInput
  courseHistory_none: CourseInstanceWhereInput
  studentLimit: Int
  studentLimit_not: Int
  studentLimit_in: [Int!]
  studentLimit_not_in: [Int!]
  studentLimit_lt: Int
  studentLimit_lte: Int
  studentLimit_gt: Int
  studentLimit_gte: Int
  room: RoomWhereInput
  AND: [CourseWhereInput!]
  OR: [CourseWhereInput!]
  NOT: [CourseWhereInput!]
}

input CourseWhereUniqueInput {
  id: ID
}

enum DanceRole {
  Leader
  Follower
  Solo
}

scalar DateTime

scalar Long

type Mutation {
  createAbsentee(data: AbsenteeCreateInput!): Absentee!
  updateAbsentee(data: AbsenteeUpdateInput!, where: AbsenteeWhereUniqueInput!): Absentee
  upsertAbsentee(where: AbsenteeWhereUniqueInput!, create: AbsenteeCreateInput!, update: AbsenteeUpdateInput!): Absentee!
  deleteAbsentee(where: AbsenteeWhereUniqueInput!): Absentee
  deleteManyAbsentees(where: AbsenteeWhereInput): BatchPayload!
  createAttendee(data: AttendeeCreateInput!): Attendee!
  updateAttendee(data: AttendeeUpdateInput!, where: AttendeeWhereUniqueInput!): Attendee
  upsertAttendee(where: AttendeeWhereUniqueInput!, create: AttendeeCreateInput!, update: AttendeeUpdateInput!): Attendee!
  deleteAttendee(where: AttendeeWhereUniqueInput!): Attendee
  deleteManyAttendees(where: AttendeeWhereInput): BatchPayload!
  createCard(data: CardCreateInput!): Card!
  updateCard(data: CardUpdateInput!, where: CardWhereUniqueInput!): Card
  updateManyCards(data: CardUpdateManyMutationInput!, where: CardWhereInput): BatchPayload!
  upsertCard(where: CardWhereUniqueInput!, create: CardCreateInput!, update: CardUpdateInput!): Card!
  deleteCard(where: CardWhereUniqueInput!): Card
  deleteManyCards(where: CardWhereInput): BatchPayload!
  createCourse(data: CourseCreateInput!): Course!
  updateCourse(data: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course
  updateManyCourses(data: CourseUpdateManyMutationInput!, where: CourseWhereInput): BatchPayload!
  upsertCourse(where: CourseWhereUniqueInput!, create: CourseCreateInput!, update: CourseUpdateInput!): Course!
  deleteCourse(where: CourseWhereUniqueInput!): Course
  deleteManyCourses(where: CourseWhereInput): BatchPayload!
  createCourseInstance(data: CourseInstanceCreateInput!): CourseInstance!
  updateCourseInstance(data: CourseInstanceUpdateInput!, where: CourseInstanceWhereUniqueInput!): CourseInstance
  updateManyCourseInstances(data: CourseInstanceUpdateManyMutationInput!, where: CourseInstanceWhereInput): BatchPayload!
  upsertCourseInstance(where: CourseInstanceWhereUniqueInput!, create: CourseInstanceCreateInput!, update: CourseInstanceUpdateInput!): CourseInstance!
  deleteCourseInstance(where: CourseInstanceWhereUniqueInput!): CourseInstance
  deleteManyCourseInstances(where: CourseInstanceWhereInput): BatchPayload!
  createCourseStudent(data: CourseStudentCreateInput!): CourseStudent!
  updateCourseStudent(data: CourseStudentUpdateInput!, where: CourseStudentWhereUniqueInput!): CourseStudent
  updateManyCourseStudents(data: CourseStudentUpdateManyMutationInput!, where: CourseStudentWhereInput): BatchPayload!
  upsertCourseStudent(where: CourseStudentWhereUniqueInput!, create: CourseStudentCreateInput!, update: CourseStudentUpdateInput!): CourseStudent!
  deleteCourseStudent(where: CourseStudentWhereUniqueInput!): CourseStudent
  deleteManyCourseStudents(where: CourseStudentWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createRoom(data: RoomCreateInput!): Room!
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateManyRooms(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  createStudent(data: StudentCreateInput!): Student!
  updateStudent(data: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student
  updateManyStudents(data: StudentUpdateManyMutationInput!, where: StudentWhereInput): BatchPayload!
  upsertStudent(where: StudentWhereUniqueInput!, create: StudentCreateInput!, update: StudentUpdateInput!): Student!
  deleteStudent(where: StudentWhereUniqueInput!): Student
  deleteManyStudents(where: StudentWhereInput): BatchPayload!
  createStudio(data: StudioCreateInput!): Studio!
  updateStudio(data: StudioUpdateInput!, where: StudioWhereUniqueInput!): Studio
  updateManyStudios(data: StudioUpdateManyMutationInput!, where: StudioWhereInput): BatchPayload!
  upsertStudio(where: StudioWhereUniqueInput!, create: StudioCreateInput!, update: StudioUpdateInput!): Studio!
  deleteStudio(where: StudioWhereUniqueInput!): Studio
  deleteManyStudios(where: StudioWhereInput): BatchPayload!
  createTeacher(data: TeacherCreateInput!): Teacher!
  updateTeacher(data: TeacherUpdateInput!, where: TeacherWhereUniqueInput!): Teacher
  updateManyTeachers(data: TeacherUpdateManyMutationInput!, where: TeacherWhereInput): BatchPayload!
  upsertTeacher(where: TeacherWhereUniqueInput!, create: TeacherCreateInput!, update: TeacherUpdateInput!): Teacher!
  deleteTeacher(where: TeacherWhereUniqueInput!): Teacher
  deleteManyTeachers(where: TeacherWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  type: PaymentType!
  date: DateTime!
  amount: Int!
  student: Student
  card: Card
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  type: PaymentType!
  date: DateTime!
  amount: Int!
  student: StudentCreateOneWithoutPaymentsInput
  card: CardCreateOneWithoutPaymentInput
}

input PaymentCreateManyWithoutStudentInput {
  create: [PaymentCreateWithoutStudentInput!]
  connect: [PaymentWhereUniqueInput!]
}

input PaymentCreateOneWithoutCardInput {
  create: PaymentCreateWithoutCardInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutCardInput {
  type: PaymentType!
  date: DateTime!
  amount: Int!
  student: StudentCreateOneWithoutPaymentsInput
}

input PaymentCreateWithoutStudentInput {
  type: PaymentType!
  date: DateTime!
  amount: Int!
  card: CardCreateOneWithoutPaymentInput
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  date_ASC
  date_DESC
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PaymentPreviousValues {
  id: ID!
  type: PaymentType!
  date: DateTime!
  amount: Int!
}

input PaymentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: PaymentType
  type_not: PaymentType
  type_in: [PaymentType!]
  type_not_in: [PaymentType!]
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  AND: [PaymentScalarWhereInput!]
  OR: [PaymentScalarWhereInput!]
  NOT: [PaymentScalarWhereInput!]
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

enum PaymentType {
  Course
  Private
  DropIn
}

input PaymentUpdateInput {
  type: PaymentType
  date: DateTime
  amount: Int
  student: StudentUpdateOneWithoutPaymentsInput
  card: CardUpdateOneWithoutPaymentInput
}

input PaymentUpdateManyDataInput {
  type: PaymentType
  date: DateTime
  amount: Int
}

input PaymentUpdateManyMutationInput {
  type: PaymentType
  date: DateTime
  amount: Int
}

input PaymentUpdateManyWithoutStudentInput {
  create: [PaymentCreateWithoutStudentInput!]
  delete: [PaymentWhereUniqueInput!]
  connect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  disconnect: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutStudentInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutStudentInput!]
  deleteMany: [PaymentScalarWhereInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
}

input PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput!
  data: PaymentUpdateManyDataInput!
}

input PaymentUpdateOneWithoutCardInput {
  create: PaymentCreateWithoutCardInput
  update: PaymentUpdateWithoutCardDataInput
  upsert: PaymentUpsertWithoutCardInput
  delete: Boolean
  disconnect: Boolean
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutCardDataInput {
  type: PaymentType
  date: DateTime
  amount: Int
  student: StudentUpdateOneWithoutPaymentsInput
}

input PaymentUpdateWithoutStudentDataInput {
  type: PaymentType
  date: DateTime
  amount: Int
  card: CardUpdateOneWithoutPaymentInput
}

input PaymentUpdateWithWhereUniqueWithoutStudentInput {
  where: PaymentWhereUniqueInput!
  data: PaymentUpdateWithoutStudentDataInput!
}

input PaymentUpsertWithoutCardInput {
  update: PaymentUpdateWithoutCardDataInput!
  create: PaymentCreateWithoutCardInput!
}

input PaymentUpsertWithWhereUniqueWithoutStudentInput {
  where: PaymentWhereUniqueInput!
  update: PaymentUpdateWithoutStudentDataInput!
  create: PaymentCreateWithoutStudentInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: PaymentType
  type_not: PaymentType
  type_in: [PaymentType!]
  type_not_in: [PaymentType!]
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  student: StudentWhereInput
  card: CardWhereInput
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type Query {
  absentee(where: AbsenteeWhereUniqueInput!): Absentee
  absentees(where: AbsenteeWhereInput, orderBy: AbsenteeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Absentee]!
  absenteesConnection(where: AbsenteeWhereInput, orderBy: AbsenteeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AbsenteeConnection!
  attendee(where: AttendeeWhereUniqueInput!): Attendee
  attendees(where: AttendeeWhereInput, orderBy: AttendeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attendee]!
  attendeesConnection(where: AttendeeWhereInput, orderBy: AttendeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AttendeeConnection!
  card(where: CardWhereUniqueInput!): Card
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card]!
  cardsConnection(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CardConnection!
  course(where: CourseWhereUniqueInput!): Course
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course]!
  coursesConnection(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseConnection!
  courseInstance(where: CourseInstanceWhereUniqueInput!): CourseInstance
  courseInstances(where: CourseInstanceWhereInput, orderBy: CourseInstanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseInstance]!
  courseInstancesConnection(where: CourseInstanceWhereInput, orderBy: CourseInstanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseInstanceConnection!
  courseStudent(where: CourseStudentWhereUniqueInput!): CourseStudent
  courseStudents(where: CourseStudentWhereInput, orderBy: CourseStudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseStudent]!
  courseStudentsConnection(where: CourseStudentWhereInput, orderBy: CourseStudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseStudentConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  room(where: RoomWhereUniqueInput!): Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  student(where: StudentWhereUniqueInput!): Student
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student]!
  studentsConnection(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudentConnection!
  studio(where: StudioWhereUniqueInput!): Studio
  studios(where: StudioWhereInput, orderBy: StudioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Studio]!
  studiosConnection(where: StudioWhereInput, orderBy: StudioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudioConnection!
  teacher(where: TeacherWhereUniqueInput!): Teacher
  teachers(where: TeacherWhereInput, orderBy: TeacherOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Teacher]!
  teachersConnection(where: TeacherWhereInput, orderBy: TeacherOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeacherConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Room {
  id: ID!
  name: String
  capacity: Int
  studio: Studio!
}

type RoomConnection {
  pageInfo: PageInfo!
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  name: String
  capacity: Int
  studio: StudioCreateOneWithoutRoomsInput!
}

input RoomCreateManyWithoutStudioInput {
  create: [RoomCreateWithoutStudioInput!]
  connect: [RoomWhereUniqueInput!]
}

input RoomCreateOneInput {
  create: RoomCreateInput
  connect: RoomWhereUniqueInput
}

input RoomCreateWithoutStudioInput {
  name: String
  capacity: Int
}

type RoomEdge {
  node: Room!
  cursor: String!
}

enum RoomOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  capacity_ASC
  capacity_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RoomPreviousValues {
  id: ID!
  name: String
  capacity: Int
}

input RoomScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  capacity: Int
  capacity_not: Int
  capacity_in: [Int!]
  capacity_not_in: [Int!]
  capacity_lt: Int
  capacity_lte: Int
  capacity_gt: Int
  capacity_gte: Int
  AND: [RoomScalarWhereInput!]
  OR: [RoomScalarWhereInput!]
  NOT: [RoomScalarWhereInput!]
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
  AND: [RoomSubscriptionWhereInput!]
  OR: [RoomSubscriptionWhereInput!]
  NOT: [RoomSubscriptionWhereInput!]
}

input RoomUpdateDataInput {
  name: String
  capacity: Int
  studio: StudioUpdateOneRequiredWithoutRoomsInput
}

input RoomUpdateInput {
  name: String
  capacity: Int
  studio: StudioUpdateOneRequiredWithoutRoomsInput
}

input RoomUpdateManyDataInput {
  name: String
  capacity: Int
}

input RoomUpdateManyMutationInput {
  name: String
  capacity: Int
}

input RoomUpdateManyWithoutStudioInput {
  create: [RoomCreateWithoutStudioInput!]
  delete: [RoomWhereUniqueInput!]
  connect: [RoomWhereUniqueInput!]
  set: [RoomWhereUniqueInput!]
  disconnect: [RoomWhereUniqueInput!]
  update: [RoomUpdateWithWhereUniqueWithoutStudioInput!]
  upsert: [RoomUpsertWithWhereUniqueWithoutStudioInput!]
  deleteMany: [RoomScalarWhereInput!]
  updateMany: [RoomUpdateManyWithWhereNestedInput!]
}

input RoomUpdateManyWithWhereNestedInput {
  where: RoomScalarWhereInput!
  data: RoomUpdateManyDataInput!
}

input RoomUpdateOneInput {
  create: RoomCreateInput
  update: RoomUpdateDataInput
  upsert: RoomUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: RoomWhereUniqueInput
}

input RoomUpdateWithoutStudioDataInput {
  name: String
  capacity: Int
}

input RoomUpdateWithWhereUniqueWithoutStudioInput {
  where: RoomWhereUniqueInput!
  data: RoomUpdateWithoutStudioDataInput!
}

input RoomUpsertNestedInput {
  update: RoomUpdateDataInput!
  create: RoomCreateInput!
}

input RoomUpsertWithWhereUniqueWithoutStudioInput {
  where: RoomWhereUniqueInput!
  update: RoomUpdateWithoutStudioDataInput!
  create: RoomCreateWithoutStudioInput!
}

input RoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  capacity: Int
  capacity_not: Int
  capacity_in: [Int!]
  capacity_not_in: [Int!]
  capacity_lt: Int
  capacity_lte: Int
  capacity_gt: Int
  capacity_gte: Int
  studio: StudioWhereInput
  AND: [RoomWhereInput!]
  OR: [RoomWhereInput!]
  NOT: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  id: ID
}

type Student {
  id: ID!
  name: String!
  email: String!
  mobile: String
  courses(where: CourseStudentWhereInput, orderBy: CourseStudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseStudent!]
  cards(where: CardWhereInput, orderBy: CardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Card!]
  hasReferralBonus: Boolean!
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment!]
}

type StudentConnection {
  pageInfo: PageInfo!
  edges: [StudentEdge]!
  aggregate: AggregateStudent!
}

input StudentCreateInput {
  name: String!
  email: String!
  mobile: String
  courses: CourseStudentCreateManyWithoutStudentInput
  cards: CardCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentCreateManyWithoutStudentInput
}

input StudentCreateOneInput {
  create: StudentCreateInput
  connect: StudentWhereUniqueInput
}

input StudentCreateOneWithoutCardsInput {
  create: StudentCreateWithoutCardsInput
  connect: StudentWhereUniqueInput
}

input StudentCreateOneWithoutCoursesInput {
  create: StudentCreateWithoutCoursesInput
  connect: StudentWhereUniqueInput
}

input StudentCreateOneWithoutPaymentsInput {
  create: StudentCreateWithoutPaymentsInput
  connect: StudentWhereUniqueInput
}

input StudentCreateWithoutCardsInput {
  name: String!
  email: String!
  mobile: String
  courses: CourseStudentCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentCreateManyWithoutStudentInput
}

input StudentCreateWithoutCoursesInput {
  name: String!
  email: String!
  mobile: String
  cards: CardCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentCreateManyWithoutStudentInput
}

input StudentCreateWithoutPaymentsInput {
  name: String!
  email: String!
  mobile: String
  courses: CourseStudentCreateManyWithoutStudentInput
  cards: CardCreateManyWithoutStudentInput
  hasReferralBonus: Boolean
}

type StudentEdge {
  node: Student!
  cursor: String!
}

enum StudentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  mobile_ASC
  mobile_DESC
  hasReferralBonus_ASC
  hasReferralBonus_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StudentPreviousValues {
  id: ID!
  name: String!
  email: String!
  mobile: String
  hasReferralBonus: Boolean!
}

type StudentSubscriptionPayload {
  mutation: MutationType!
  node: Student
  updatedFields: [String!]
  previousValues: StudentPreviousValues
}

input StudentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudentWhereInput
  AND: [StudentSubscriptionWhereInput!]
  OR: [StudentSubscriptionWhereInput!]
  NOT: [StudentSubscriptionWhereInput!]
}

input StudentUpdateDataInput {
  name: String
  email: String
  mobile: String
  courses: CourseStudentUpdateManyWithoutStudentInput
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentUpdateManyWithoutStudentInput
}

input StudentUpdateInput {
  name: String
  email: String
  mobile: String
  courses: CourseStudentUpdateManyWithoutStudentInput
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentUpdateManyWithoutStudentInput
}

input StudentUpdateManyMutationInput {
  name: String
  email: String
  mobile: String
  hasReferralBonus: Boolean
}

input StudentUpdateOneRequiredInput {
  create: StudentCreateInput
  update: StudentUpdateDataInput
  upsert: StudentUpsertNestedInput
  connect: StudentWhereUniqueInput
}

input StudentUpdateOneRequiredWithoutCardsInput {
  create: StudentCreateWithoutCardsInput
  update: StudentUpdateWithoutCardsDataInput
  upsert: StudentUpsertWithoutCardsInput
  connect: StudentWhereUniqueInput
}

input StudentUpdateOneRequiredWithoutCoursesInput {
  create: StudentCreateWithoutCoursesInput
  update: StudentUpdateWithoutCoursesDataInput
  upsert: StudentUpsertWithoutCoursesInput
  connect: StudentWhereUniqueInput
}

input StudentUpdateOneWithoutPaymentsInput {
  create: StudentCreateWithoutPaymentsInput
  update: StudentUpdateWithoutPaymentsDataInput
  upsert: StudentUpsertWithoutPaymentsInput
  delete: Boolean
  disconnect: Boolean
  connect: StudentWhereUniqueInput
}

input StudentUpdateWithoutCardsDataInput {
  name: String
  email: String
  mobile: String
  courses: CourseStudentUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentUpdateManyWithoutStudentInput
}

input StudentUpdateWithoutCoursesDataInput {
  name: String
  email: String
  mobile: String
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
  payments: PaymentUpdateManyWithoutStudentInput
}

input StudentUpdateWithoutPaymentsDataInput {
  name: String
  email: String
  mobile: String
  courses: CourseStudentUpdateManyWithoutStudentInput
  cards: CardUpdateManyWithoutStudentInput
  hasReferralBonus: Boolean
}

input StudentUpsertNestedInput {
  update: StudentUpdateDataInput!
  create: StudentCreateInput!
}

input StudentUpsertWithoutCardsInput {
  update: StudentUpdateWithoutCardsDataInput!
  create: StudentCreateWithoutCardsInput!
}

input StudentUpsertWithoutCoursesInput {
  update: StudentUpdateWithoutCoursesDataInput!
  create: StudentCreateWithoutCoursesInput!
}

input StudentUpsertWithoutPaymentsInput {
  update: StudentUpdateWithoutPaymentsDataInput!
  create: StudentCreateWithoutPaymentsInput!
}

input StudentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobile: String
  mobile_not: String
  mobile_in: [String!]
  mobile_not_in: [String!]
  mobile_lt: String
  mobile_lte: String
  mobile_gt: String
  mobile_gte: String
  mobile_contains: String
  mobile_not_contains: String
  mobile_starts_with: String
  mobile_not_starts_with: String
  mobile_ends_with: String
  mobile_not_ends_with: String
  courses_every: CourseStudentWhereInput
  courses_some: CourseStudentWhereInput
  courses_none: CourseStudentWhereInput
  cards_every: CardWhereInput
  cards_some: CardWhereInput
  cards_none: CardWhereInput
  hasReferralBonus: Boolean
  hasReferralBonus_not: Boolean
  payments_every: PaymentWhereInput
  payments_some: PaymentWhereInput
  payments_none: PaymentWhereInput
  AND: [StudentWhereInput!]
  OR: [StudentWhereInput!]
  NOT: [StudentWhereInput!]
}

input StudentWhereUniqueInput {
  id: ID
}

type Studio {
  id: ID!
  name: String
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room!]
  address: String
}

type StudioConnection {
  pageInfo: PageInfo!
  edges: [StudioEdge]!
  aggregate: AggregateStudio!
}

input StudioCreateInput {
  name: String
  rooms: RoomCreateManyWithoutStudioInput
  address: String
}

input StudioCreateOneWithoutRoomsInput {
  create: StudioCreateWithoutRoomsInput
  connect: StudioWhereUniqueInput
}

input StudioCreateWithoutRoomsInput {
  name: String
  address: String
}

type StudioEdge {
  node: Studio!
  cursor: String!
}

enum StudioOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  address_ASC
  address_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StudioPreviousValues {
  id: ID!
  name: String
  address: String
}

type StudioSubscriptionPayload {
  mutation: MutationType!
  node: Studio
  updatedFields: [String!]
  previousValues: StudioPreviousValues
}

input StudioSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudioWhereInput
  AND: [StudioSubscriptionWhereInput!]
  OR: [StudioSubscriptionWhereInput!]
  NOT: [StudioSubscriptionWhereInput!]
}

input StudioUpdateInput {
  name: String
  rooms: RoomUpdateManyWithoutStudioInput
  address: String
}

input StudioUpdateManyMutationInput {
  name: String
  address: String
}

input StudioUpdateOneRequiredWithoutRoomsInput {
  create: StudioCreateWithoutRoomsInput
  update: StudioUpdateWithoutRoomsDataInput
  upsert: StudioUpsertWithoutRoomsInput
  connect: StudioWhereUniqueInput
}

input StudioUpdateWithoutRoomsDataInput {
  name: String
  address: String
}

input StudioUpsertWithoutRoomsInput {
  update: StudioUpdateWithoutRoomsDataInput!
  create: StudioCreateWithoutRoomsInput!
}

input StudioWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  rooms_every: RoomWhereInput
  rooms_some: RoomWhereInput
  rooms_none: RoomWhereInput
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  AND: [StudioWhereInput!]
  OR: [StudioWhereInput!]
  NOT: [StudioWhereInput!]
}

input StudioWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  absentee(where: AbsenteeSubscriptionWhereInput): AbsenteeSubscriptionPayload
  attendee(where: AttendeeSubscriptionWhereInput): AttendeeSubscriptionPayload
  card(where: CardSubscriptionWhereInput): CardSubscriptionPayload
  course(where: CourseSubscriptionWhereInput): CourseSubscriptionPayload
  courseInstance(where: CourseInstanceSubscriptionWhereInput): CourseInstanceSubscriptionPayload
  courseStudent(where: CourseStudentSubscriptionWhereInput): CourseStudentSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  student(where: StudentSubscriptionWhereInput): StudentSubscriptionPayload
  studio(where: StudioSubscriptionWhereInput): StudioSubscriptionPayload
  teacher(where: TeacherSubscriptionWhereInput): TeacherSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Teacher {
  id: ID!
  name: String!
  email: String!
  mobile: String
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
}

type TeacherConnection {
  pageInfo: PageInfo!
  edges: [TeacherEdge]!
  aggregate: AggregateTeacher!
}

input TeacherCreateInput {
  name: String!
  email: String!
  mobile: String
  courses: CourseCreateManyWithoutTeachersInput
}

input TeacherCreateManyWithoutCoursesInput {
  create: [TeacherCreateWithoutCoursesInput!]
  connect: [TeacherWhereUniqueInput!]
}

input TeacherCreateWithoutCoursesInput {
  name: String!
  email: String!
  mobile: String
}

type TeacherEdge {
  node: Teacher!
  cursor: String!
}

enum TeacherOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  mobile_ASC
  mobile_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TeacherPreviousValues {
  id: ID!
  name: String!
  email: String!
  mobile: String
}

input TeacherScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobile: String
  mobile_not: String
  mobile_in: [String!]
  mobile_not_in: [String!]
  mobile_lt: String
  mobile_lte: String
  mobile_gt: String
  mobile_gte: String
  mobile_contains: String
  mobile_not_contains: String
  mobile_starts_with: String
  mobile_not_starts_with: String
  mobile_ends_with: String
  mobile_not_ends_with: String
  AND: [TeacherScalarWhereInput!]
  OR: [TeacherScalarWhereInput!]
  NOT: [TeacherScalarWhereInput!]
}

type TeacherSubscriptionPayload {
  mutation: MutationType!
  node: Teacher
  updatedFields: [String!]
  previousValues: TeacherPreviousValues
}

input TeacherSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeacherWhereInput
  AND: [TeacherSubscriptionWhereInput!]
  OR: [TeacherSubscriptionWhereInput!]
  NOT: [TeacherSubscriptionWhereInput!]
}

input TeacherUpdateInput {
  name: String
  email: String
  mobile: String
  courses: CourseUpdateManyWithoutTeachersInput
}

input TeacherUpdateManyDataInput {
  name: String
  email: String
  mobile: String
}

input TeacherUpdateManyMutationInput {
  name: String
  email: String
  mobile: String
}

input TeacherUpdateManyWithoutCoursesInput {
  create: [TeacherCreateWithoutCoursesInput!]
  delete: [TeacherWhereUniqueInput!]
  connect: [TeacherWhereUniqueInput!]
  set: [TeacherWhereUniqueInput!]
  disconnect: [TeacherWhereUniqueInput!]
  update: [TeacherUpdateWithWhereUniqueWithoutCoursesInput!]
  upsert: [TeacherUpsertWithWhereUniqueWithoutCoursesInput!]
  deleteMany: [TeacherScalarWhereInput!]
  updateMany: [TeacherUpdateManyWithWhereNestedInput!]
}

input TeacherUpdateManyWithWhereNestedInput {
  where: TeacherScalarWhereInput!
  data: TeacherUpdateManyDataInput!
}

input TeacherUpdateWithoutCoursesDataInput {
  name: String
  email: String
  mobile: String
}

input TeacherUpdateWithWhereUniqueWithoutCoursesInput {
  where: TeacherWhereUniqueInput!
  data: TeacherUpdateWithoutCoursesDataInput!
}

input TeacherUpsertWithWhereUniqueWithoutCoursesInput {
  where: TeacherWhereUniqueInput!
  update: TeacherUpdateWithoutCoursesDataInput!
  create: TeacherCreateWithoutCoursesInput!
}

input TeacherWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobile: String
  mobile_not: String
  mobile_in: [String!]
  mobile_not_in: [String!]
  mobile_lt: String
  mobile_lte: String
  mobile_gt: String
  mobile_gte: String
  mobile_contains: String
  mobile_not_contains: String
  mobile_starts_with: String
  mobile_not_starts_with: String
  mobile_ends_with: String
  mobile_not_ends_with: String
  courses_every: CourseWhereInput
  courses_some: CourseWhereInput
  courses_none: CourseWhereInput
  AND: [TeacherWhereInput!]
  OR: [TeacherWhereInput!]
  NOT: [TeacherWhereInput!]
}

input TeacherWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  email: String
  password: String!
  name: String!
  admin: Boolean!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  email: String
  password: String!
  name: String!
  admin: Boolean
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  admin_ASC
  admin_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String
  password: String!
  name: String!
  admin: Boolean!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  password: String
  name: String
  admin: Boolean
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  name: String
  admin: Boolean
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  admin: Boolean
  admin_not: Boolean
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
